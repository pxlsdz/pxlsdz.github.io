<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>软件过程——结构化分析</title>
      <link href="/2020/03/09/%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B%E2%80%94%E2%80%94%E7%BB%93%E6%9E%84%E5%8C%96%E5%88%86%E6%9E%90/"/>
      <url>/2020/03/09/%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B%E2%80%94%E2%80%94%E7%BB%93%E6%9E%84%E5%8C%96%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="结构化分析概述"><a href="#结构化分析概述" class="headerlink" title="结构化分析概述"></a>结构化分析概述</h1><a id="more"></a><p>​    它基于<strong>“分解”和“抽象”</strong>的基本思想，逐步建立目标系统的<strong>逻辑模型</strong>， 进而描绘出满足用户要求的软件系统。 </p><p>核心思想：      </p><p><strong>“分解”是指对于一个复杂的系统，为了将复杂性降低到可以掌握的程 度，可以把大问题分解为若干个小问题，然后再分别解决。</strong></p><p>举个例子：</p><p><img src="https://gitee.com/pxlsdz/blogImage/raw/master/img/20200311134707.png" alt=""></p><p>最顶层描述了整个目标系统 X </p><p>中间层将目标系统划分为若干个模块，每个模块完成一定的功能 </p><p>最底层是对每个模块的细节性描述 </p><p>在逐层分解的过程中，起初我们不考虑细节问题，最关注的是系统的本质属性，随着分解向下进行，才会逐步考虑越来越具体的细节——这就是抽象。</p><p><strong>总结：</strong></p><ul><li><p>结构化分析方法是一种<strong>面向数据流</strong>的需求分析方法 </p></li><li><p>结构化分析方法适合于<strong>数据处理类型软件</strong>的需求分析 </p></li><li><p>具体来说结构化分析方法就是用抽象模型的概念，按照软件内部数据传递、变换的关系，<strong>自顶向下逐层分解</strong>，直到找到满足功能要求的所有可实现的软件为止 </p></li></ul><h1 id="结构化分析方法"><a href="#结构化分析方法" class="headerlink" title="结构化分析方法"></a>结构化分析方法</h1><p>​        此模型的核心是“数据字典”，它描述软件使用或产生的所有数据对象。围绕着这个核心有3种不同的图： </p><ul><li><p>“实体-关系图”（E-R图）描绘数据对象 之间的关系，用于数据建模 </p></li><li><p>“数据流图”（DFD图）指出当数据在软 件系统中移动时怎样被变换，以及描绘变 换数据流的功能和子功能，用于功能建模 </p></li><li><p>“状态转换图”指明了作为外部事件结果 的系统行为，用于行为建模 </p></li></ul><p><img src="https://gitee.com/pxlsdz/blogImage/raw/master/img/20200311142701.png" alt=""></p><h2 id="功能建模"><a href="#功能建模" class="headerlink" title="功能建模"></a>功能建模</h2><pre><code>功能建模的思想就是用抽象模型的概念，按照软件内部数据传递和变 换的关系，自顶向下逐层分解，直到找到满足功能要求的可实现的软件 为止。功能模型用数据流图来描述。  数据流图（简称DFD图）就是采用图形方式来表达系统的逻辑功能、 数据在系统内部的逻辑流向和逻辑变换过程，是结构化系统分析方法的 主要表达工具及用于表示软件模型的一种图示方法。 </code></pre>]]></content>
      
      
      <categories>
          
          <category> 软件工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于熵权法对Topsis模型的修正</title>
      <link href="/2020/03/04/%E5%9F%BA%E4%BA%8E%E7%86%B5%E6%9D%83%E6%B3%95%E5%AF%B9Topsis%E6%A8%A1%E5%9E%8B%E7%9A%84%E4%BF%AE%E6%AD%A3/"/>
      <url>/2020/03/04/%E5%9F%BA%E4%BA%8E%E7%86%B5%E6%9D%83%E6%B3%95%E5%AF%B9Topsis%E6%A8%A1%E5%9E%8B%E7%9A%84%E4%BF%AE%E6%AD%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="引例"><a href="#引例" class="headerlink" title="引例"></a>引例</h1><a id="more"></a><p><img src="https://gitee.com/pxlsdz/blogImage/raw/master/img/20200304195221.png" alt=""></p><p>在先前的博客中，Topsis确定指标权值用的是层次分析法。</p><p>层次分析法最大的缺点判断矩阵的确定依赖于专家，如果专家的判断存在主观性的话，会对结果产生很大的影响。（<strong>主观性太强</strong>）  </p><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p><strong>熵权法是一种客观赋权方法</strong><br>        依据的原理： 指标的变异程度越⼩，所反映的信息量也越少，其对应的权值也应该越低。（客观 = 数据本身就可以告诉我们权重）<br>      （一种极端的例子：对于所有的样本而言，这个指标都是相同的数值，<br>那么我们可认为这个指标的权值为0，即这个指标对于我们的评价起不到任何帮助）。</p><h2 id="如何度量信息量的大小"><a href="#如何度量信息量的大小" class="headerlink" title="如何度量信息量的大小"></a>如何度量信息量的大小</h2><ul><li>越有可能发生的事情，信息量越少；</li><li>越不可能发生的事情，信息量就越多。</li></ul><p>怎么衡量事情发生的可能性大小？<strong>概率</strong>  </p><h1 id="信息熵的定义"><a href="#信息熵的定义" class="headerlink" title="信息熵的定义"></a>信息熵的定义</h1><p>假设x表示事件X可能发生的某种情况，p（x）表示这种情况发生的概率。</p><p>我们可以定义：I（x）= -ln（p（x）），因为0≤p（x）≤1，所以I（x）≥0。</p><p>如果事件X可能发生的情况分别为：$x_{1},x_{2},…,x_{n}$</p><p>那么我们可以定义事件X的信息熵为：<br>$$<br>H ( X ) = \sum _ { i = 1 } ^ { n } \left[ p \left( x _ { i } \right) I \left( x _ { i } \right) \right] = - \sum _ { i = 1 } ^ { n } \left[ p \left( x _ { i } \right) \ln \left( p \left( x _ { i } \right) \right) \right]<br>$$<br>从上面的公式可以看出，信息熵的本质就是对信息量的期望值。<br>可以证明的是：</p><p>当$p \left( x _ { 1 } \right) = p \left( x _ { 2 } \right) = \cdots = p \left( x _ { n } \right) = \frac { 1 } { n }$时，H(x)取最大值，此时H（x)=ln n</p><p><strong>信息熵越大，信息量是越小</strong>  </p><h1 id="熵权法的计算步骤"><a href="#熵权法的计算步骤" class="headerlink" title="熵权法的计算步骤"></a>熵权法的计算步骤</h1><ol><li><p>判断输入的矩阵中是否存在负数，如果有则要重新标准化到非负区间<br>（后面计算概率时需要保证每一个元素为非负数）  </p><p>假设有n个要评价的对象，m个评价指标（已经正向化了）构成的正向化矩阵如下：<br>$$<br>A=\begin{bmatrix}a_{11}&amp; a_{12}&amp; \cdots  &amp; a_{1n}\a_{21}&amp; a_{22}&amp; \cdots  &amp; a_{2n}\\vdots &amp; \vdots &amp; \ddots &amp; \vdots \a_{m1}&amp; a_{m2}&amp; \cdots  &amp; a_{mn}\end{bmatrix}<br>$$<br>那么，对其标准化的矩阵记为Z，Z中的每一个元素：<br>$$<br>z_{ij}=a_{ij}/ \sqrt{\sum_{i=1}^{n}a_{ij}^{2} }<br>$$<br>判断Z矩阵中是否存在着负数，如果存在的话，需要对A使用另一种标准化方法对矩阵X进行一次标准化得到之矩阵，其标准化的公式为：<br>$$<br>\tilde{z}<em>{i j}=\frac{x</em>{i j}-\min \left{x_{1 j}, x_{2 j}, \cdots, x_{n j}\right}}{\max \left{x_{1 j}, x_{2 j}, \cdots, x_{n j}\right}-\min \left{x_{1 j}, x_{2 j}, \cdots, x_{n j}\right}}<br>$$</p></li></ol><ol start="2"><li>计算第j项指标下第i个样本所占的比重，并将其看作相对熵计算中用到的概率  </li></ol><p><img src="https://gitee.com/pxlsdz/blogImage/raw/master/img/20200304222729.png" alt=""></p><ol start="3"><li><p>计算每个指标的信息熵，并计算信息效用值，并归一化得到每个指标的熵权  </p><p><img src="https://gitee.com/pxlsdz/blogImage/raw/master/img/20200304222819.png" alt=""></p></li></ol><h1 id="熵权法背后的原理"><a href="#熵权法背后的原理" class="headerlink" title="熵权法背后的原理"></a>熵权法背后的原理</h1><p>熵权法是一种客观赋权方法<br>依据的原理： 指标的变异程度越⼩，所反映的信息量也越少，其对应<br>的权值也应该越低。（客观 = 数据本身就可以告诉我们权重）  </p><p>我们可以用指标的标准差来衡量样本的变异程度，指标的标准差越大，其信息熵越小 。</p><p>下图是蒙特卡洛的结果<br>随机生成一组有30个样本且位于区间[0,1]上的数据，计算其信息熵和标准差；将上述步骤重复100次，我们能够得到100组信息熵和标准差的取值，将其绘制成散点图。可以发现，两个指标之间有很明显的负相关关系。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% 蒙特卡洛模拟：指标的标准差和信息熵成反比</span></span><br><span class="line">n = <span class="number">30</span>;  <span class="comment">% 样本个数</span></span><br><span class="line">N = <span class="number">100</span>; <span class="comment">% 试验的次数</span></span><br><span class="line">result = <span class="built_in">zeros</span>(N,<span class="number">2</span>);  <span class="comment">% 初始化用来保存信息熵和标准差的矩阵，横坐标表示信息熵，纵坐标表示标准差</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:N</span><br><span class="line">    x = <span class="built_in">rand</span>(n,<span class="number">1</span>);  <span class="comment">% 随机生成n个位于区间[0,1]上面的样本 (随机数生成是视频第四讲的内容)</span></span><br><span class="line">    p = x / sum(x);</span><br><span class="line">    e = -sum(p .* mylog(p)) / <span class="built_in">log</span>(n); <span class="comment">% 计算信息熵</span></span><br><span class="line">    sd = std(x);  <span class="comment">% 计算标准差(描述性统计是视频第五讲的内容)</span></span><br><span class="line">    result(<span class="built_in">i</span>,<span class="number">1</span>) = e;</span><br><span class="line">    result(<span class="built_in">i</span>,<span class="number">2</span>) = sd;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">plot</span>(result(:,<span class="number">1</span>),result(:,<span class="number">2</span>),<span class="string">'o'</span>)   <span class="comment">%(画图是视频第三讲的内容)</span></span><br><span class="line">xlabel(<span class="string">'信息熵'</span>)</span><br><span class="line">ylabel(<span class="string">'标准差'</span>)</span><br><span class="line">[r,p] = corrcoef(result(:,<span class="number">1</span>),result(:,<span class="number">2</span>)) <span class="comment">% 计算相关系数和对应的p值(相关系数是视频第五讲的内容)</span></span><br></pre></td></tr></table></figure><h1 id="TOPSIS代码完整实现"><a href="#TOPSIS代码完整实现" class="headerlink" title="TOPSIS代码完整实现"></a>TOPSIS代码完整实现</h1><h2 id="topsis-m"><a href="#topsis-m" class="headerlink" title="topsis.m"></a>topsis.m</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%%  第一步：把数据复制到工作区，并将这个矩阵命名为X</span></span><br><span class="line"><span class="comment">% （1）在工作区右键，点击新建（Ctrl+N)，输入变量名称为X</span></span><br><span class="line"><span class="comment">% （2）在Excel中复制数据，再回到Excel中右键，点击粘贴Excel数据（Ctrl+Shift+V）</span></span><br><span class="line"><span class="comment">% （3）关掉这个窗口，点击X变量，右键另存为，保存为mat文件（下次就不用复制粘贴了，只需使用load命令即可加载数据）</span></span><br><span class="line"><span class="comment">% （4）注意，代码和数据要放在同一个目录下哦。</span></span><br><span class="line">clear;clc</span><br><span class="line">load data_water_quality.mat</span><br><span class="line"></span><br><span class="line"><span class="comment">%%  第二步：判断是否需要正向化</span></span><br><span class="line">[n,m] = <span class="built_in">size</span>(X);</span><br><span class="line"><span class="built_in">disp</span>([<span class="string">'共有'</span> num2str(n) <span class="string">'个评价对象, '</span> num2str(m) <span class="string">'个评价指标'</span>]) </span><br><span class="line">Judge = input([<span class="string">'这'</span> num2str(m) <span class="string">'个指标是否需要经过正向化处理，需要请输入1 ，不需要输入0：  '</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> Judge == <span class="number">1</span></span><br><span class="line">    Position = input(<span class="string">'请输入需要正向化处理的指标所在的列，例如第2、3、6三列需要处理，那么你需要输入[2,3,6]： '</span>); <span class="comment">%[2,3,4]</span></span><br><span class="line">    <span class="built_in">disp</span>(<span class="string">'请输入需要处理的这些列的指标类型（1：极小型， 2：中间型， 3：区间型） '</span>)</span><br><span class="line">    Type = input(<span class="string">'例如：第2列是极小型，第3列是区间型，第6列是中间型，就输入[1,3,2]：  '</span>); <span class="comment">%[2,1,3]</span></span><br><span class="line">    <span class="comment">% 注意，Position和Type是两个同维度的行向量</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span> : <span class="built_in">size</span>(Position,<span class="number">2</span>)  <span class="comment">%这里需要对这些列分别处理，因此我们需要知道一共要处理的次数，即循环的次数</span></span><br><span class="line">        X(:,Position(<span class="built_in">i</span>)) = Positivization(X(:,Position(<span class="built_in">i</span>)),Type(<span class="built_in">i</span>),Position(<span class="built_in">i</span>));</span><br><span class="line">    <span class="comment">% Positivization是我们自己定义的函数，其作用是进行正向化，其一共接收三个参数</span></span><br><span class="line">    <span class="comment">% 第一个参数是要正向化处理的那一列向量 X(:,Position(i))   回顾上一讲的知识，X(:,n)表示取第n列的全部元素</span></span><br><span class="line">    <span class="comment">% 第二个参数是对应的这一列的指标类型（1：极小型， 2：中间型， 3：区间型）</span></span><br><span class="line">    <span class="comment">% 第三个参数是告诉函数我们正在处理的是原始矩阵中的哪一列</span></span><br><span class="line">    <span class="comment">% 该函数有一个返回值，它返回正向化之后的指标，我们可以将其直接赋值给我们原始要处理的那一列向量</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="built_in">disp</span>(<span class="string">'正向化后的矩阵 X =  '</span>)</span><br><span class="line">    <span class="built_in">disp</span>(X)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">%% 作业：在这里增加是否需要算加权</span></span><br><span class="line"><span class="comment">% 补充一个基础知识：m*n维的矩阵A 点乘 n维行向量B，等于这个A的每一行都点乘B</span></span><br><span class="line"><span class="comment">% （注意：2017以及之后版本的Matlab才支持，老版本Matlab会报错）</span></span><br><span class="line"><span class="comment">% % 假如原始数据为：</span></span><br><span class="line"><span class="comment">%   A=[1, 2, 3;</span></span><br><span class="line"><span class="comment">%        2, 4, 6] </span></span><br><span class="line"><span class="comment">% % 权重矩阵为：</span></span><br><span class="line"><span class="comment">%   B=[ 0.2, 0.5 ,0.3 ] </span></span><br><span class="line"><span class="comment">% % 加权后为：</span></span><br><span class="line"><span class="comment">%   C=A .* B</span></span><br><span class="line"><span class="comment">%     0.2000    1.0000    0.9000</span></span><br><span class="line"><span class="comment">%     0.4000    2.0000    1.8000</span></span><br><span class="line"><span class="comment">% 类似的，还有矩阵和向量的点除， 大家可以自己试试计算A ./ B</span></span><br><span class="line"><span class="comment">% 注意，矩阵和向量没有 .- 和 .+ 哦 ，大家可以试试，如果计算A.+B 和 A.-B会报什么错误。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 这里补充一个小插曲</span></span><br><span class="line"><span class="comment">% % 在上一讲层次分析法的代码中，我们可以优化以下的语句：</span></span><br><span class="line"><span class="comment">% % Sum_A = sum(A);</span></span><br><span class="line"><span class="comment">% % SUM_A = repmat(Sum_A,n,1);</span></span><br><span class="line"><span class="comment">% % Stand_A = A ./ SUM_A;</span></span><br><span class="line"><span class="comment">% % 事实上，我们把第三行换成：Stand_A = A ./ Sum_A; 也是可以的哦 </span></span><br><span class="line"><span class="comment">% % (再次强调，新版本的Matlab才能运行哦)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 第三步：对正向化后的矩阵进行标准化</span></span><br><span class="line">Z = X ./ <span class="built_in">repmat</span>(sum(X.*X) .^ <span class="number">0.5</span>, n, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">disp</span>(<span class="string">'标准化矩阵 Z = '</span>)</span><br><span class="line"><span class="built_in">disp</span>(Z)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 让用户判断是否需要增加权重</span></span><br><span class="line"><span class="built_in">disp</span>(<span class="string">"请输入是否需要增加权重向量，需要输入1，不需要输入0"</span>)</span><br><span class="line">Judge = input(<span class="string">'请输入是否需要增加权重： '</span>);</span><br><span class="line"><span class="keyword">if</span> Judge == <span class="number">1</span></span><br><span class="line">    Judge = input(<span class="string">'使用熵权法确定权重请输入1，否则输入0： '</span>);</span><br><span class="line">    <span class="keyword">if</span> Judge == <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> sum(sum(Z&lt;<span class="number">0</span>)) &gt;<span class="number">0</span>   <span class="comment">% 如果之前标准化后的Z矩阵中存在负数，则重新对X进行标准化</span></span><br><span class="line">            <span class="built_in">disp</span>(<span class="string">'原来标准化得到的Z矩阵中存在负数，所以需要对X重新标准化'</span>)</span><br><span class="line">            <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:n</span><br><span class="line">                <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:m</span><br><span class="line">                    Z(<span class="built_in">i</span>,<span class="built_in">j</span>) = [X(<span class="built_in">i</span>,<span class="built_in">j</span>) - <span class="built_in">min</span>(X(:,<span class="built_in">j</span>))] / [<span class="built_in">max</span>(X(:,<span class="built_in">j</span>)) - <span class="built_in">min</span>(X(:,<span class="built_in">j</span>))];</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="built_in">disp</span>(<span class="string">'X重新进行标准化得到的标准化矩阵Z为:  '</span>)</span><br><span class="line">            <span class="built_in">disp</span>(Z)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        weight = Entropy_Method(Z);</span><br><span class="line">        <span class="built_in">disp</span>(<span class="string">'熵权法确定的权重为：'</span>)</span><br><span class="line">        <span class="built_in">disp</span>(weight)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">disp</span>([<span class="string">'如果你有3个指标，你就需要输入3个权重，例如它们分别为0.25,0.25,0.5, 则你需要输入[0.25,0.25,0.5]'</span>]);</span><br><span class="line">        weight = input([<span class="string">'你需要输入'</span> num2str(m) <span class="string">'个权数。'</span> <span class="string">'请以行向量的形式输入这'</span> num2str(m) <span class="string">'个权重: '</span>]);</span><br><span class="line">        OK = <span class="number">0</span>;  <span class="comment">% 用来判断用户的输入格式是否正确</span></span><br><span class="line">        <span class="keyword">while</span> OK == <span class="number">0</span> </span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">abs</span>(sum(weight) <span class="number">-1</span>)&lt;<span class="number">0.000001</span> &amp;&amp; <span class="built_in">size</span>(weight,<span class="number">1</span>) == <span class="number">1</span> &amp;&amp; <span class="built_in">size</span>(weight,<span class="number">2</span>) == m  <span class="comment">% 注意，Matlab中浮点数的比较要小心</span></span><br><span class="line">                OK =<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                weight = input(<span class="string">'你输入的有误，请重新输入权重行向量: '</span>);</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    weight = <span class="built_in">ones</span>(<span class="number">1</span>,m) ./ m ; <span class="comment">%如果不需要加权重就默认权重都相同，即都为1/m</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 第四步：计算与最大值的距离和最小值的距离，并算出得分</span></span><br><span class="line">D_P = sum([(Z - <span class="built_in">repmat</span>(<span class="built_in">max</span>(Z),n,<span class="number">1</span>)) .^ <span class="number">2</span> ] .* <span class="built_in">repmat</span>(weight,n,<span class="number">1</span>) ,<span class="number">2</span>) .^ <span class="number">0.5</span>;   <span class="comment">% D+ 与最大值的距离向量</span></span><br><span class="line">D_N = sum([(Z - <span class="built_in">repmat</span>(<span class="built_in">min</span>(Z),n,<span class="number">1</span>)) .^ <span class="number">2</span> ] .* <span class="built_in">repmat</span>(weight,n,<span class="number">1</span>) ,<span class="number">2</span>) .^ <span class="number">0.5</span>;   <span class="comment">% D- 与最小值的距离向量</span></span><br><span class="line">S = D_N ./ (D_P+D_N);    <span class="comment">% 未归一化的得分</span></span><br><span class="line"><span class="built_in">disp</span>(<span class="string">'最后的得分为：'</span>)</span><br><span class="line">stand_S = S / sum(S)</span><br><span class="line">[sorted_S,index] = <span class="built_in">sort</span>(stand_S ,<span class="string">'descend'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">% A = magic(5)  % 幻方矩阵</span></span><br><span class="line"><span class="comment">% M = magic(n)返回由1到n^2的整数构成并且总行数和总列数相等的n×n矩阵。阶次n必须为大于或等于3的标量。</span></span><br><span class="line"><span class="comment">% sort(A)若A是向量不管是列还是行向量，默认都是对A进行升序排列。sort(A)是默认的升序，而sort(A,'descend')是降序排序。</span></span><br><span class="line"><span class="comment">% sort(A)若A是矩阵，默认对A的各列进行升序排列</span></span><br><span class="line"><span class="comment">% sort(A,dim)</span></span><br><span class="line"><span class="comment">% dim=1时等效sort(A)</span></span><br><span class="line"><span class="comment">% dim=2时表示对A中的各行元素升序排列</span></span><br><span class="line"><span class="comment">% A = [2,1,3,8]</span></span><br><span class="line"><span class="comment">% Matlab中给一维向量排序是使用sort函数：sort（A），排序是按升序进行的，其中A为待排序的向量；</span></span><br><span class="line"><span class="comment">% 若欲保留排列前的索引，则可用 [sA,index] = sort(A,'descend') ，排序后，sA是排序好的向量，index是向量sA中对A的索引。</span></span><br><span class="line"><span class="comment">% sA  =  8     3     2     1</span></span><br><span class="line"><span class="comment">% index =  4     3     1     2</span></span><br></pre></td></tr></table></figure><h2 id="Inter2Max-m"><a href="#Inter2Max-m" class="headerlink" title="Inter2Max.m"></a>Inter2Max.m</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[posit_x]</span> = <span class="title">Inter2Max</span><span class="params">(x,a,b)</span></span></span><br><span class="line">    r_x = <span class="built_in">size</span>(x,<span class="number">1</span>);  <span class="comment">% row of x </span></span><br><span class="line">    M = <span class="built_in">max</span>([a-<span class="built_in">min</span>(x),<span class="built_in">max</span>(x)-b]);</span><br><span class="line">    posit_x = <span class="built_in">zeros</span>(r_x,<span class="number">1</span>);   <span class="comment">%zeros函数用法: zeros(3)  zeros(3,1)  ones(3)</span></span><br><span class="line">    <span class="comment">% 初始化posit_x全为0  初始化的目的是节省处理时间</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>: r_x</span><br><span class="line">        <span class="keyword">if</span> x(<span class="built_in">i</span>) &lt; a</span><br><span class="line">           posit_x(<span class="built_in">i</span>) = <span class="number">1</span>-(a-x(<span class="built_in">i</span>))/M;</span><br><span class="line">        <span class="keyword">elseif</span> x(<span class="built_in">i</span>) &gt; b</span><br><span class="line">           posit_x(<span class="built_in">i</span>) = <span class="number">1</span>-(x(<span class="built_in">i</span>)-b)/M;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">           posit_x(<span class="built_in">i</span>) = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="Mid2Max-m"><a href="#Mid2Max-m" class="headerlink" title="Mid2Max.m"></a>Mid2Max.m</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[posit_x]</span> = <span class="title">Mid2Max</span><span class="params">(x,best)</span></span></span><br><span class="line">    M = <span class="built_in">max</span>(<span class="built_in">abs</span>(x-best));</span><br><span class="line">    posit_x = <span class="number">1</span> - <span class="built_in">abs</span>(x-best) / M;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="Min2Max-m"><a href="#Min2Max-m" class="headerlink" title="Min2Max.m"></a>Min2Max.m</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[posit_x]</span> = <span class="title">Min2Max</span><span class="params">(x)</span></span></span><br><span class="line">    posit_x = <span class="built_in">max</span>(x) - x;</span><br><span class="line">     <span class="comment">%posit_x = 1 ./ x;    %如果x全部都大于0，也可以这样正向化</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="Positivization-m"><a href="#Positivization-m" class="headerlink" title="Positivization.m"></a>Positivization.m</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% function [输出变量] = 函数名称(输入变量）  </span></span><br><span class="line"><span class="comment">% 函数的中间部分都是函数体</span></span><br><span class="line"><span class="comment">% 函数的最后要用end结尾</span></span><br><span class="line"><span class="comment">% 输出变量和输入变量可以有多个，用逗号隔开</span></span><br><span class="line"><span class="comment">% function [a,b,c]=test(d,e,f)</span></span><br><span class="line"><span class="comment">%     a=d+e;</span></span><br><span class="line"><span class="comment">%     b=e+f;</span></span><br><span class="line"><span class="comment">%     c=f+d;</span></span><br><span class="line"><span class="comment">% end</span></span><br><span class="line"><span class="comment">% 自定义的函数要单独放在一个m文件中，不可以直接放在主函数里面（和其他大多数语言不同）</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[posit_x]</span> = <span class="title">Positivization</span><span class="params">(x,type,i)</span></span></span><br><span class="line"><span class="comment">% 输入变量有三个：</span></span><br><span class="line"><span class="comment">% x：需要正向化处理的指标对应的原始列向量</span></span><br><span class="line"><span class="comment">% type： 指标的类型（1：极小型， 2：中间型， 3：区间型）</span></span><br><span class="line"><span class="comment">% i: 正在处理的是原始矩阵中的哪一列</span></span><br><span class="line"><span class="comment">% 输出变量posit_x表示：正向化后的列向量</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span> == <span class="number">1</span>  <span class="comment">%极小型</span></span><br><span class="line">        <span class="built_in">disp</span>([<span class="string">'第'</span> num2str(<span class="built_in">i</span>) <span class="string">'列是极小型，正在正向化'</span>] )</span><br><span class="line">        posit_x = Min2Max(x);  <span class="comment">%调用Min2Max函数来正向化</span></span><br><span class="line">        <span class="built_in">disp</span>([<span class="string">'第'</span> num2str(<span class="built_in">i</span>) <span class="string">'列极小型正向化处理完成'</span>] )</span><br><span class="line">        <span class="built_in">disp</span>(<span class="string">'~~~~~~~~~~~~~~~~~~~~分界线~~~~~~~~~~~~~~~~~~~~'</span>)</span><br><span class="line">    <span class="keyword">elseif</span> <span class="built_in">type</span> == <span class="number">2</span>  <span class="comment">%中间型</span></span><br><span class="line">        <span class="built_in">disp</span>([<span class="string">'第'</span> num2str(<span class="built_in">i</span>) <span class="string">'列是中间型'</span>] )</span><br><span class="line">        best = input(<span class="string">'请输入最佳的那一个值： '</span>);</span><br><span class="line">        posit_x = Mid2Max(x,best);</span><br><span class="line">        <span class="built_in">disp</span>([<span class="string">'第'</span> num2str(<span class="built_in">i</span>) <span class="string">'列中间型正向化处理完成'</span>] )</span><br><span class="line">        <span class="built_in">disp</span>(<span class="string">'~~~~~~~~~~~~~~~~~~~~分界线~~~~~~~~~~~~~~~~~~~~'</span>)</span><br><span class="line">    <span class="keyword">elseif</span> <span class="built_in">type</span> == <span class="number">3</span>  <span class="comment">%区间型</span></span><br><span class="line">        <span class="built_in">disp</span>([<span class="string">'第'</span> num2str(<span class="built_in">i</span>) <span class="string">'列是区间型'</span>] )</span><br><span class="line">        a = input(<span class="string">'请输入区间的下界： '</span>);</span><br><span class="line">        b = input(<span class="string">'请输入区间的上界： '</span>); </span><br><span class="line">        posit_x = Inter2Max(x,a,b);</span><br><span class="line">        <span class="built_in">disp</span>([<span class="string">'第'</span> num2str(<span class="built_in">i</span>) <span class="string">'列区间型正向化处理完成'</span>] )</span><br><span class="line">        <span class="built_in">disp</span>(<span class="string">'~~~~~~~~~~~~~~~~~~~~分界线~~~~~~~~~~~~~~~~~~~~'</span>)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">disp</span>(<span class="string">'没有这种类型的指标，请检查Type向量中是否有除了1、2、3之外的其他值'</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="mylog-m"><a href="#mylog-m" class="headerlink" title="mylog.m"></a>mylog.m</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 重新定义一个mylog函数，当输入的p中元素为0时，返回0</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[lnp]</span> =  <span class="title">mylog</span><span class="params">(p)</span></span></span><br><span class="line">n = <span class="built_in">length</span>(p);   <span class="comment">% 向量的长度</span></span><br><span class="line">lnp = <span class="built_in">zeros</span>(n,<span class="number">1</span>);   <span class="comment">% 初始化最后的结果</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:n   <span class="comment">% 开始循环</span></span><br><span class="line">        <span class="keyword">if</span> p(<span class="built_in">i</span>) == <span class="number">0</span>   <span class="comment">% 如果第i个元素为0</span></span><br><span class="line">            lnp(<span class="built_in">i</span>) = <span class="number">0</span>;  <span class="comment">% 那么返回的第i个结果也为0</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            lnp(<span class="built_in">i</span>) = <span class="built_in">log</span>(p(<span class="built_in">i</span>));  </span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="Entropy-Method-m"><a href="#Entropy-Method-m" class="headerlink" title="Entropy_Method.m"></a>Entropy_Method.m</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[W]</span> = <span class="title">Entropy_Method</span><span class="params">(Z)</span></span></span><br><span class="line"><span class="comment">% 计算有n个样本，m个指标的样本所对应的的熵权</span></span><br><span class="line"><span class="comment">% 输入</span></span><br><span class="line"><span class="comment">% Z ： n*m的矩阵（要经过正向化和标准化处理，且元素中不存在负数）</span></span><br><span class="line"><span class="comment">% 输出</span></span><br><span class="line"><span class="comment">% W：熵权，m*1的行向量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 计算熵权</span></span><br><span class="line">    [n,m] = <span class="built_in">size</span>(Z);</span><br><span class="line">    D = <span class="built_in">zeros</span>(<span class="number">1</span>,m);  <span class="comment">% 初始化保存信息效用值的行向量</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:m</span><br><span class="line">        x = Z(:,<span class="built_in">i</span>);  <span class="comment">% 取出第i列的指标</span></span><br><span class="line">        p = x / sum(x);</span><br><span class="line">        <span class="comment">% 注意，p有可能为0，此时计算ln(p)*p时，Matlab会返回NaN，所以这里我们自己定义一个函数</span></span><br><span class="line">        e = -sum(p .* mylog(p)) / <span class="built_in">log</span>(n); <span class="comment">% 计算信息熵</span></span><br><span class="line">        D(<span class="built_in">i</span>) = <span class="number">1</span>- e; <span class="comment">% 计算信息效用值</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    W = D ./ sum(D);  <span class="comment">% 将信息效用值归一化，得到权重    </span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MATLAB </tag>
            
            <tag> 评价模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机专业英语--MEMORY SYSTEMS</title>
      <link href="/2020/03/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%8B%B1%E8%AF%AD--MEMORY%20SYSTEMS/"/>
      <url>/2020/03/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%8B%B1%E8%AF%AD--MEMORY%20SYSTEMS/</url>
      
        <content type="html"><![CDATA[<h1 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h1><p> <strong>Main point:</strong></p><a id="more"></a><p>​    ● Memory system specifications</p><p>​    ● Hierarchical structure of memory</p><p>​      ● Devices and operation of memory</p><p>​    * RAM       * Magnetic recording devices</p><p>​    * ROM         ● Magnetic disk</p><p>​    * Cache         ●  Magnetic tape</p><p>​    * CD-ROM</p><p>​      </p><ol><li><p><strong>hierarchical memory</strong>     存储器层次结构  </p></li><li><p><strong>cash</strong>  高速缓冲存储器,高速缓存</p></li><li><p><strong>chip</strong>    芯片</p></li><li><p><strong>magnetic disk</strong>             磁盘</p></li><li><p><strong>main memory</strong>             主存储器</p></li><li><p><strong>paged virtual memory</strong>      页式虚拟存储器</p><p>segment</p></li><li><p><strong>boot</strong>     引导，启动，自举</p></li><li><p><strong>latency</strong>        潜伏时间、等待时间 ，延迟       </p></li><li><p><strong>page frame</strong>     页帧     </p></li><li><p><strong>volatile</strong>   易失性</p></li><li><p><strong>laser storage</strong>   激光存储器</p></li></ol><hr><p>以上为关键单词</p><ol start="12"><li>approximated. 近似的</li><li>分子基数词，分母序数词，当分子超过1的时候，把s往分母加，把：eg two thirds；three sevenths</li></ol>]]></content>
      
      
      <categories>
          
          <category> 英语 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络测试与分析--综合布线系统</title>
      <link href="/2020/03/04/%E7%BD%91%E7%BB%9C%E6%B5%8B%E8%AF%95%E4%B8%8E%E5%88%86%E6%9E%90--%E7%BB%BC%E5%90%88%E5%B8%83%E7%BA%BF%E7%B3%BB%E7%BB%9F/"/>
      <url>/2020/03/04/%E7%BD%91%E7%BB%9C%E6%B5%8B%E8%AF%95%E4%B8%8E%E5%88%86%E6%9E%90--%E7%BB%BC%E5%90%88%E5%B8%83%E7%BA%BF%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="综合布线系统基础"><a href="#综合布线系统基础" class="headerlink" title="综合布线系统基础"></a>综合布线系统基础</h1><a id="more"></a><p>综合布线系统是由<strong>线缆及相关连接硬组成</strong>的信息传输的通道，是智能建筑连接“3A”系统各类信息必备的基础设施，是“建效物内的信息高速路”。</p><p>综合布线系统由六个子系统组成：</p><ul><li>1、工作区子系统</li></ul><ul><li><p>2、水平布线子系统</p></li><li><p>3、管理间子系统</p></li><li><p>4、垂直干线子系统</p></li><li><p>5、设备间子系统</p></li><li><p>6、建筑群子系统</p></li></ul><h1 id="综合布线系统的传输介质"><a href="#综合布线系统的传输介质" class="headerlink" title="综合布线系统的传输介质"></a>综合布线系统的传输介质</h1><h2 id="双绞线"><a href="#双绞线" class="headerlink" title="双绞线"></a>双绞线</h2><p><strong>各线对按一定密度互相绞在一起的目的</strong>：降低信号干扰的程度，每一根导线在传输中辐射出来的电波会被另一根线上发出的电波抵消。</p><p>双绞线可分为非屏蔽双绞线（UTP）和屏蔽双绞线（STP）。<br>屏蔽双绞线电缆的外层由铝箔包裹，相对非屏蔽双绞。线具有更好的抗电磁干扰能力，造价也相对高一些。</p><p>直通线与交叉线</p><ul><li><p>直通线适用于计算机到集线设备的连接。</p></li><li><p>交叉线适用于计算机与计算机的连接。</p></li></ul><h2 id="大对数线"><a href="#大对数线" class="headerlink" title="大对数线"></a>大对数线</h2><h2 id="光纤与光缆"><a href="#光纤与光缆" class="headerlink" title="光纤与光缆"></a>光纤与光缆</h2><ol><li><p>损耗<br>是指光纤单位长度上的衰减，单位db/km。光纤损耗的高低直接影响传输距离或中继站距离的远近。</p></li><li><p>色散<br>也称弥散，是指光纤传输中光信号达到一定距离后必然产生的信号失真。</p></li></ol><p>根据光纤传输点模数分类：单模光纤和多模光纤</p><h1 id="综合布线系统工程设计"><a href="#综合布线系统工程设计" class="headerlink" title="综合布线系统工程设计."></a>综合布线系统工程设计.</h1>]]></content>
      
      
      <categories>
          
          <category> 网络测试与分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课堂笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>人工智能——知识表示</title>
      <link href="/2020/03/03/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E2%80%94%E2%80%94%E7%9F%A5%E8%AF%86%E8%A1%A8%E7%A4%BA/"/>
      <url>/2020/03/03/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E2%80%94%E2%80%94%E7%9F%A5%E8%AF%86%E8%A1%A8%E7%A4%BA/</url>
      
        <content type="html"><![CDATA[<p>“知识的表示”是传统人工智能学科的基石，一定要掌握</p><ul><li>（1）常用的知识表示方法，每种知识表示方法的基本原理；</li><li>（2）知识的特点/特征，</li><li>（3）一阶谓词逻辑表示法。</li></ul><p>以上3个知识点是本节的重点</p><a id="more"></a><h1 id="知识与知识表示的概念"><a href="#知识与知识表示的概念" class="headerlink" title="知识与知识表示的概念"></a>知识与知识表示的概念</h1><p>知识：把有关信息<strong>关联</strong>在一起所形成的信息结构</p><h2 id="知识的特性"><a href="#知识的特性" class="headerlink" title="知识的特性"></a>知识的特性</h2><ol><li><p>相对正确性</p><p>任何知识都是在<strong>一定的条件及环境</strong>下产生的，在这种条件及环境下才是正确的。</p><p>1+1=10（二进制）</p><p>1+1=2 （十进制）</p></li><li><p>不确定性</p><p>“真”与“假”之间的中间状态,eg：可能感冒了。</p></li></ol><p>   引起原因：</p><p>   ①随机性引起的不确定性（可能感冒了）<br>   ②模糊性引起的不确定性（学习挺好，大方向是对的）<br>   ③经验引起的不确定性<br>   ④不完全性引起的不确定性</p><ol start="3"><li><p>可表示性与可利用性</p><p>知识的可表示性：知识可以用适当形式表示出来，如用语言、文字、图形、神经网络等。<br>知识的可利用性：知识可以被利用。</p></li></ol><h2 id="知识分类"><a href="#知识分类" class="headerlink" title="知识分类"></a>知识分类</h2><ol><li><p>按知识的作用范围</p><ul><li>常识性知识：通用性知识</li><li>领域性知识：专业性的知识</li></ul></li><li><p>按知识的作用及表示</p><ul><li><p>事实性知识：有关概念、事实、事物的属性及状态等。</p></li><li><p>过程性知识：有关系统状态变化、问题求解过程的操作、演算和行动的知识。</p></li><li><p>控制性知识（深层知识或元知识）：关于如何运用已有的知识进行问题求解的知识。</p></li></ul><p>例子：<br>从北京到上海是乘飞机还是火车的问题表示如下：</p><ul><li><p>事实性知识：北京、上海、飞机、时间、费用</p></li><li><p>过程性知识：乘飞机、坐火车</p></li><li><p>控制性知识：乘坐飞机较快、较贵。坐火车较慢、较便宜</p></li></ul></li><li><p>按知识的结构及表现形式</p><ul><li>逻辑性知识：反映人类逻辑思维过程的知识</li><li>形象性知识：通过事物的形象建立起来的知识</li></ul></li><li><p>按知识的确定性</p><ul><li><p>确定性知识：可指出其真值为“真”或“假”的知识，是精确性的知识。</p></li><li><p>不确定性知识：具有不精确、不完全及模糊性等特性的知识。</p></li></ul></li></ol><h2 id="知识表示"><a href="#知识表示" class="headerlink" title="知识表示"></a>知识表示</h2><p>知识表示（Knowledge Representation）：将人类知识形式化或者模型化。</p><p>知识表示是对知识的一种描述，或者说是一组约定，一种计算机可以接受的用于描述知识的数据结构。</p><p>选择知识表示方法的原则：</p><p>①充分表示领域知识<br>②有利于对知识的利用<br>③便于对知识的组织、维护与管理<br>④便于理解与实现</p><h1 id="一阶谓词逻辑表示法"><a href="#一阶谓词逻辑表示法" class="headerlink" title="一阶谓词逻辑表示法"></a>一阶谓词逻辑表示法</h1><h2 id="命题"><a href="#命题" class="headerlink" title="命题"></a>命题</h2><p>一个非真即假的陈述句。</p><p>一个命题可以在一种条件下为真，早另一种条件下为假。</p><h2 id="谓词"><a href="#谓词" class="headerlink" title="谓词"></a>谓词</h2><p>谓词的一般形式：<br>$$<br>P(x_{1},x_{1},…,x_{n})<br>$$<br><strong>个体$x_{1},x_{1},…,x_{n}$</strong>:某个独立存在的事物或者某一个抽象的概念。</p><p><strong>谓词名P</strong>：刻划个体的性质、状态或个体间的关系。</p><ol><li><p>个体是常量：一个或者一组指定的个体。</p><p><strong>“老张是一个教师”</strong>：一元谓词Teacher（zhang）<br><strong>“5&gt;3”</strong>：二元谓词Greater（5，3）<br><strong>“Smith”</strong>:作为一个工程师为IBM工作”：<br>三元谓词Works（smith，IBM，engineer）</p></li><li><p>个体是变元（变量）：没有指定的一个或者一组个体。</p><p>“x&lt;5”：Less（x,5）</p></li><li><p>个体是函数：一个个体到另一个个体的映射。<br>“小李的父亲是教师”：Teacher（father（（li））</p></li></ol><ol start="4"><li>个体是谓词<br>“Smith作为一个工程师为IBM工作”：<br>二阶谓词Works（Engineer（smith），IBM）</li></ol><h2 id="谓词公式"><a href="#谓词公式" class="headerlink" title="谓词公式"></a>谓词公式</h2><h3 id="连接词（连词）"><a href="#连接词（连词）" class="headerlink" title="连接词（连词）"></a>连接词（连词）</h3><p>（1）┐： “否定”（Negation）或“非”。</p><p>（2）V:     “析取”（Disjunction）“或”</p><p>（3）∧:      “合取”（Conjunction）“与”</p><p>（4）-&gt;：“蕴含”（Implication）或“条件”</p><p>​        “如果刘华跑得最快，那么他取得冠军。”：<br>​         RUNS（LIUHUA，FASTER）→WINS（LIUHUA，CHAMPION）</p><p>（5）<strong>⇔</strong>：“等价”（Equivalence）或“双条件”（Bicondition）。<br>        P<strong>⇔</strong>Q:“P当且仅当Q”。</p><p><img src="https://gitee.com/pxlsdz/blogImage/raw/master/img/20200303165609.png" alt=""></p><h3 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h3><ol><li><p>全称量词（Universal quantifier）（∀x）：“对个体域中的所有（或任一个）个体x”。</p><p>例子：“所有的机器人都是灰色的”<br>（∀x）[ROBOT（x）-&gt;COLOR（x，GRAY）]</p></li><li><p>存在量词（Existential quantifier）（∃x）：“在个体域中存在个体x”。</p><p>例子：“1号房间有个物体”<br>（∃x）INROOM（x，r1）</p></li></ol><p>全称量词和存在量词举例：</p><ul><li>(∀x)(∃y)F(x,y)表示对于个体域中的任何个体x都存在个体y，x与y是朋友。</li><li>(∃x)(∀y)F(x,y)表示在个体域中存在个体x，与个体域中的任何个体y都是朋友。</li><li>(∃x)(∃y)F(x,y)表示在个体域中存在个体x与个体y，x与y是朋友。</li><li>(∀x)(∀y)F(x,y)表示对于个体域中的任何两个个体s和y，x与y都是朋友。</li></ul><p>全称量词和存在量词出现的次序将影响命题的意思例如：<br><img src="https://gitee.com/pxlsdz/blogImage/raw/master/img/20200303170621.png" alt=""></p><h3 id="谓词公式-1"><a href="#谓词公式-1" class="headerlink" title="谓词公式"></a>谓词公式</h3><p><img src="https://gitee.com/pxlsdz/blogImage/raw/master/img/20200303170744.png" alt=""></p><h3 id="量词的辖域"><a href="#量词的辖域" class="headerlink" title="量词的辖域"></a>量词的辖域</h3><ul><li>量词的辖域：位于量词后面的单个谓词或者用括弧括起来的谓词公式。</li><li>约束变元与自由变元：辖域内与量词中同名的变元称为约束变元，不同名的变元称为自由变元。</li></ul><p><img src="https://gitee.com/pxlsdz/blogImage/raw/master/img/20200303170944.png" alt=""></p><h2 id="谓词公式的性质"><a href="#谓词公式的性质" class="headerlink" title="谓词公式的性质"></a>谓词公式的性质</h2><h3 id="谓词公式的解释"><a href="#谓词公式的解释" class="headerlink" title="谓词公式的解释"></a>谓词公式的解释</h3><p>谓词公式在个体域上的解释：个体域中的实体对谓词演算表达式的每个常量、变量、谓词和函数符号的指派。</p><h3 id="谓词公式的永真性、可满足性、不可满足性"><a href="#谓词公式的永真性、可满足性、不可满足性" class="headerlink" title="谓词公式的永真性、可满足性、不可满足性"></a>谓词公式的永真性、可满足性、不可满足性</h3><ul><li>定义2.3如果谓词公式P，对个体域D上的任何一个解释都取得真值T，则称P在D上是永真的；如果P在每个非空个体域上均永真，则称P永真。</li><li>定义2.4如果谓词公式P，对个体域D上的任何一个解释都取得真值F，则称P在D上是永假的；如果P在每个非空个体域上均永假，则称P永假。</li><li>定义2.5对于谓词公式P，如果至少存在一个解释使得P在此解释下的真值为T，则称P是可满足的，否则，则称P是不可满足的。</li></ul><h3 id="谓词公式的等价性"><a href="#谓词公式的等价性" class="headerlink" title="谓词公式的等价性"></a>谓词公式的等价性</h3><p>定义2.6 设P与Q是两个谓词公式，D是它们共同的个体域，若对D上的任何一个解释，P与Q都有相同的真值，则称公式P和Q在D上是等价的。如果D是任意个体域，则称P和Q是等价的，记作P<strong>⇔</strong>Q。</p><p>（4）德.摩根律（De.Morgen）</p><p>（8）连接词化规律（蕴含、等价等值式）</p><p>（10）量词转换律面</p><h3 id="谓词公式的永真蕴含"><a href="#谓词公式的永真蕴含" class="headerlink" title="谓词公式的永真蕴含"></a>谓词公式的永真蕴含</h3><p>定义2.7 对于谓词公式P与Q，如果P-&gt;Q永真，则称公式P永真蕴含Q，且称Q为P的逻辑结论，称P为Q的前提，记作P=&gt;Q。<br>（3）假言推理</p><p>（4）拒取式推理</p><p>（5）假言三段论</p><p>谓词逻辑的其他推理规则：<br>①P规则：在推理的任何步骤上都可引入前提。</p><p>②T规则：在推理过程中，如果前面步骤中有一个或多个公式永真蕴含公式S，则可把S引入惟理过程中。</p><p>③CP规则：如果能从任意引入的命题R和前提集合中推出S来，则可从前提集合推出R-&gt;S来。</p><p><img src="https://gitee.com/pxlsdz/blogImage/raw/master/img/20200303171944.png" alt=""></p><p><img src="https://gitee.com/pxlsdz/blogImage/raw/master/img/20200303172101.png" alt=""></p><h2 id="一阶谓词逻辑知识表示方法"><a href="#一阶谓词逻辑知识表示方法" class="headerlink" title="一阶谓词逻辑知识表示方法"></a>一阶谓词逻辑知识表示方法</h2><h2 id="一阶谓词逻辑表示法的特点"><a href="#一阶谓词逻辑表示法的特点" class="headerlink" title="一阶谓词逻辑表示法的特点"></a>一阶谓词逻辑表示法的特点</h2><h1 id="产生式表示法"><a href="#产生式表示法" class="headerlink" title="产生式表示法"></a>产生式表示法</h1><h2 id="产生式"><a href="#产生式" class="headerlink" title="产生式"></a>产生式</h2><p>​       产生式通常用于表示事实、规则以及它们的不确定性度量，适合于表示事实性知识和规则性知识。</p><ol><li><p>确定性规则知识的产生式表示</p><p><img src="https://gitee.com/pxlsdz/blogImage/raw/master/img/20200305084115.png" alt=""></p></li><li><p>不确定性规则知识的产生式表示</p><p><img src="C:/Users/17861/AppData/Roaming/Typora/typora-user-images/image-20200305084145976.png" alt="image-20200305084145976"></p></li><li><p>确定性事实性知识的产生式表示</p><ul><li><p>三元组表示：（对象，属性，值）</p><p>​            或者：（关系，对象1，对象2）</p></li><li><p>例：老李年龄是40岁：（Li，Age，40）</p><p>老李和老王是朋友：（Frind，Li，Wang）</p></li></ul></li><li><p>不确定性事实性知识的产生式表示</p><ul><li><p>四元组表示：（对象，属性，值，置信度）</p><p>​          或者：（关系，对象1，对象2，置信度）</p></li><li><p>例：老李年龄很可能是40岁：（Li，Age，40，0.8）<br>老李和老王不大可能是朋友：（Frind，Li.Wang，0.1）</p></li></ul></li></ol><p>产生式与谓词逻辑中的蕴含式的区别：</p><ol><li><p><strong>除逻辑蕴含外，产生式还包括各种操作、规则、变换、算子、函数等</strong>。例如，“如果炉温超过上限，则立即关闭风门”是一个产生式，但不是蕴涵式。</p></li><li><p><strong>蕴含式只能表示精确知识，而产生式不仅可以表示精确的知识，还可以表示不精确知识。</strong>蕴含式的匹配总要求是精确的。产生式匹配可以是精确的，也可以是不精确的，只要按某种算法求出的相似度落在预先指定的范围内就认为是可匹配的。</p></li></ol><p>产生式它的形式描述及语义——用巴科斯范式BNF（Backus Normal Form）</p><p><img src="https://gitee.com/pxlsdz/blogImage/raw/master/img/20200305155336.png" alt=""></p><h2 id="产生式系统"><a href="#产生式系统" class="headerlink" title="产生式系统"></a>产生式系统</h2><p><img src="https://gitee.com/pxlsdz/blogImage/raw/master/img/20200305220032.png" alt=""></p><ol><li><p>规则库<br>规则库：明于描述相应领域内知识的产生式集合。</p></li><li><p>综合数据库<br>综合数据库（事实库、上下文、黑板等）：一个用于存放问题求解过程中各种当前信息的数据结构。</p></li><li><p>控制系统<br>控制系统（推理机构）：由一组程序组成，负责整个产生式系统的运行，实现对问题的求解。</p><p>控制系统要做以下几项工作：<br>1）从规则库中选择与综合数据库中的已知事实进行匹配。<br>2）匹配成功的规则可能不止一条，进行冲突消解。<br>3）执行某一规则时，如果其右部是一个或多个结论，则把这些结论加入到综合数据库中：如果其右部是一个或多个操作，则执行这些操作。<br>4）对于不确定性知识，在执行每一条规则时还要按一定的算法计算结论的不确定性。<br>5）检查综合数据库中是否包含了最终结论，决定是否停止系统的运行。</p></li></ol><h2 id="产生式系统——动物识别系统"><a href="#产生式系统——动物识别系统" class="headerlink" title="产生式系统——动物识别系统"></a>产生式系统——动物识别系统</h2><p>例，动物识别系统：识别虎、金钱豹、斑马、长颈鹿、鸵鸟、企鹅、信天翁等七种动物的产生式系统。</p><h2 id="规则库："><a href="#规则库：" class="headerlink" title="规则库："></a>规则库：</h2><p><img src="https://gitee.com/pxlsdz/blogImage/raw/master/img/20200305220845.png" alt=""></p><p><img src="https://gitee.com/pxlsdz/blogImage/raw/master/img/20200305220916.png" alt=""></p><p>设已知初始事实存放在综合数据库中：<br>该动物身上有：暗斑点，长脖子，长腿，奶，蹄</p><p>推理机构的工作过程：<br>（1）从规则库中取出r1，检查其前提是否可与综合数据库中的已知事实匹配。匹配失败则r1不能被用于推理。然后取r2进行同样的工作。匹配成功则r2被执行。</p><p>综合数据库：<br>该动物身上有：暗斑点，长脖子，长腿，奶，蹄，哺乳动物</p><p>推理机构的工作过程：<br>（2）分别用r3，r4，r5，r6综合数据库中的已知事实进行匹配，均不成功。r7匹配成功，执行了。<br>综合数据库：<br>该动物身上有：暗斑点，长脖子，长腿，奶，蹄，哺乳动物，有蹄类动物<br>（3）r1匹配成功，并推出“该动物是长颈鹿”。</p><p><img src="https://gitee.com/pxlsdz/blogImage/raw/master/img/20200305222422.png" alt=""></p><h2 id="产生式表示法的特点"><a href="#产生式表示法的特点" class="headerlink" title="产生式表示法的特点"></a>产生式表示法的特点</h2><ol><li>产生式表示法的优点</li></ol><ul><li>（1）自然性</li><li>（2）模块性</li><li>（3）有效性</li><li>（4）清晰性</li></ul><ol start="2"><li>产生式表示法的缺点</li></ol><ul><li>（1）效率不高</li><li>（2）不能表达结构性知识</li></ul><ol start="3"><li>适合产生式表示的知识</li></ol><ul><li>1）领域知识间关系不密切，不存在结构关系。</li><li>2）经验性及不确定性的知识，且相关领域中对这些知识没有严格、统一的理论。</li><li>3）领域问题的求解过程可被表示为一系列相对独立的操作，且每个操作可被表示为一条或多条产生式规则。</li></ul><h1 id="框架表示法"><a href="#框架表示法" class="headerlink" title="框架表示法"></a>框架表示法</h1><h1 id="语义网络表示法"><a href="#语义网络表示法" class="headerlink" title="语义网络表示法"></a>语义网络表示法</h1>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux操作系统——vim编辑器</title>
      <link href="/2020/03/03/linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94vim%E7%BC%96%E8%BE%91%E5%99%A8/"/>
      <url>/2020/03/03/linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94vim%E7%BC%96%E8%BE%91%E5%99%A8/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>linux操作系统——SHELL基本命令</title>
      <link href="/2020/03/03/linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94SHELL%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
      <url>/2020/03/03/linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94SHELL%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="shell定义"><a href="#shell定义" class="headerlink" title="shell定义"></a>shell定义</h1><a id="more"></a><p><strong>Shell</strong>：字面意思“壳”；引申一下就是人机界面。是Linux里用户使用Linux的桥梁（命令接口）。</p><p><img src="https://gitee.com/pxlsdz/blogImage/raw/master/img/20200303101515.png" alt=""></p><p><strong>Bourne（[buən]） Again Shell (bash)</strong>：GNU计划的一部分，用来替代Bourne shell。用于基于GNU的系统.<br><strong>大多数的Linux(Red Hat,Centos, Slackware, Caldera)都以bash作为缺省的shell</strong></p><p>查看shell</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cat &#x2F;etc&#x2F;shells</span><br><span class="line">Echo $SHELL</span><br></pre></td></tr></table></figure><h1 id="shell实用功能"><a href="#shell实用功能" class="headerlink" title="shell实用功能"></a>shell实用功能</h1><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><p>Tab键：自动补齐</p><p>反斜杠“\”：强制换行</p><p>快捷键 Ctrl+U：清空至行首</p><p>快捷键 Ctrl+K：清空至行尾</p><p>快捷键 Ctrl+L：清屏</p><p>快捷键 Ctrl+C：取消本次命令编辑</p><p>Home：跳到行首</p><p>End：跳到行尾</p><h2 id="获得命令帮助"><a href="#获得命令帮助" class="headerlink" title="获得命令帮助"></a>获得命令帮助</h2><ul><li><p>内部命令help</p><p>查看Bash内部命令的帮助信息</p></li><li><p>命令的“–help” 选项</p><p>适用于大多数外部命令</p></li><li><p>使用man命令阅读手册页</p><p><strong>man –k [关键字]</strong></p><p>使用“上”、“下”方向键滚动文本</p><p>使用Page Up和Page Down键翻页</p><p>按Q或q键退出阅读环境、<strong>按“/”键后查找内容</strong></p></li></ul><h2 id="历史命令的使用"><a href="#历史命令的使用" class="headerlink" title="历史命令的使用"></a>历史命令的使用</h2><p>bash支持历史命令功能，通过上下光标键来选择，<strong>history</strong>命令可以查看执行的命令</p><p>Shell还可以执行指定序号的历史命令,使用方式<strong>!num</strong></p><p>当历史命令比较多时，可以结合<strong>grep命令和管道</strong>进行查找使用</p><h2 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h2><table><thead><tr><th><strong>通配符</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>？</td><td>匹配任意一个字符</td></tr><tr><td>*</td><td>匹配任意多个字符</td></tr><tr><td>[]</td><td>相当于或的意思</td></tr><tr><td>-</td><td>代表一个范围，比如a-z</td></tr></tbody></table><h1 id="Linux目录类命令"><a href="#Linux目录类命令" class="headerlink" title="Linux目录类命令"></a><strong>Linux目录类命令</strong></h1><h2 id="常见目录"><a href="#常见目录" class="headerlink" title="常见目录"></a>常见目录</h2><p><img src="https://gitee.com/pxlsdz/blogImage/raw/master/img/20200303135822.png" alt=""></p><h2 id="pwd-绝对路径"><a href="#pwd-绝对路径" class="headerlink" title="pwd 绝对路径"></a>pwd 绝对路径</h2><p> 显示当前工作目录的绝对路径</p><p>命令格式：pwd</p><p>【 例】显示用户当前工作目录路径</p><p>[user@localhost ~]$ pwd</p><p>/home/user</p><p>注意：</p><ul><li>绝对路径：指从根目录（/）开始到当前目录（文件）的路径；</li><li>相对路径：指从当前目录到其下子目录（文件）的路径。</li></ul><h2 id="mkdir-创建目录"><a href="#mkdir-创建目录" class="headerlink" title="mkdir 创建目录"></a>mkdir 创建目录</h2><p>命令格式：  mkdir [选项] [目录]</p><table><thead><tr><th><strong>选项</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>-p</strong></td><td>若路径中的目录不存在，先创建目录</td></tr><tr><td><strong>-v</strong></td><td>每次创建目录都显示信息</td></tr></tbody></table><p>【例】 创建空目录test。</p><p>[user@localhost ~]$ mkdir test //当前目录下创建空目录test</p><p>【例】 递归的创建目录。 </p><p>[user@localhost ~]$ mkdir -p test1/test2</p><h2 id="cd-更改工作目录路径"><a href="#cd-更改工作目录路径" class="headerlink" title="cd 更改工作目录路径"></a>cd 更改工作目录路径</h2><p>命令格式： cd  [目录]</p><p>几个特殊符号：</p><ol><li>.   代表当前所在目录</li><li>..  代表当前目录位置的上一层目录</li><li>~   代表家目录（home directory),即login时所在的目录</li><li>~ user 代表到 user 用户的根目录</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root @test root]# cd ..　　　　　　　&lt;&#x3D;&#x3D;回到上一层目录</span><br><span class="line">[root @test root]# cd ..&#x2F;home　　　　 &lt;&#x3D;&#x3D;相对路径的写法</span><br><span class="line">[root @test root]# cd &#x2F;var&#x2F;www&#x2F;html　 &lt;&#x3D;&#x3D;绝对路径的写法</span><br><span class="line">[root @test etc]# cd　　　　　　&lt;&#x3D;&#x3D;回到使用者的家目录</span><br><span class="line">[root @test etc]# cd ~ 　　　　　&lt;&#x3D;&#x3D;回到使用者的家目录</span><br></pre></td></tr></table></figure><h2 id="ls-列出目录和文件信息"><a href="#ls-列出目录和文件信息" class="headerlink" title="ls 列出目录和文件信息"></a>ls 列出目录和文件信息</h2><p>命令格式： ls [选项] [目录] [文件]</p><table><thead><tr><th><strong>选项</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>-l</strong></td><td><strong>以详细信息的形式展示出当前目录的文件</strong></td></tr><tr><td><strong>-a</strong></td><td><strong>显示当前目录中的全部文件（包括隐藏文件）</strong></td></tr><tr><td><strong>-d</strong></td><td><strong>查看目录属性</strong></td></tr><tr><td><strong>-t</strong></td><td><strong>按照创建时间顺序列出文件</strong></td></tr><tr><td><strong>-F</strong></td><td><strong>显示文件类型</strong></td></tr></tbody></table><p><img src="https://gitee.com/pxlsdz/blogImage/raw/master/img/20200303112115.png" alt=""></p><p><img src="https://gitee.com/pxlsdz/blogImage/raw/master/img/%E5%9B%BE%E7%89%871.png" alt=""></p><p><strong>Linux中一切皆文件</strong><br>常见文件：<br>1）普通文件 文件属性的第一个符号是“-”<br>2）目录文件  文件属性的第一个符号是“d”<br>3）设备文件  /dev中有大量设备文件，包括块设备文件（b）和 字符设备文件（c）<br>4）管道文件 从一头流入从另一头留出的文件，文件属性的第一个符号是“p”<br>5）链接文件 文件属性的第一个符号是“l”</p><h3 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h3><p>举例1：$[-][r w x][r - x][r - -]$<br>举例2：$[d][r w x][r - -][r - -]$<br>问题：非root的其他人是否可以进入该目录？<br>注意：在Linux中，文件是否能执行，通过是否具有x属性来决定执行，与文件名没有关系；x与目录的关系相当重要，如果在该目录下不能执行命令，也就无法进入</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><table><thead><tr><th><strong>要完成的操作</strong></th><th><strong>命令</strong></th></tr></thead><tbody><tr><td><strong>返回当前用户的主目录</strong></td><td>cd</td></tr><tr><td><strong>确定当前位置的绝对路径名</strong></td><td>pwd</td></tr><tr><td><strong>返回到最前面的工作目录</strong></td><td>cd ~</td></tr><tr><td><strong>从当前位置上移两个级别</strong></td><td>cd ../..</td></tr><tr><td><strong>列出当前的位置（长格式）及隐藏文件</strong></td><td>ls -la</td></tr><tr><td><strong>从任何当前位置移动到二进制文件（*/bin）位置</strong></td><td>cd /bin</td></tr><tr><td><strong>上移到当前位置的父目录</strong></td><td>cd ..</td></tr><tr><td><strong>从根目录移到二进制文件（/bin）位置</strong></td><td>cd bin</td></tr><tr><td><strong>当前用户的主目录不是当前位置时，以最简单的语法列出该目录（长格式）</strong></td><td>ls -l ~</td></tr></tbody></table><h2 id="rmdir-删除空目录"><a href="#rmdir-删除空目录" class="headerlink" title="rmdir  删除空目录"></a>rmdir  删除空目录</h2><p>命令格式： rmdir [选项] [目录]</p><table><thead><tr><th><strong>选项</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>-p</strong></td><td>删除递归目录，当子目录删除后其父目录为空时，也一同被删除</td></tr><tr><td><strong>-v</strong></td><td>输出处理的目录详情</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">【 例 】 删除空目录 test。</span><br><span class="line">[user@localhost ~]$ rmdir test</span><br><span class="line">【 例 】 删除空目录 ~&#x2F;test1&#x2F;test2。</span><br><span class="line">[user@localhost ~]$ rmdir -p test1&#x2F;test2</span><br></pre></td></tr></table></figure><h1 id="文件操作命令"><a href="#文件操作命令" class="headerlink" title="文件操作命令"></a>文件操作命令</h1><h2 id="touch-创建空文件、更改文件时间"><a href="#touch-创建空文件、更改文件时间" class="headerlink" title="touch 创建空文件、更改文件时间"></a>touch 创建空文件、更改文件时间</h2><p>命令格式： touch [选项] 文件</p><table><thead><tr><th><strong>选项</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>-a</strong></td><td>只更改访问时间（atime）</td></tr><tr><td><strong>-m</strong></td><td>更改文件的修改时间记录（mtime）</td></tr><tr><td><strong>-c</strong></td><td>假如目标文件不存在，则不会建立新的文件</td></tr><tr><td>*<em>-d&lt;字符串&gt; *</em></td><td>使用指定字符串表示时间而非当前时间</td></tr><tr><td><strong>-t&lt;日期时间&gt;</strong></td><td>使用MMDDhhmm格式的时间而非当前时间</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">【例】 创建空文件file1、file2、 file3和file4。</span><br><span class="line">[user@localhost ~]$ touch file1</span><br><span class="line">[user@localhost ~]$ touch file&#123;2,3,4&#125;</span><br><span class="line">【例】 将文件file1的时间记录改为3月12日19时30分。</span><br><span class="line">[user@localhost ~]$ touch -c -t 03121930 file1</span><br><span class="line">[user@localhost ~]$ ls -l file1</span><br><span class="line">-rw-rw-r--. 1 user user 0 3月  12 19:30 file1</span><br></pre></td></tr></table></figure><p>时间格式MMDDHHmm指月（MM）日（DD）时（HH）分（mm），如果还需要加上年份，可以使用201903121930，表示2019年3月12日19时30分。</p><h2 id="cp-复制文件和目录"><a href="#cp-复制文件和目录" class="headerlink" title="cp 复制文件和目录"></a>cp 复制文件和目录</h2><p>命令格式： cp [选项] [源文件|目录] [目标文件|目录]</p><table><thead><tr><th><strong>选项</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>-f</strong></td><td>强制复制文件和目录，无论目的文件或目录是否已经存在</td></tr><tr><td><strong>-r</strong></td><td>递归复制目录下的子目录和文件</td></tr><tr><td><strong>-i</strong></td><td>若目标文件存在，则提示用户如何操作</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">【例】将&#x2F;etc&#x2F;passwd文件复制到当前家目录的test文件夹中。</span><br><span class="line">[user@localhost ~]$ cp   &#x2F;etc&#x2F;passwd    ~&#x2F;test</span><br><span class="line">这时在家目录的test中即有一个文件passwd。</span><br><span class="line">【例】生成一个passwd_new文件，要求内容与passwd文件内容相同。 </span><br><span class="line">[user@localhost ~]$ cd test</span><br><span class="line">[user@localhost test]$ cp passwd passwd_new</span><br><span class="line">【例】 将 ~&#x2F;test目录下的所有内容复制到当前家目录，命名为testnew。</span><br><span class="line">[user@localhost ~]$ cp  -r  test   test_new</span><br></pre></td></tr></table></figure><h2 id="mv-文件和目录改名、移动文件和目录路径"><a href="#mv-文件和目录改名、移动文件和目录路径" class="headerlink" title="mv 文件和目录改名、移动文件和目录路径"></a>mv 文件和目录改名、移动文件和目录路径</h2><p>命令格式：mv [选项] [源文件|目录] [目标文件|目录]</p><table><thead><tr><th><strong>选项</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>-f</strong></td><td><strong>移动时自动替换已经存在的目标文件，不提示</strong></td></tr><tr><td><strong>-i</strong></td><td><strong>若目标文件存在，则提示用户如何操作</strong></td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">【例】 将~&#x2F;test目录下的所有后缀名为”*.png”的文件移动到~&#x2F;pic目录下。</span><br><span class="line">[user@localhost ~]$ mv   ~&#x2F;test&#x2F;*.png   ~&#x2F;pic</span><br><span class="line">【例】把~&#x2F;pic&#x2F;1.png文件改名为 ~&#x2F;pic&#x2F;life.png。</span><br><span class="line">[user@localhost ~]$ cd  pic</span><br><span class="line">[user@localhost pic]$ mv 1.png life.png</span><br><span class="line">【例】把~&#x2F;pic目录名称更改为~&#x2F;mypic。</span><br><span class="line">[user@localhost ~]$ mv  ~&#x2F;pic   ~&#x2F;mypic</span><br></pre></td></tr></table></figure><h2 id="find-用于查找文件或目录"><a href="#find-用于查找文件或目录" class="headerlink" title="find 用于查找文件或目录"></a>find 用于查找文件或目录</h2><p>命令格式：find [查找范围] [选项] [查找条件]</p><p>如果用户没有指定查找范围，则find命令从当前目录开始搜索查找</p><table><thead><tr><th><strong>选项</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>-name&lt;文件名*&gt;</strong></td><td><strong>匹配文件的名称</strong></td></tr><tr><td><strong>-user &lt;用户名&gt;</strong></td><td><strong>匹配文件的所有者</strong></td></tr><tr><td><strong>-perm &lt;权限&gt;</strong></td><td><strong>匹配文件的权限</strong></td></tr><tr><td><strong>-type &lt;文件类型&gt;</strong></td><td><strong>匹配文件类型查找</strong></td></tr><tr><td><strong>-size n[ckMG]</strong></td><td><strong>匹配文件的大小（+50k查找超过50k的文件,而-50k则代表查找小于50k的文件）</strong></td></tr><tr><td><strong>–exec {} ;</strong></td><td><strong>后面可接对搜索到结果进一步处理的命令</strong></td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">【 例】搜索在&#x2F;etc&#x2F;中所有以host开头的文件。</span><br><span class="line">其中的”host*”表示所有以host开头的文件。</span><br><span class="line">[root@localhost ~]# find &#x2F;etc -name &quot;host*&quot; -type f</span><br><span class="line">【 例】搜索当前目录中文件属主具有读写权限，并且文件所属组及其他用户具有读权限的文件。</span><br><span class="line">[root@localhost ~]# find . -perm 644  -type f -exec ls -l &#123;&#125; \;</span><br><span class="line">【 例】 在&#x2F;etc目录下查找大于1MB小于10MB的文件。</span><br><span class="line">[root@localhost ~]# find &#x2F;etc -size +1M -a -size  -10M</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">【 例2-21 】查找&#x2F;var&#x2F;log 目录中更改时间在7天以前的普通文件，并删除。</span><br><span class="line"> [root@localhost ~]# find &#x2F;var&#x2F;log -type f -mtime +7 -exec rm &#123;&#125; \;</span><br><span class="line">【 例2-22 】查找找出所有用户susa拥有的文件，并且把它们拷贝到&#x2F;root&#x2F;finder目录中。</span><br><span class="line">两种解决办法：</span><br><span class="line">（1）[root@localhost ~]# mkdir  &#x2F;root&#x2F;finder</span><br><span class="line">[root@localhost ~]# find &#x2F; -user susa -type f，然后挨个复制到指定目录中。</span><br><span class="line">（2）[root@localhost ~]# find  &#x2F;  -user  susa   -type f  -exec  cp  &#39;&#123;&#125;&#39;  &#x2F;root&#x2F;finder  \;</span><br></pre></td></tr></table></figure><h1 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h1>]]></content>
      
      
      <categories>
          
          <category> linux操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件过程——可行性研究及需求分析</title>
      <link href="/2020/03/02/%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B%E2%80%94%E2%80%94%E5%8F%AF%E8%A1%8C%E6%80%A7%E7%A0%94%E7%A9%B6%E5%8F%8A%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90/"/>
      <url>/2020/03/02/%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B%E2%80%94%E2%80%94%E5%8F%AF%E8%A1%8C%E6%80%A7%E7%A0%94%E7%A9%B6%E5%8F%8A%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="可行性研究"><a href="#可行性研究" class="headerlink" title="可行性研究"></a>可行性研究</h1><a id="more"></a><h2 id="项目立项"><a href="#项目立项" class="headerlink" title="项目立项"></a>项目立项</h2><ol><li>项目发起</li><li>项目论证（可行性研究）</li><li>项目立项</li><li>项目审核</li></ol><p>可行性研究需要从多个方面进行评估，主要包括：</p><ul><li><p>战略可行性</p></li><li><p>社会可行性</p></li><li><p>操作可行性</p></li><li><p>市场可行性</p></li><li><p>计划可行性</p></li><li><p>经济可行性</p></li><li><p>技术可行性</p></li><li><p>风险可行性</p></li></ul><h2 id="可行性研究步骤"><a href="#可行性研究步骤" class="headerlink" title="可行性研究步骤"></a>可行性研究步骤</h2><ol><li><p>明确系统目标</p></li><li><p>分析研究现行系统</p></li><li><p>设计新系统的高层逻辑模型</p></li><li><p>获得并比较可行的方案</p></li><li><p>撰写可行性研究报告</p><h1 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h1></li></ol><h2 id="需求分析的任务"><a href="#需求分析的任务" class="headerlink" title="需求分析的任务"></a>需求分析的任务</h2><ol><li><p>确定系统的运行环境要求</p></li><li><p>确定系统的功能性需求和非功能性需求</p></li><li><p>进行有效的需求分析</p></li></ol><ol start="4"><li><p>在需求分析的过程中应该遵守一些原则</p><ul><li>首先，需求分析是一个过程，它应该贯穿于系统的整个生命周期中，而不是仅仅属于软件生命周期早期的一项工作。</li><li>其次，需求分析应该是一个迭代的过程。由于市场环境的易变性以及用户本身对于新系统要求的模糊性，需求往往很难一步到位。通常情况下，需求是随着项目的深入而不断变化的。所以需求分析的过程还应该是一个迭代的过程。</li><li>此外，为了方便评审和后续的设计，需求的表述应该具体、清晰，并且是可测量的、可实现的。最好能够对需求进行适当的量化。</li></ul></li><li><p>需求分析的两个任务。<br>首先，是需求分析的<strong>建模阶段</strong>，即在充分了解需求的基础上，要建立起系统的分析<strong>模型。</strong><br>其次，是需求分析的<strong>描述阶段</strong>，就是把需求<strong>文档化</strong>，用<strong>软件需求规格说明书</strong>的方式把需求表达出来。</p></li></ol><p>软件需求规格说明书<br>软件需求规格说明书是需求分析阶段的输出，它全面、清晰地描述了用户需求，因此是开发人员进行后续软件设计的重要依据。软件需求规格说明书应该具有清晰性、无二义性、一致性和准确性等特点。同时，它还需通过严格的需求验证、反复修改的过程才能最终确定。</p><h2 id="需求分析的步骤"><a href="#需求分析的步骤" class="headerlink" title="需求分析的步骤"></a>需求分析的步骤</h2><h3 id="需求获取"><a href="#需求获取" class="headerlink" title="需求获取"></a>需求获取</h3><p>获取需求的方法多种：</p><ul><li>访谈</li><li>问卷调查</li><li>实她操作</li><li>原型系统</li></ul><h3 id="分析建模"><a href="#分析建模" class="headerlink" title="分析建模"></a>分析建模</h3><p>对待开发系统建立各种角度的模型有助于人们更好地理解问题。</p><h3 id="需求描述"><a href="#需求描述" class="headerlink" title="需求描述"></a>需求描述</h3><p>需求描述就是指编制需求分析阶段的文档。<br>一般情况下，对于复杂的软件系统，需求阶段会产生3个文档：系统定义文档（用户需求报告）、系统需求文档（系统需求规格说明书）、软件需求文档（软件需求规格说明书）。</p><p>不同规格需要不同的文档</p><p><img src="https://gitee.com/pxlsdz/blogImage/raw/master/img/20200304144352.png" alt=""></p><h3 id="需求验证"><a href="#需求验证" class="headerlink" title="需求验证"></a>需求验证</h3><p>确保需求的</p><ul><li><p>一致性</p></li><li><p>完整性</p></li><li><p>现实性</p></li><li><p>有效性</p></li></ul><h2 id="需求管理"><a href="#需求管理" class="headerlink" title="需求管理"></a>需求管理</h2><p>​      为了更好的进行需求分析并记录需求结果，需要进行需求管理。需求管理是一种用于查找、记录、组织和<strong>跟踪系统需求变更</strong>的系统化方法。<br>可用于：</p><ul><li>获取、组织和记录系统需求</li><li>使客户和项目团队在系统变更需求上达成并保持一致</li></ul><h2 id="需求分析的常用方法"><a href="#需求分析的常用方法" class="headerlink" title="需求分析的常用方法"></a>需求分析的常用方法</h2><ol><li><p>功能分解方法</p><p>功能、子功能和功能按口成为功能分解方法的3个要素</p></li><li><p>结构化分析方法</p><p>结构化分析方法是一种从问题空间到某种表示的映射方法，其逻辑模型由<strong>数据流图和数据词典</strong>构成并表示。它是一种面向数据流的需求分析方法。它主要适用于数据处理领域问题。第4章将详细介绍这种方法。</p></li><li><p>信息建模方法</p><p>E-R图</p></li><li><p>面向对象的分析方法</p><ul><li><p>描述系统静态结构的对象模型</p></li><li><p>描述系统控制结构的动态模型</p></li><li><p>描述系统计算结构的功能模型<br>对象模型是最基本、最核心、最重要的。</p></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 软件工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件工程——软件过程</title>
      <link href="/2020/03/02/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E2%80%94%E2%80%94%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B/"/>
      <url>/2020/03/02/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E2%80%94%E2%80%94%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="软件过程模型"><a href="#软件过程模型" class="headerlink" title="软件过程模型"></a>软件过程模型</h1><a id="more"></a><h2 id="敏捷过程与极限编程"><a href="#敏捷过程与极限编程" class="headerlink" title="敏捷过程与极限编程"></a>敏捷过程与极限编程</h2><ol><li><p>个体交互 </p><p>个体与交互高于过程和工具</p></li><li><p>可运行软件 </p><p>可运行软件高于详尽的文档</p></li><li><p>客户协作 </p><p>与客户协作高于合 同（契约）谈判</p></li><li><p>相应变更 </p><p>对变更及时响应高于遵循计划</p></li></ol><h2 id="敏捷方法"><a href="#敏捷方法" class="headerlink" title="敏捷方法"></a>敏捷方法</h2><p>   敏捷方法是一种轻量级的软件工程方法，相对于传统的软件工程方法，<strong>它更强调软件开发过程中各种变化的必然性</strong>，通过团队成员之间充分的交流与沟通以及合理的机制来有效地响应变化。</p><h2 id="极限编程（eXtreme-Programming，XP）"><a href="#极限编程（eXtreme-Programming，XP）" class="headerlink" title="极限编程（eXtreme Programming，XP）"></a><strong>极限编程（eXtreme Programming，XP）</strong></h2><p> <strong>把好的开发实践运用到极致 。</strong></p><ul><li><p><strong>极限编程是一种实践性较强的规范化的软件开发方法，它强调用户需求和团队合作工作。</strong> </p></li><li><p>利用极限编程方法进行软件开发实践的工程师，即使在开发周期的末期，也 可以很快地响应用户需求。 </p></li><li><p>在团队工作中，项目经理、用户以及开发人员都有责任为提高软件产品的质 量而努力。 </p></li><li><p>XP特别适用于软件需求模糊且容易改变、开发团队人数少于10人、开发地点 集中（比如一个办公室）的场合。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机专业英语--OS</title>
      <link href="/2020/03/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%8B%B1%E8%AF%AD--OS/"/>
      <url>/2020/03/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%8B%B1%E8%AF%AD--OS/</url>
      
        <content type="html"><![CDATA[<h1 id="关键单词"><a href="#关键单词" class="headerlink" title="关键单词"></a>关键单词</h1><a id="more"></a><ol><li><p><strong>job management</strong>               <strong>作业管理</strong></p></li><li><p><strong>resource management</strong>           <strong>资源管理</strong></p></li><li><p><strong>job queue</strong>                     <strong>作业队列</strong></p></li><li><p><strong>input/output control system(IOCS)</strong> <strong>输入输出控制系统</strong></p></li><li><p><strong>batch system</strong>                  <strong>批处理系统</strong></p></li><li><p><strong>time-shared operating system</strong>    <strong>分时操作系统</strong></p></li><li><p><strong>offline operation</strong>               <strong>脱机操作</strong></p></li><li><p><strong>real-time system</strong>               <strong>实时系统</strong> </p></li><li><p><strong>buffering</strong>           <strong>缓冲技术</strong></p></li><li><p><strong>spooling system</strong>     <strong>假脱机系统</strong></p></li><li><p><strong>multiprogramming</strong>   <strong>多道程序设计</strong></p></li><li><p>priviledged <em>instruction</em>  特权指令</p></li><li><p>assess 评价</p></li><li><p>resident 驻留</p></li><li><p>sequencing 排序</p></li><li><p>overlap（ping） 重叠</p></li><li><p>approve  同意</p><p>deny       拒绝</p></li></ol><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><ol><li><p>What are two main purposes of developing operating system ? </p></li><li><p>Are operating systems normally related to their manufacturers and hardware?</p></li><li><p>List five functions of operating systems.</p></li><li><p>What does buffering mean ?</p></li><li><p>How multi-programs to be operated ?</p></li><li><p>List three basic types of operating systems.</p></li><li><p>What resources should be included in Resource management ?</p></li></ol><p>ans：</p><ol><li><p>The primary goal is to make the computer system convenient to use. The secondary goal is to use the computer hardware in an efficient manner.</p></li><li><p>Yes.</p></li><li><p>(1) Job management;          (2) Resource management; </p><p>(3) Control of I/O operations;   (4) Error recovery;</p><p>(5) Memory management. </p></li><li><p>Buffering means to overlap the input, output, and computation of a single job to improve system performance. It can increase the level of resources utilization and throughput capacity.</p></li><li><p>With multiprogramming, several jobs are kept in memory at one time; the CPU is switched back and forth between them in order to increase CPU utilization and to decrease the total real time needed to execute a job. </p></li><li><p>Batch system, time-shared operating system ,</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 英语 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机专业英语--PROCESSOR</title>
      <link href="/2020/03/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%8B%B1%E8%AF%AD--PROCESSOR%20/"/>
      <url>/2020/03/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%8B%B1%E8%AF%AD--PROCESSOR%20/</url>
      
        <content type="html"><![CDATA[<h1 id="Main-point"><a href="#Main-point" class="headerlink" title="Main point:"></a>Main point:</h1><ul><li>Instruction and Instruction set</li><li>Three units of CPU</li><li>Operation of CPU</li></ul><a id="more"></a><ol><li><p>处理器的概念</p><p>A processor is functional unit that interprets and carries out the instructions.</p></li><li><p>指令的概念</p><p>Instruction is a code in a program which defines and carries out an operation.</p></li></ol><ol start="3"><li><p>interprets  解释</p></li><li><p>encrypt 加密</p><p>decrypt 解密</p></li><li><p>instruction set  指令系统，指令集</p></li><li><p>processor        处理器</p></li><li><p>operation         操作、操作码</p></li><li><p>operand            操作数</p></li><li><p>register             寄存器</p></li><li><p>control unit        控制器，控制部件</p></li><li><p>decode            译码，解码</p><p>encode            编码</p></li><li><p>arithmetic and logic unit (ALU)  算术/逻辑部件</p></li><li><p>word size (word length)        字长</p></li><li><p>machine language             机器语言 </p></li><li><p>be referred to       称为</p></li><li><p>retrieve  检索；取指令</p></li><li><p>awesome  极好的；惊人的</p><p>awful       糟糕的   </p></li><li><p>precisely  恰好地</p><p>precision  精准</p></li><li><p>depict/show/illustrate/demonstrate/indicate/represent/specify/interprete</p><p>图示说明；表示</p></li><li><p>external  外部的</p><p>internal   内部的</p></li><li><p>supervis 监督</p></li><li><p>fetch     获取</p></li><li><p>keep track of 追踪；跟踪</p></li><li><p>tightly  紧密的</p><p>loosely 松散的</p></li></ol><h1 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h1><ol><li><p>Which two parts make up an instruction? Please describe their functions. </p><p>An instruction is made up of operations and operands. The former specifies the function to be performed by an instruction and the later represents the data to be operated by the instruction.                                                                                                                                                                                </p></li><li><p>What functions should be performed with Control Unit? </p><p>The control unit fetches instructions from memory and determines their types or decodes them. It then breaks each instruction into a series of simple small steps or actions. By doing this, it controls the step-by-step operation of the entire computer system.</p></li><li><p>List four operations belonging to arithmetic operations. What is logic operation?          </p><p>Arithmetic operations include adding, subtracting, multiplying, and dividing. Logic operations make a comparison and take action based on the results. </p></li><li><p>What items should be stored into registers?</p><p>A register is a storage location inside the processor. Registers in the control unit are used to keep track of the overall status of the program that is running. Control unit registers store information such as the current instruction, the location of the next instruction to be executed, and the operands of the instruction. In the ALU, registers store data items that are added, subtracted, multiplied, divided, and compared. Other registers store the results of arithmetic and logic operations.</p></li></ol><hr><ul><li><p>a.The part of an instruction that specifies the function that is to be performed.  </p><p>  <strong>operation</strong></p></li><li><p>b. The binary language in which a computer’s    instruction set is written.</p><p>  <strong>machine language</strong></p></li><li><p>c. A timer in a processor that releases precisely timed signals that provide a pulse for the processor’s work.</p><p>   <strong>clock</strong></p></li><li><p>d. A functional unit that interprets and carries out  instructions.</p><p>  <strong>processor</strong></p></li><li><p>e. A unique set of operations that comes with every processor.</p><p>  <strong>instruction set</strong></p></li><li><p>f. The part of an instruction that tells where data that are operated on are located </p><p>  <strong>Operand</strong></p></li><li><p>g. Million cycles per second.</p><p>  <strong>Megahertz</strong> </p></li><li><p>h. The function unit that is responsible for supervising  the operation of the entire computer system.</p><p>  <strong>Control unit</strong></p></li><li><p>i. A function unit that provides the computer with logical and computational capability. </p><p>  <strong>Arithmetic and logic unit</strong></p></li><li><p>j. The term used to describe the size of operand registers and buses.</p><p>  <strong>Word size</strong></p></li><li><p>k. A storage location inside the processor. </p><p>  <strong>register</strong></p></li></ul><hr><ul><li><p>(1) We usually call our computers :<strong>machines</strong></p></li><li><p>(2) An instruction set can sometimes be referred to as     :<strong>machine instructions</strong></p></li><li><p>(3) The binary language is called     :<strong>machine language</strong></p></li><li><p>(4) We don’t confuse the processor’s instruction set with  the instructions of *<em>High-level programming languages *</em>      </p></li><li><p>(5) An instruction consists of  :<strong>operations and operands</strong></p></li><li><p>(6) An operand that refers to data in the memory is called  an   *<em>address *</em></p></li><li><p>(7) A timer can give precisely timed   <strong>electical signals</strong>  </p></li><li><p>(8) A processor includes two functional units, they  are <strong>machine language</strong></p></li><li><p>(9) The ways by which the control unit works  are analogous to    *<em>a telephone switchboard with intelligence *</em> </p></li><li><p>(10) The control unit takes out the from memory *<em>instructions *</em></p></li></ul><p>​     </p>]]></content>
      
      
      <categories>
          
          <category> 英语 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>灰色预测</title>
      <link href="/2020/03/01/%E7%81%B0%E8%89%B2%E9%A2%84%E6%B5%8B/"/>
      <url>/2020/03/01/%E7%81%B0%E8%89%B2%E9%A2%84%E6%B5%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><a id="more"></a><p>​       灰色预测是对既含有已知信息又含有不确定信息的系统进行预 则，就是对在一定范围内变化的、与时间有关的灰色过程进行预测。 </p><p>​       灰色预测对原始数据进行生成处理来寻找系统变动的规律，并 生成有较强规律性的数据序列，然后建立相应的微分方程模型，从 而预测事物未来发展趋势的状况。</p><h1 id="GM-1-1-模型-Grey-Gray-Model"><a href="#GM-1-1-模型-Grey-Gray-Model" class="headerlink" title="GM(1,1)模型: Grey(Gray) Model"></a>GM(1,1)模型: Grey(Gray) Model</h1><p>​        GM(1,1)是使用原始的离散非负数据列，通过一次累加生成削弱随机性的 较有规律的新的离散数据列，然后通过建立微分方程模型，得到在离散点处的 解经过累减生成的原始数据的近似估计值，从而预测原始数据的后续发展。 （本文只探究GM(1,1)模型，第一个‘1’表示微分方程是一阶的， 后面的‘1’表示只有一个变量，且暂时不讨论证明过程）</p><p>$$<br>x^{(0)}=\left(X^{(0)}(1), X^{(0)}(2), \ldots, X^{(0)}(n)\right)<br>$$<br>做一次累加生成（1-AGO）序列：</p><p>$$<br>x^{(1)}=\left(X^{(1)}(1), X^{(1)}(2), \ldots, X^{(1)}(n)\right)<br>$$<br>其中，<br>$$<br>x^{(1)}(k)=\sum_{i=1}^{k} x^{(0)}(i), \quad k=1, \ldots, n<br>$$<br>令$Z^{(1)}$为数列$x^{(1)}$的紧邻均值生成数列，即<br>$$<br>Z^{(1)}(m)=\delta x^{(1)}(m)+(1-\delta) x^{(1)}(m-1), m=2,3, \cdots n \quad &amp;&amp; \quad\delta=0.5<br>$$<br>建立GM(1,1)的灰微分方程模型为：</p><p>（时间紧迫，贴图保存）</p><p><img src="https://gitee.com/pxlsdz/blogImage/raw/master/img/20200303221334.png" alt=""></p><p><img src="https://gitee.com/pxlsdz/blogImage/raw/master/img/20200303221554.png" alt=""></p><h1 id="准指数规律的检验"><a href="#准指数规律的检验" class="headerlink" title="准指数规律的检验"></a>准指数规律的检验</h1><p><img src="https://gitee.com/pxlsdz/blogImage/raw/master/img/20200303221842.png" alt=""></p><p><img src="https://gitee.com/pxlsdz/blogImage/raw/master/img/20200303222014.png" alt=""></p><h1 id="GM-1-1-模型的评价"><a href="#GM-1-1-模型的评价" class="headerlink" title="GM(1,1)模型的评价"></a>GM(1,1)模型的评价</h1><p><img src="https://gitee.com/pxlsdz/blogImage/raw/master/img/20200303222034.png" alt=""></p><p><img src="https://gitee.com/pxlsdz/blogImage/raw/master/img/20200303222050.png" alt=""></p><h1 id="GM-1-1-模型的拓展"><a href="#GM-1-1-模型的拓展" class="headerlink" title="GM(1,1)模型的拓展"></a>GM(1,1)模型的拓展</h1><p><img src="https://gitee.com/pxlsdz/blogImage/raw/master/img/20200303222110.png" alt=""></p><h1 id="什么时候用灰色预测？"><a href="#什么时候用灰色预测？" class="headerlink" title="什么时候用灰色预测？"></a>什么时候用灰色预测？</h1><p>（1）数据是以年份度量的非负数据（如果是月份或者季度 数据一定要用我们上一讲学过的时间序列模型）； </p><p>（2）数据能经过准指数规律的检验（除了前两期外，后面 至少90%的期数的光滑比要低于0.5）； </p><p>（3）数据的期数较短且和其他数据之间的关联性不强（小于等于10，也不能太短了，比如只有3期数据），要是数据期数较长，一般用传统的时间序列模型比较合适。</p><h1 id="预测的题目的一些小套路"><a href="#预测的题目的一些小套路" class="headerlink" title="预测的题目的一些小套路"></a>预测的题目的一些小套路</h1><p>（1）看到数据后先画时间序列图并简单的分析下趋势（例 如：的时间序列分解）； </p><p>（2）将数据分为训练组和试验组，尝试使用不同的模型对 训练组进行建模，并利用试验组的数据判断哪种模型的预测效 果最好（比如我们可以使用SSE这个指标来挑选模型，常见的 模型有指数平滑、ARIMA、灰色预测、神经网络等）。 （</p><p>3）选择上一步骤中得到的预测误差最小的那个模型，并 利用全部数据来重新建模，并对未来的数据进行预测。 </p><p>（4）画出预测后的数据和原来数据的时序图，看看预测的 未来趋势是否合理。</p><h1 id="GM-1-1-模型代码讲解"><a href="#GM-1-1-模型代码讲解" class="headerlink" title="GM(1,1)模型代码讲解"></a>GM(1,1)模型代码讲解</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li><p>画出原始数据的时间序列图，并判断原始数据中是否有负数或期数是否低于4期，如 果是的话则报错，否则执行下一步； </p></li><li><p>对一次累加后的数据进行准指数规律检验，返回两个指标： </p><ul><li>指标1：光滑比小于0.5的数据占比（一般要大于60%） </li><li>指标2：除去前两个时期外，光滑比小于0.5的数据占比（一般大于    90%） 并让用户决定数据是否满足准指数规律，满足则输入1，不满足则输入0 3.</li></ul></li><li><p>如果上一步用户输入0，则程序停止；如果输入1，则继续下面的步骤。 </p></li><li><p>让用户输入需要预测的后续期数，并判断原始数据的期数： </p><p>4.1 数据期数为4： 分别计算出传统的GM(1,1)模型、新信息GM(1,1)模型和新陈代谢GM(1,1)模型对于 未来期数的预测结果，为了保证结果的稳健性，对三个结果求平均值作为预测值。 </p><p>4.2 数据期数为5,6或7： 取最后两期为试验组，前面的n‐2期为训练组；用训练组的数据分别训练三种GM 模型，并将训练出来的模型分别用于预测试验组的两期数据；利用试验组两期的真实 数据和预测出来的两期数据，可分别计算出三个模型的SSE；选择SSE最小的模型作为我们建模的模型。</p><p> 4.3 数据期数大于7： 取最后三期为试验组，其他的过程和4.2类似。 </p></li><li><p>输出并绘制图形显示预测结果，并进行残差检验和级比偏差检验。</p></li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%%  输入原始数据并做出时间序列图</span></span><br><span class="line">clear;clc</span><br><span class="line">year =[<span class="number">1995</span>:<span class="number">1</span>:<span class="number">2004</span>]';  <span class="comment">% 横坐标表示年份，写成列向量的形式（加'就表示转置）</span></span><br><span class="line">x0 = [<span class="number">174</span>,<span class="number">179</span>,<span class="number">183</span>,<span class="number">189</span>,<span class="number">207</span>,<span class="number">234</span>,<span class="number">220.5</span>,<span class="number">256</span>,<span class="number">270</span>,<span class="number">285</span>]';  <span class="comment">%原始数据序列，写成列向量的形式（加'就表示转置）</span></span><br><span class="line"><span class="comment">% year = [2009:2015]; % 其实本程序写成了行向量也可以，因为我怕你们真的这么写了，所以在后面会有判断。</span></span><br><span class="line"><span class="comment">% x0 = [730, 679, 632, 599, 589, 532, 511];</span></span><br><span class="line"><span class="comment">% year = [2010:2017]';   % 该数据很特殊，可以通过准指数规律检验，但是预测效果却很差</span></span><br><span class="line"><span class="comment">% x0 = [1.321,0.387,0.651,0.985,1.235,0.987,0.854,1.021]';</span></span><br><span class="line"><span class="comment">% year = [2014:2017]';</span></span><br><span class="line"><span class="comment">% x0 = [2.874,3.278,3.337,3.390]';</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 画出原始数据的时间序列图</span></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">1</span>); <span class="comment">% 因为我们的图形不止一个，因此要设置编号</span></span><br><span class="line"><span class="built_in">plot</span>(year,x0,<span class="string">'o-'</span>); grid on;  <span class="comment">% 原式数据的时间序列图</span></span><br><span class="line">set(gca,<span class="string">'xtick'</span>,year(<span class="number">1</span>:<span class="number">1</span>:<span class="keyword">end</span>))  <span class="comment">% 设置x轴横坐标的间隔为1</span></span><br><span class="line">xlabel(<span class="string">'年份'</span>);  ylabel(<span class="string">'排污总量'</span>);  <span class="comment">% 给坐标轴加上标签</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 因为我们要使用GM(1,1)模型，其适用于数据期数较短的非负时间序列</span></span><br><span class="line">ERROR = <span class="number">0</span>;  <span class="comment">% 建立一个错误指标，一旦出错就指定为1</span></span><br><span class="line"><span class="comment">% 判断是否有负数元素</span></span><br><span class="line"><span class="keyword">if</span> sum(x0&lt;<span class="number">0</span>) &gt; <span class="number">0</span>  <span class="comment">% x0&lt;0返回一个逻辑数组(0-1组成)，如果有数据小于0，则所在位置为1，如果原始数据均为非负数，那么这个逻辑数组中全为0，求和后也是0~</span></span><br><span class="line">    <span class="built_in">disp</span>(<span class="string">'亲，灰色预测的时间序列中不能有负数哦'</span>)</span><br><span class="line">    ERROR = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 判断数据量是否太少</span></span><br><span class="line">n = <span class="built_in">length</span>(x0);  <span class="comment">% 计算原始数据的长度</span></span><br><span class="line"><span class="built_in">disp</span>(strcat(<span class="string">'原始数据的长度为'</span>,num2str(n)))    <span class="comment">% strcat()是连接字符串的函数，第一讲学了，可别忘了哦</span></span><br><span class="line"><span class="keyword">if</span> n&lt;=<span class="number">3</span></span><br><span class="line">    <span class="built_in">disp</span>(<span class="string">'亲，数据量太小，我无能为力哦'</span>)</span><br><span class="line">    ERROR = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 数据太多时提示可考虑使用其他方法（不报错）</span></span><br><span class="line"><span class="keyword">if</span> n&gt;<span class="number">10</span></span><br><span class="line">    <span class="built_in">disp</span>(<span class="string">'亲，这么多数据量，一定要考虑使用其他的方法哦，例如ARIMA，指数平滑等'</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 判断数据是否为列向量，如果输入的是行向量则转置为列向量</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">size</span>(x0,<span class="number">1</span>) == <span class="number">1</span></span><br><span class="line">    x0 = x0';</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">size</span>(year,<span class="number">1</span>) == <span class="number">1</span></span><br><span class="line">    year = year';</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 对一次累加后的数据进行准指数规律的检验(注意，这个检验有时候即使能通过，也不一定能保证预测结果非常好，例如上面的第三组数据)</span></span><br><span class="line"><span class="keyword">if</span> ERROR == <span class="number">0</span>   <span class="comment">% 如果上述错误均没有发生时，才能执行下面的操作步骤</span></span><br><span class="line">    <span class="built_in">disp</span>(<span class="string">'------------------------------------------------------------'</span>)</span><br><span class="line">    <span class="built_in">disp</span>(<span class="string">'准指数规律检验'</span>)</span><br><span class="line">    x1 = cumsum(x0);   <span class="comment">% 生成1-AGO序列，cumsum是累加函数哦~    注意：1.0e+03 *0.1740的意思是科学计数法,即10^3*0.1740 = 174</span></span><br><span class="line">    rho = x0(<span class="number">2</span>:<span class="keyword">end</span>) ./ x1(<span class="number">1</span>:<span class="keyword">end</span><span class="number">-1</span>) ;   <span class="comment">% 计算光滑度rho(k) = x0(k)/x1(k-1)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% 画出光滑度的图形，并画上0.5的直线，表示临界值</span></span><br><span class="line">    <span class="built_in">figure</span>(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">plot</span>(year(<span class="number">2</span>:<span class="keyword">end</span>),rho,<span class="string">'o-'</span>,[year(<span class="number">2</span>),year(<span class="keyword">end</span>)],[<span class="number">0.5</span>,<span class="number">0.5</span>],<span class="string">'-'</span>); grid on;</span><br><span class="line">    text(year(<span class="keyword">end</span><span class="number">-1</span>)+<span class="number">0.2</span>,<span class="number">0.55</span>,<span class="string">'临界线'</span>)   <span class="comment">% 在坐标(year(end-1)+0.2,0.55)上添加文本</span></span><br><span class="line">    set(gca,<span class="string">'xtick'</span>,year(<span class="number">2</span>:<span class="number">1</span>:<span class="keyword">end</span>))  <span class="comment">% 设置x轴横坐标的间隔为1</span></span><br><span class="line">    xlabel(<span class="string">'年份'</span>);  ylabel(<span class="string">'原始数据的光滑度'</span>);  <span class="comment">% 给坐标轴加上标签</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">disp</span>(strcat(<span class="string">'指标1：光滑比小于0.5的数据占比为'</span>,num2str(<span class="number">100</span>*sum(rho&lt;<span class="number">0.5</span>)/(n<span class="number">-1</span>)),<span class="string">'%'</span>))</span><br><span class="line">    <span class="built_in">disp</span>(strcat(<span class="string">'指标2：除去前两个时期外，光滑比小于0.5的数据占比为'</span>,num2str(<span class="number">100</span>*sum(rho(<span class="number">3</span>:<span class="keyword">end</span>)&lt;<span class="number">0.5</span>)/(n<span class="number">-3</span>)),<span class="string">'%'</span>))</span><br><span class="line">    <span class="built_in">disp</span>(<span class="string">'参考标准：指标1一般要大于60%, 指标2要大于90%，你认为本例数据可以通过检验吗？'</span>)</span><br><span class="line">    </span><br><span class="line">    Judge = input(<span class="string">'你认为可以通过准指数规律的检验吗？可以通过请输入1，不能请输入0：'</span>);</span><br><span class="line">    <span class="keyword">if</span> Judge == <span class="number">0</span></span><br><span class="line">        <span class="built_in">disp</span>(<span class="string">'亲，灰色预测模型不适合你的数据哦~ 请考虑其他方法吧 例如ARIMA，指数平滑等'</span>)</span><br><span class="line">        ERROR = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="built_in">disp</span>(<span class="string">'------------------------------------------------------------'</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 当数据量大于4时，我们利用试验组来选择使用传统的GM(1,1)模型、新信息GM(1,1)模型还是新陈代谢GM(1,1)模型； 如果数据量等于4，那么我们直接对三种方法求一个平均来进行预测</span></span><br><span class="line"><span class="keyword">if</span> ERROR == <span class="number">0</span>   <span class="comment">% 如果上述错误均没有发生时，才能执行下面的操作步骤</span></span><br><span class="line">    <span class="keyword">if</span>  n &gt; <span class="number">4</span>  <span class="comment">% 数据量大于4时，将数据分为训练组和试验组(根据原数据量大小n来取，n为5-7个则取最后两年为试验组，n大于7则取最后三年为试验组)</span></span><br><span class="line">        <span class="built_in">disp</span>(<span class="string">'因为原数据的期数大于4，所以我们可以将数据组分为训练组和试验组'</span>)   <span class="comment">% 注意，如果试验组的个数只有1个，那么三种模型的结果完全相同，因此至少要取2个试验组</span></span><br><span class="line">        <span class="keyword">if</span> n &gt; <span class="number">7</span></span><br><span class="line">            test_num = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            test_num = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        train_x0 = x0(<span class="number">1</span>:<span class="keyword">end</span>-test_num);  <span class="comment">% 训练数据</span></span><br><span class="line">        <span class="built_in">disp</span>(<span class="string">'训练数据是: '</span>)</span><br><span class="line">        <span class="built_in">disp</span>(mat2str(train_x0'))  <span class="comment">% mat2str可以将矩阵或者向量转换为字符串显示, 这里加一撇表示转置，把列向量变成行向量方便观看</span></span><br><span class="line">        test_x0 =  x0(<span class="keyword">end</span>-test_num+<span class="number">1</span>:<span class="keyword">end</span>); <span class="comment">% 试验数据</span></span><br><span class="line">        <span class="built_in">disp</span>(<span class="string">'试验数据是: '</span>)</span><br><span class="line">        <span class="built_in">disp</span>(mat2str(test_x0'))  <span class="comment">% mat2str可以将矩阵或者向量转换为字符串显示</span></span><br><span class="line">        <span class="built_in">disp</span>(<span class="string">'------------------------------------------------------------'</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">% 使用三种模型对训练数据进行训练，返回的result就是往后预测test_num期的数据</span></span><br><span class="line">        <span class="built_in">disp</span>(<span class="string">' '</span>)</span><br><span class="line">        <span class="built_in">disp</span>(<span class="string">'***下面是传统的GM(1,1)模型预测的详细过程***'</span>)</span><br><span class="line">        result1 = gm11(train_x0, test_num); <span class="comment">%使用传统的GM(1,1)模型对训练数据，并预测后test_num期的结果</span></span><br><span class="line">        <span class="built_in">disp</span>(<span class="string">' '</span>)</span><br><span class="line">        <span class="built_in">disp</span>(<span class="string">'***下面是进行新信息的GM(1,1)模型预测的详细过程***'</span>)</span><br><span class="line">        result2 = new_gm11(train_x0, test_num); <span class="comment">%使用新信息GM(1,1)模型对训练数据，并预测后test_num期的结果</span></span><br><span class="line">        <span class="built_in">disp</span>(<span class="string">' '</span>)</span><br><span class="line">        <span class="built_in">disp</span>(<span class="string">'***下面是进行新陈代谢的GM(1,1)模型预测的详细过程***'</span>)</span><br><span class="line">        result3 = metabolism_gm11(train_x0, test_num); <span class="comment">%使用新陈代谢GM(1,1)模型对训练数据，并预测后test_num期的结果</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">% 现在比较三种模型对于试验数据的预测结果</span></span><br><span class="line">        <span class="built_in">disp</span>(<span class="string">' '</span>)</span><br><span class="line">        <span class="built_in">disp</span>(<span class="string">'------------------------------------------------------------'</span>)</span><br><span class="line">        <span class="comment">% 绘制对试验数据进行预测的图形（对于部分数据，可能三条直线预测的结果非常接近）</span></span><br><span class="line">        test_year = year(<span class="keyword">end</span>-test_num+<span class="number">1</span>:<span class="keyword">end</span>);  <span class="comment">% 试验组对应的年份</span></span><br><span class="line">        <span class="built_in">figure</span>(<span class="number">3</span>)</span><br><span class="line">        <span class="built_in">plot</span>(test_year,test_x0,<span class="string">'o-'</span>,test_year,result1,<span class="string">'*-'</span>,test_year,result2,<span class="string">'+-'</span>,test_year,result3,<span class="string">'x-'</span>); grid on;</span><br><span class="line">        set(gca,<span class="string">'xtick'</span>,year(<span class="keyword">end</span>-test_num+<span class="number">1</span>): <span class="number">1</span> :year(<span class="keyword">end</span>))  <span class="comment">% 设置x轴横坐标的间隔为1</span></span><br><span class="line">        <span class="built_in">legend</span>(<span class="string">'试验组的真实数据'</span>,<span class="string">'传统GM(1,1)预测结果'</span>,<span class="string">'新信息GM(1,1)预测结果'</span>,<span class="string">'新陈代谢GM(1,1)预测结果'</span>)  <span class="comment">% 注意：如果lengend挡着了图形中的直线，那么lengend的位置可以自己手动拖动</span></span><br><span class="line">        xlabel(<span class="string">'年份'</span>);  ylabel(<span class="string">'排污总量'</span>);  <span class="comment">% 给坐标轴加上标签</span></span><br><span class="line">        <span class="comment">% 计算误差平方和SSE</span></span><br><span class="line">        SSE1 = sum((test_x0-result1).^<span class="number">2</span>);</span><br><span class="line">        SSE2 = sum((test_x0-result2).^<span class="number">2</span>);</span><br><span class="line">        SSE3 = sum((test_x0-result3).^<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">disp</span>(strcat(<span class="string">'传统GM(1,1)对于试验组预测的误差平方和为'</span>,num2str(SSE1)))</span><br><span class="line">        <span class="built_in">disp</span>(strcat(<span class="string">'新信息GM(1,1)对于试验组预测的误差平方和为'</span>,num2str(SSE2)))</span><br><span class="line">        <span class="built_in">disp</span>(strcat(<span class="string">'新陈代谢GM(1,1)对于试验组预测的误差平方和为'</span>,num2str(SSE3)))</span><br><span class="line">        <span class="keyword">if</span> SSE1&lt;SSE2</span><br><span class="line">            <span class="keyword">if</span> SSE1&lt;SSE3</span><br><span class="line">                choose = <span class="number">1</span>;  <span class="comment">% SSE1最小，选择传统GM(1,1)模型</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                choose = <span class="number">3</span>;  <span class="comment">% SSE3最小，选择新陈代谢GM(1,1)模型</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">elseif</span> SSE2&lt;SSE3</span><br><span class="line">            choose = <span class="number">2</span>;  <span class="comment">% SSE2最小，选择新信息GM(1,1)模型</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            choose = <span class="number">3</span>;  <span class="comment">% SSE3最小，选择新陈代谢GM(1,1)模型</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        Model = &#123;<span class="string">'传统GM(1,1)模型'</span>,<span class="string">'新信息GM(1,1)模型'</span>,<span class="string">'新陈代谢GM(1,1)模型'</span>&#125;;</span><br><span class="line">        <span class="built_in">disp</span>(strcat(<span class="string">'因为'</span>,Model(choose),<span class="string">'的误差平方和最小，所以我们应该选择其进行预测'</span>))</span><br><span class="line">        <span class="built_in">disp</span>(<span class="string">'------------------------------------------------------------'</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">%% 选用误差最小的那个模型进行预测</span></span><br><span class="line">        predict_num = input(<span class="string">'请输入你要往后面预测的期数： '</span>);</span><br><span class="line">        <span class="comment">% 计算使用传统GM模型的结果，用来得到另外的返回变量：x0_hat, 相对残差relative_residuals和级比偏差eta</span></span><br><span class="line">        [result, x0_hat, relative_residuals, eta] = gm11(x0, predict_num);  <span class="comment">% 先利用gm11函数得到对原数据拟合的详细结果</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">% % 判断我们选择的是哪个模型，如果是2或3，则更新刚刚由模型1计算出来的预测结果</span></span><br><span class="line">        <span class="keyword">if</span> choose == <span class="number">2</span></span><br><span class="line">            result = new_gm11(x0, predict_num);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">if</span> choose == <span class="number">3</span></span><br><span class="line">            result = metabolism_gm11(x0, predict_num);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">%% 输出使用最佳的模型预测出来的结果</span></span><br><span class="line">        <span class="built_in">disp</span>(<span class="string">'------------------------------------------------------------'</span>)</span><br><span class="line">        <span class="built_in">disp</span>(<span class="string">'对原始数据的拟合结果：'</span>)</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:n</span><br><span class="line">            <span class="built_in">disp</span>(strcat(num2str(year(<span class="built_in">i</span>)), <span class="string">' ： '</span>,num2str(x0_hat(<span class="built_in">i</span>))))</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="built_in">disp</span>(strcat(<span class="string">'往后预测'</span>,num2str(predict_num),<span class="string">'期的得到的结果：'</span>))</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:predict_num</span><br><span class="line">            <span class="built_in">disp</span>(strcat(num2str(year(<span class="keyword">end</span>)+<span class="built_in">i</span>), <span class="string">' ： '</span>,num2str(result(<span class="built_in">i</span>))))</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">%% 如果只有四期数据，那么我们就没必要选择何种模型进行预测，直接对三种模型预测的结果求一个平均值~</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">disp</span>(<span class="string">'因为数据只有4期，因此我们直接将三种方法的结果求平均即可~'</span>)</span><br><span class="line">        predict_num = input(<span class="string">'请输入你要往后面预测的期数： '</span>);</span><br><span class="line">        <span class="built_in">disp</span>(<span class="string">' '</span>)</span><br><span class="line">        <span class="built_in">disp</span>(<span class="string">'***下面是传统的GM(1,1)模型预测的详细过程***'</span>)</span><br><span class="line">        [result1, x0_hat, relative_residuals, eta] = gm11(x0, predict_num);</span><br><span class="line">        <span class="built_in">disp</span>(<span class="string">' '</span>)</span><br><span class="line">        <span class="built_in">disp</span>(<span class="string">'***下面是进行新信息的GM(1,1)模型预测的详细过程***'</span>)</span><br><span class="line">        result2 = new_gm11(x0, predict_num);</span><br><span class="line">        <span class="built_in">disp</span>(<span class="string">' '</span>)</span><br><span class="line">        <span class="built_in">disp</span>(<span class="string">'***下面是进行新陈代谢的GM(1,1)模型预测的详细过程***'</span>)</span><br><span class="line">        result3 = metabolism_gm11(x0, predict_num);</span><br><span class="line">        result = (result1+result2+result3)/<span class="number">3</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">disp</span>(<span class="string">'对原始数据的拟合结果：'</span>)</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:n</span><br><span class="line">            <span class="built_in">disp</span>(strcat(num2str(year(<span class="built_in">i</span>)), <span class="string">' ： '</span>,num2str(x0_hat(<span class="built_in">i</span>))))</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="built_in">disp</span>(strcat(<span class="string">'传统GM(1,1)往后预测'</span>,num2str(predict_num),<span class="string">'期的得到的结果：'</span>))</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:predict_num</span><br><span class="line">            <span class="built_in">disp</span>(strcat(num2str(year(<span class="keyword">end</span>)+<span class="built_in">i</span>), <span class="string">' ： '</span>,num2str(result1(<span class="built_in">i</span>))))</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="built_in">disp</span>(strcat(<span class="string">'新信息GM(1,1)往后预测'</span>,num2str(predict_num),<span class="string">'期的得到的结果：'</span>))</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:predict_num</span><br><span class="line">            <span class="built_in">disp</span>(strcat(num2str(year(<span class="keyword">end</span>)+<span class="built_in">i</span>), <span class="string">' ： '</span>,num2str(result2(<span class="built_in">i</span>))))</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="built_in">disp</span>(strcat(<span class="string">'新陈代谢GM(1,1)往后预测'</span>,num2str(predict_num),<span class="string">'期的得到的结果：'</span>))</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:predict_num</span><br><span class="line">            <span class="built_in">disp</span>(strcat(num2str(year(<span class="keyword">end</span>)+<span class="built_in">i</span>), <span class="string">' ： '</span>,num2str(result3(<span class="built_in">i</span>))))</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="built_in">disp</span>(strcat(<span class="string">'三种方法求平均得到的往后预测'</span>,num2str(predict_num),<span class="string">'期的得到的结果：'</span>))</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:predict_num</span><br><span class="line">            <span class="built_in">disp</span>(strcat(num2str(year(<span class="keyword">end</span>)+<span class="built_in">i</span>), <span class="string">' ： '</span>,num2str(result(<span class="built_in">i</span>))))</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">%% 绘制相对残差和级比偏差的图形(注意：因为是对原始数据的拟合效果评估，所以三个模型都是一样的哦~~~)</span></span><br><span class="line">    <span class="built_in">figure</span>(<span class="number">4</span>)</span><br><span class="line">    subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>)  <span class="comment">% 绘制子图（将图分块）</span></span><br><span class="line">    <span class="built_in">plot</span>(year(<span class="number">2</span>:<span class="keyword">end</span>), relative_residuals,<span class="string">'*-'</span>); grid on;   <span class="comment">% 原数据中的各时期和相对残差</span></span><br><span class="line">    <span class="built_in">legend</span>(<span class="string">'相对残差'</span>); xlabel(<span class="string">'年份'</span>);</span><br><span class="line">    set(gca,<span class="string">'xtick'</span>,year(<span class="number">2</span>:<span class="number">1</span>:<span class="keyword">end</span>))  <span class="comment">% 设置x轴横坐标的间隔为1</span></span><br><span class="line">    subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">plot</span>(year(<span class="number">2</span>:<span class="keyword">end</span>), eta,<span class="string">'o-'</span>); grid on;   <span class="comment">% 原数据中的各时期和级比偏差</span></span><br><span class="line">    <span class="built_in">legend</span>(<span class="string">'级比偏差'</span>); xlabel(<span class="string">'年份'</span>);</span><br><span class="line">    set(gca,<span class="string">'xtick'</span>,year(<span class="number">2</span>:<span class="number">1</span>:<span class="keyword">end</span>))  <span class="comment">% 设置x轴横坐标的间隔为1</span></span><br><span class="line">    <span class="built_in">disp</span>(<span class="string">' '</span>)</span><br><span class="line">    <span class="built_in">disp</span>(<span class="string">'****下面将输出对原数据拟合的评价结果***'</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">%% 残差检验</span></span><br><span class="line">    average_relative_residuals = <span class="built_in">mean</span>(relative_residuals);  <span class="comment">% 计算平均相对残差 mean函数用来均值</span></span><br><span class="line">    <span class="built_in">disp</span>(strcat(<span class="string">'平均相对残差为'</span>,num2str(average_relative_residuals)))</span><br><span class="line">    <span class="keyword">if</span> average_relative_residuals&lt;<span class="number">0.1</span></span><br><span class="line">        <span class="built_in">disp</span>(<span class="string">'残差检验的结果表明：该模型对原数据的拟合程度非常不错'</span>)</span><br><span class="line">    <span class="keyword">elseif</span> average_relative_residuals&lt;<span class="number">0.2</span></span><br><span class="line">        <span class="built_in">disp</span>(<span class="string">'残差检验的结果表明：该模型对原数据的拟合程度达到一般要求'</span>)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">disp</span>(<span class="string">'残差检验的结果表明：该模型对原数据的拟合程度不太好，建议使用其他模型预测'</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">%% 级比偏差检验</span></span><br><span class="line">    average_eta = <span class="built_in">mean</span>(eta);   <span class="comment">% 计算平均级比偏差</span></span><br><span class="line">    <span class="built_in">disp</span>(strcat(<span class="string">'平均级比偏差为'</span>,num2str(average_eta)))</span><br><span class="line">    <span class="keyword">if</span> average_eta&lt;<span class="number">0.1</span></span><br><span class="line">        <span class="built_in">disp</span>(<span class="string">'级比偏差检验的结果表明：该模型对原数据的拟合程度非常不错'</span>)</span><br><span class="line">    <span class="keyword">elseif</span> average_eta&lt;<span class="number">0.2</span></span><br><span class="line">        <span class="built_in">disp</span>(<span class="string">'级比偏差检验的结果表明：该模型对原数据的拟合程度达到一般要求'</span>)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">disp</span>(<span class="string">'级比偏差检验的结果表明：该模型对原数据的拟合程度不太好，建议使用其他模型预测'</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="built_in">disp</span>(<span class="string">' '</span>)</span><br><span class="line">    <span class="built_in">disp</span>(<span class="string">'------------------------------------------------------------'</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">%% 绘制最终的预测效果图</span></span><br><span class="line">    <span class="built_in">figure</span>(<span class="number">5</span>)  <span class="comment">% 下面绘图中的符号m:洋红色 b:蓝色</span></span><br><span class="line">    <span class="built_in">plot</span>(year,x0,<span class="string">'-o'</span>,  year,x0_hat,<span class="string">'-*m'</span>,  year(<span class="keyword">end</span>)+<span class="number">1</span>:year(<span class="keyword">end</span>)+predict_num,result,<span class="string">'-*b'</span> );   grid on;</span><br><span class="line">    <span class="built_in">hold</span> on;</span><br><span class="line">    <span class="built_in">plot</span>([year(<span class="keyword">end</span>),year(<span class="keyword">end</span>)+<span class="number">1</span>],[x0(<span class="keyword">end</span>),result(<span class="number">1</span>)],<span class="string">'-*b'</span>)</span><br><span class="line">    <span class="built_in">legend</span>(<span class="string">'原始数据'</span>,<span class="string">'拟合数据'</span>,<span class="string">'预测数据'</span>)  <span class="comment">% 注意：如果lengend挡着了图形中的直线，那么lengend的位置可以自己手动拖动</span></span><br><span class="line">    set(gca,<span class="string">'xtick'</span>,[year(<span class="number">1</span>):<span class="number">1</span>:year(<span class="keyword">end</span>)+predict_num])  <span class="comment">% 设置x轴横坐标的间隔为1</span></span><br><span class="line">    xlabel(<span class="string">'年份'</span>);  ylabel(<span class="string">'排污总量'</span>);  <span class="comment">% 给坐标轴加上标签</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>gm11.m</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[result, x0_hat, relative_residuals, eta]</span> = <span class="title">gm11</span><span class="params">(x0, predict_num)</span></span></span><br><span class="line">    <span class="comment">% 函数作用：使用传统的GM(1,1)模型对数据进行预测</span></span><br><span class="line">    <span class="comment">%     x0：要预测的原始数据</span></span><br><span class="line">    <span class="comment">%     predict_num： 向后预测的期数</span></span><br><span class="line">    <span class="comment">% 输出变量 （注意，实际调用时该函数时不一定输出全部结果，就像corrcoef函数一样~，可以只输出相关系数矩阵，也可以附带输出p值矩阵）</span></span><br><span class="line">    <span class="comment">%     result：预测值</span></span><br><span class="line">    <span class="comment">%     x0_hat：对原始数据的拟合值</span></span><br><span class="line">    <span class="comment">%     relative_residuals： 对模型进行评价时计算得到的相对残差</span></span><br><span class="line">    <span class="comment">%     eta： 对模型进行评价时计算得到的级比偏差</span></span><br><span class="line"></span><br><span class="line">    n = <span class="built_in">length</span>(x0); <span class="comment">% 数据的长度</span></span><br><span class="line">    x1=cumsum(x0); <span class="comment">% 计算一次累加值</span></span><br><span class="line">    z1 = (x1(<span class="number">1</span>:<span class="keyword">end</span><span class="number">-1</span>) + x1(<span class="number">2</span>:<span class="keyword">end</span>)) / <span class="number">2</span>;  <span class="comment">% 计算紧邻均值生成数列（长度为n-1）</span></span><br><span class="line">    <span class="comment">% 将从第二项开始的x0当成y，z1当成x，来进行一元回归  y = kx +b</span></span><br><span class="line">    y = x0(<span class="number">2</span>:<span class="keyword">end</span>); x = z1;</span><br><span class="line">    <span class="comment">% 下面的表达式就是第四讲拟合里面的哦~ 当是要注意，此时的样本数应该是n-1，少了一项哦</span></span><br><span class="line">    k = ((n<span class="number">-1</span>)*sum(x.*y)-sum(x)*sum(y))/((n<span class="number">-1</span>)*sum(x.*x)-sum(x)*sum(x));</span><br><span class="line">    b = (sum(x.*x)*sum(y)-sum(x)*sum(x.*y))/((n<span class="number">-1</span>)*sum(x.*x)-sum(x)*sum(x));</span><br><span class="line">    a = -k;  <span class="comment">%注意：k = -a哦</span></span><br><span class="line">    <span class="comment">% 注意： -a就是发展系数,  b就是灰作用量</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">disp</span>(<span class="string">'现在进行GM(1,1)预测的原始数据是: '</span>)</span><br><span class="line">    <span class="built_in">disp</span>(mat2str(x0'))  <span class="comment">% mat2str可以将矩阵或者向量转换为字符串显示</span></span><br><span class="line">    <span class="built_in">disp</span>(strcat(<span class="string">'最小二乘法拟合得到的发展系数为'</span>,num2str(-a),<span class="string">'，灰作用量是'</span>,num2str(b)))</span><br><span class="line">    <span class="built_in">disp</span>(<span class="string">'***************分割线***************'</span>)</span><br><span class="line">    x0_hat=<span class="built_in">zeros</span>(n,<span class="number">1</span>);  x0_hat(<span class="number">1</span>)=x0(<span class="number">1</span>);   <span class="comment">% x0_hat向量用来存储对x0序列的拟合值，这里先进行初始化</span></span><br><span class="line">    <span class="keyword">for</span> m = <span class="number">1</span>: n<span class="number">-1</span></span><br><span class="line">        x0_hat(m+<span class="number">1</span>) = (<span class="number">1</span>-<span class="built_in">exp</span>(a))*(x0(<span class="number">1</span>)-b/a)*<span class="built_in">exp</span>(-a*m);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    result = <span class="built_in">zeros</span>(predict_num,<span class="number">1</span>);  <span class="comment">% 初始化用来保存预测值的向量</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>: predict_num</span><br><span class="line">        result(<span class="built_in">i</span>) = (<span class="number">1</span>-<span class="built_in">exp</span>(a))*(x0(<span class="number">1</span>)-b/a)*<span class="built_in">exp</span>(-a*(n+<span class="built_in">i</span><span class="number">-1</span>)); <span class="comment">% 带入公式直接计算</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">% 计算绝对残差和相对残差</span></span><br><span class="line">    absolute_residuals = x0(<span class="number">2</span>:<span class="keyword">end</span>) - x0_hat(<span class="number">2</span>:<span class="keyword">end</span>);   <span class="comment">% 从第二项开始计算绝对残差，因为第一项是相同的</span></span><br><span class="line">    relative_residuals = <span class="built_in">abs</span>(absolute_residuals) ./ x0(<span class="number">2</span>:<span class="keyword">end</span>);  <span class="comment">% 计算相对残差，注意分子要加绝对值，而且要使用点除</span></span><br><span class="line">    <span class="comment">% 计算级比和级比偏差</span></span><br><span class="line">    class_ratio = x0(<span class="number">2</span>:<span class="keyword">end</span>) ./ x0(<span class="number">1</span>:<span class="keyword">end</span><span class="number">-1</span>) ;  <span class="comment">% 计算级比 sigma(k) = x0(k)/x0(k-1)</span></span><br><span class="line">    eta = <span class="built_in">abs</span>(<span class="number">1</span>-(<span class="number">1</span><span class="number">-0.5</span>*a)/(<span class="number">1</span>+<span class="number">0.5</span>*a)*(<span class="number">1.</span>/class_ratio));  <span class="comment">% 计算级比偏差</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>new_gm11.m</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[result]</span> = <span class="title">new_gm11</span><span class="params">(x0, predict_num)</span></span></span><br><span class="line"><span class="comment">% 函数作用：使用新信息的GM(1,1)模型对数据进行预测</span></span><br><span class="line"><span class="comment">% 输入变量</span></span><br><span class="line"><span class="comment">%     x0：要预测的原始数据</span></span><br><span class="line"><span class="comment">%     predict_num： 向后预测的期数</span></span><br><span class="line"><span class="comment">% 输出变量</span></span><br><span class="line"><span class="comment">%     result：预测值</span></span><br><span class="line">    result = <span class="built_in">zeros</span>(predict_num,<span class="number">1</span>);  <span class="comment">% 初始化用来保存预测值的向量</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span> : predict_num  </span><br><span class="line">        result(<span class="built_in">i</span>) = gm11(x0, <span class="number">1</span>);  <span class="comment">% 将预测一期的结果保存到result中</span></span><br><span class="line">        x0 = [x0; result(<span class="built_in">i</span>)];  <span class="comment">% 更新x0向量，此时x0多了新的预测信息</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>metabolism_gm11.m</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[result]</span> = <span class="title">metabolism_gm11</span><span class="params">(x0, predict_num)</span></span></span><br><span class="line"><span class="comment">% 函数作用：使用新陈代谢的GM(1,1)模型对数据进行预测</span></span><br><span class="line"><span class="comment">% 输入变量</span></span><br><span class="line"><span class="comment">%     x0：要预测的原始数据</span></span><br><span class="line"><span class="comment">%     predict_num： 向后预测的期数</span></span><br><span class="line"><span class="comment">% 输出变量</span></span><br><span class="line"><span class="comment">%     result：预测值</span></span><br><span class="line">    result = <span class="built_in">zeros</span>(predict_num,<span class="number">1</span>);  <span class="comment">% 初始化用来保存预测值的向量</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span> : predict_num  </span><br><span class="line">        result(<span class="built_in">i</span>) = gm11(x0, <span class="number">1</span>);  <span class="comment">% 将预测一期的结果保存到result中</span></span><br><span class="line">        x0 = [x0(<span class="number">2</span>:<span class="keyword">end</span>); result(<span class="built_in">i</span>)];  <span class="comment">% 更新x0向量，此时x0多了新的预测信息，并且删除了最开始的那个向量</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MATLAB </tag>
            
            <tag> 灰色预测 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数学规划模型——作业</title>
      <link href="/2020/03/01/%E6%95%B0%E5%AD%A6%E8%A7%84%E5%88%92%E6%A8%A1%E5%9E%8B%E2%80%94%E2%80%94%E4%BD%9C%E4%B8%9A/"/>
      <url>/2020/03/01/%E6%95%B0%E5%AD%A6%E8%A7%84%E5%88%92%E6%A8%A1%E5%9E%8B%E2%80%94%E2%80%94%E4%BD%9C%E4%B8%9A/</url>
      
        <content type="html"><![CDATA[<h1 id="题目1"><a href="#题目1" class="headerlink" title="题目1"></a>题目1</h1><p><img src="https://gitee.com/pxlsdz/blogImage/raw/master/img/20200301194847.png" alt=""></p><p>解：</p><h2 id="一、问题假设"><a href="#一、问题假设" class="headerlink" title="一、问题假设"></a>一、问题假设</h2><p>1、每名值班护士都正常工作，没有请假现象。<br>2、该医院不存在大的人员变动。<br>3、每名护士都可以连续工作八小时。</p><h2 id="二、问题分析"><a href="#二、问题分析" class="headerlink" title="二、问题分析"></a>二、问题分析</h2><p>​      分析该问题，可以得出该问题是一个整数规划问题，求解需雇佣的最少护士人数，所以应该，建立目标函数以及对应的约束条件。根据每班的人数列出目标函数，根据六个时间段所需要的最少护土数建立六个约束条件。</p><h2 id="三、符号说明"><a href="#三、符号说明" class="headerlink" title="三、符号说明"></a>三、符号说明</h2><p><img src="https://gitee.com/pxlsdz/blogImage/raw/master/img/20200301195614.png" alt=""></p><h2 id="四、模型建立"><a href="#四、模型建立" class="headerlink" title="四、模型建立"></a>四、模型建立</h2><p>根据题意判断出该问题属于求解最优化问题，需要确定目标函数和约束条件，具体模型如下：<br>$$<br>\min Z=x_{1}+x_{2}+x_{3}+x_{4}+x_{5}+x_{6}<br>\<br>s.t.<br>\quad \quad\left[\begin{array}{l}x_{1}+x_{6} \geq 20 \ x_{1}+x_{2} \geq 7 \ x_{2}+x_{3} \geq 60 \ x_{3}+x_{4} \geq 30 \ x_{4}+x_{5} \geq 20 \ x_{5}+x_{6} \geq 30 \<br>x_{i}∈整数,i=1,2……,6<br>\end{array}\right.<br>$$</p><h2 id="五、代码"><a href="#五、代码" class="headerlink" title="五、代码"></a>五、代码</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% 护士排班问题</span></span><br><span class="line">clear </span><br><span class="line"><span class="comment">% (1) 系数向量</span></span><br><span class="line">c = <span class="built_in">ones</span>(<span class="number">6</span>,<span class="number">1</span>); </span><br><span class="line"><span class="comment">% (2) 不等式约束</span></span><br><span class="line">A =<span class="built_in">zeros</span>(<span class="number">6</span>,<span class="number">6</span>);</span><br><span class="line">A(<span class="number">1</span>,<span class="number">1</span>) = <span class="number">-1</span>; A(<span class="number">1</span>,<span class="number">6</span>) = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="number">5</span></span><br><span class="line">    A(<span class="built_in">i</span>+<span class="number">1</span>, <span class="built_in">i</span>) = <span class="number">-1</span>;  A(<span class="built_in">i</span>+<span class="number">1</span>,<span class="built_in">i</span>+<span class="number">1</span>) = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">b = -[<span class="number">60</span> <span class="number">70</span> <span class="number">60</span> <span class="number">50</span> <span class="number">20</span> <span class="number">30</span>]';</span><br><span class="line"><span class="comment">%（3）上下界</span></span><br><span class="line">lb = <span class="built_in">zeros</span>(<span class="number">6</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 注意，这题应该是一个整数规划问题哦</span></span><br><span class="line">intcon = [<span class="number">1</span>:<span class="number">6</span>];</span><br><span class="line">[x fval] = intlinprog(c,intcon, A, b, [], [], lb)  </span><br><span class="line"><span class="comment">% fval =</span></span><br><span class="line"><span class="comment">%    150</span></span><br><span class="line"><span class="comment">% 注：本题的x可能有多个解！</span></span><br></pre></td></tr></table></figure><h1 id="题目2"><a href="#题目2" class="headerlink" title="题目2"></a>题目2</h1><p>​       一架货机有三个货舱：前舱、中仓和后舱。三个货舱所能装载的货物的最大重量和体积有限制如表1.3所列。并且为了飞机的平衡，三个货舱装载的货物重量必须与其最大的容许量成比例。</p><p>​       <img src="https://gitee.com/pxlsdz/blogImage/raw/master/img/20200301212646.png" alt=""></p><p>​       现有四类货物用该货机进行装运，货物的规格以及装运后获得的利润如表1.4所列。</p><p><img src="https://gitee.com/pxlsdz/blogImage/raw/master/img/20200301212711.png" alt=""></p><p>假设：<br>（1）每种货物可以无限细分；<br>（2）每种货物可以分布在一个或者多个货舱内；<br>（3）不同的货物可以放在同一个货舱内，并且可以保证不留空隙。<br>问应如何装运，能使货机飞行利润最大？</p><p>解:</p><p>用i=1，2，3，4分别表示货物1，货物2，货物3和货物4；j=1，2，3分别表示前舱，中舱和后舱。设$x_{ij}（i=1，2，3，4，j=1，2，3）$表示第i种货物装在第j个货舱j内的重量，$w_{j}，v_{j}（j=1，2，3）$分别表示第个舱的重量限制和体积限制，$a_{i},b_{i},c_{i}（i=1，2，3，4）$分别表示可以运输的第i种货物的重量，单位重量所占的空间和单位货物的利润，则（1）目标函数为<br>$$<br>z=c_{1} \sum_{j=1}^{3} x_{1 j}+c_{2} \sum_{j=1}^{3} x_{2 j}+c_{3} \sum_{j=1}^{3} x_{3 j}+c_{4} \sum_{j=1}^{3} x_{4 j}=\sum_{i=1}^{4} c_{i} \sum_{j=1}^{3} x_{i j}<br>$$<br>约束条件：</p><p><img src="https://gitee.com/pxlsdz/blogImage/raw/master/img/20200301230502.png" alt=""></p><p>决策变量的二维转一维。</p><p><img src="https://gitee.com/pxlsdz/blogImage/raw/master/img/20200301230521.png" alt=""></p><h1 id="题目3"><a href="#题目3" class="headerlink" title="题目3"></a>题目3</h1><p><img src="https://gitee.com/pxlsdz/blogImage/raw/master/img/20200302000940.png" alt=""></p><p><img src="https://gitee.com/pxlsdz/blogImage/raw/master/img/20200302135700.png" alt=""></p><p>main.m</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% 作业三：非线性规划的求解</span></span><br><span class="line">clear;clc</span><br><span class="line">A=[<span class="number">-1</span> <span class="number">-2</span> <span class="number">0</span>];   b=<span class="number">-1</span>;  <span class="comment">% 线性不等式约束</span></span><br><span class="line">x0 = [<span class="number">1</span> <span class="number">0</span> <span class="number">1</span>];  <span class="comment">% 初始值</span></span><br><span class="line">lb = [<span class="number">0</span> -<span class="built_in">inf</span> -<span class="built_in">inf</span>];  <span class="comment">% 下界</span></span><br><span class="line">[x,fval] = fmincon(@fun,x0,A,b,[],[],lb,[],@nonlfun)</span><br><span class="line">fval = -fval</span><br><span class="line"></span><br><span class="line"><span class="comment">% 先使用蒙特卡罗算法确定初始值，然后再进行计算</span></span><br><span class="line">N = <span class="number">1000000</span>;</span><br><span class="line">x1 = unifrnd(<span class="number">0</span>,<span class="number">3</span>,N,<span class="number">1</span>);   <span class="comment">% x1在0~3之间均匀分布</span></span><br><span class="line">x2 = unifrnd(<span class="number">-8</span>,<span class="number">7</span>,N,<span class="number">1</span>);  <span class="comment">% x2在-8~7之间均匀分布</span></span><br><span class="line">x3 = <span class="number">2</span>-x1.^<span class="number">2</span>;   <span class="comment">% x1^2 + x3 = 2, 注意这里要用“.^”，表示每个元素分别平方</span></span><br><span class="line">fmax=-<span class="built_in">inf</span>; <span class="comment">% 初始化函数f的最大值为负无穷（后续只要找到一个比它大的我们就对其更新）</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:N</span><br><span class="line">    x = [x1(<span class="built_in">i</span>), x2(<span class="built_in">i</span>), x3(<span class="built_in">i</span>)];  <span class="comment">%构造x向量, 这里千万别写成了：x =[x1, x2, x3]</span></span><br><span class="line">    <span class="keyword">if</span> (x(<span class="number">1</span>)+<span class="number">2</span>*x(<span class="number">1</span>)^<span class="number">2</span>+x(<span class="number">2</span>)+<span class="number">2</span>*x(<span class="number">2</span>)^<span class="number">2</span>+x(<span class="number">3</span>)<span class="number">-10</span>&lt;=<span class="number">0</span>) &amp; (x(<span class="number">1</span>)+x(<span class="number">1</span>)^<span class="number">2</span>+x(<span class="number">2</span>)+x(<span class="number">2</span>)^<span class="number">2</span>-x(<span class="number">3</span>)<span class="number">-50</span>&lt;=<span class="number">0</span>) &amp; (<span class="number">2</span>*x(<span class="number">1</span>)+x(<span class="number">1</span>)^<span class="number">2</span>+<span class="number">2</span>*x(<span class="number">2</span>)+x(<span class="number">3</span>)<span class="number">-40</span>&lt;=<span class="number">0</span>) &amp; (x(<span class="number">1</span>)+<span class="number">2</span>*x(<span class="number">2</span>)&gt;=<span class="number">1</span>)   <span class="comment">% 判断是否满足条件</span></span><br><span class="line">        result =<span class="number">2</span>*x(<span class="number">1</span>)+<span class="number">3</span>*x(<span class="number">1</span>)^<span class="number">2</span>+<span class="number">3</span>*x(<span class="number">2</span>)+x(<span class="number">2</span>)^<span class="number">2</span>+x(<span class="number">3</span>) ;  <span class="comment">% 如果满足条件就计算函数值</span></span><br><span class="line">        <span class="keyword">if</span>  result  &gt; fmax  <span class="comment">% 如果这个函数值大于我们之前计算出来的最大值</span></span><br><span class="line">            fmax = result;  <span class="comment">% 那么就更新这个函数值为新的最大值</span></span><br><span class="line">            x0 = x;  <span class="comment">% 并且将此时的x1 x2 x3更新为初始值</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">disp</span>(<span class="string">'蒙特卡罗算法选取的初始值为：'</span>); <span class="built_in">disp</span>(x0)</span><br><span class="line">[x,fval] = fmincon(@fun,x0,A,b,[],[],lb,[],@nonlfun)</span><br><span class="line">fval = -fval</span><br></pre></td></tr></table></figure><p>fun.m</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>=<span class="title">fun</span><span class="params">(x)</span></span></span><br><span class="line">    f=<span class="number">2</span>*x(<span class="number">1</span>)+<span class="number">3</span>*x(<span class="number">1</span>)^<span class="number">2</span>+<span class="number">3</span>*x(<span class="number">2</span>)+x(<span class="number">2</span>)^<span class="number">2</span>+x(<span class="number">3</span>);</span><br><span class="line">    f=-f;  <span class="comment">% 最大值加负号改为最小值</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>nonlfun.m</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[c,ceq]</span>=<span class="title">nonlfun</span><span class="params">(x)</span></span></span><br><span class="line">    <span class="comment">% 非线性不等式约束    </span></span><br><span class="line">    c=[x(<span class="number">1</span>)+<span class="number">2</span>*x(<span class="number">1</span>)^<span class="number">2</span>+x(<span class="number">2</span>)+<span class="number">2</span>*x(<span class="number">2</span>)^<span class="number">2</span>+x(<span class="number">3</span>)<span class="number">-10</span></span><br><span class="line">        x(<span class="number">1</span>)+x(<span class="number">1</span>)^<span class="number">2</span>+x(<span class="number">2</span>)+x(<span class="number">2</span>)^<span class="number">2</span>-x(<span class="number">3</span>)<span class="number">-50</span></span><br><span class="line">        <span class="number">2</span>*x(<span class="number">1</span>)+x(<span class="number">1</span>)^<span class="number">2</span>+<span class="number">2</span>*x(<span class="number">2</span>)+x(<span class="number">3</span>)<span class="number">-40</span>];</span><br><span class="line">    <span class="comment">% 非线性等式约束    </span></span><br><span class="line">    ceq=x(<span class="number">1</span>)^<span class="number">2</span>+x(<span class="number">3</span>)<span class="number">-2</span>;  </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h1 id="题目4"><a href="#题目4" class="headerlink" title="题目4"></a>题目4</h1><p>（覆盖问题）某市为方便小学生上学，拟在新建的8个居民小区A1，A2.…，A8，增设若干所小学，经过论证知备选校址有B1，B2，…，B6。它们能够覆盖的居民小区如表2.1所列。</p><p><img src="https://gitee.com/pxlsdz/blogImage/raw/master/img/20200302173438.png" alt=""></p><p><img src="https://gitee.com/pxlsdz/blogImage/raw/master/img/20200302173511.png" alt=""></p><p>按照哪所个小区的顺序列出约束条件。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%%  第四题：覆盖问题</span></span><br><span class="line">c = <span class="built_in">ones</span>(<span class="number">1</span>,<span class="number">6</span>);  <span class="comment">% 目标函数的系数矩阵</span></span><br><span class="line">intcon=[<span class="number">1</span>:<span class="number">6</span>];  <span class="comment">% 整数变量的位置(一共6个决策变量，均为0-1整数变量)</span></span><br><span class="line"><span class="comment">% 线性不等式约束的系数矩阵和常数项向量</span></span><br><span class="line">A =- [<span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">         <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">         <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span>;</span><br><span class="line">         <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span>;</span><br><span class="line">         <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span>;</span><br><span class="line">         <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">         <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span>];</span><br><span class="line">b = -<span class="built_in">ones</span>(<span class="number">7</span>,<span class="number">1</span>);</span><br><span class="line">Aeq = []; beq = [];  <span class="comment">% 不存在线性等式约束</span></span><br><span class="line">lb = <span class="built_in">zeros</span>(<span class="number">1</span>,<span class="number">6</span>);  <span class="comment">% 约束变量的范围下限</span></span><br><span class="line">ub = <span class="built_in">ones</span>(<span class="number">1</span>,<span class="number">6</span>);  <span class="comment">% 约束变量的范围上限</span></span><br><span class="line"><span class="comment">%最后调用intlinprog()函数</span></span><br><span class="line">[x,fval]=intlinprog(c,intcon,A,b,Aeq,beq,lb,ub)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MATLAB </tag>
            
            <tag> 数学规划模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数学规划模型——最大最小化问题</title>
      <link href="/2020/03/01/%E6%95%B0%E5%AD%A6%E8%A7%84%E5%88%92%E6%A8%A1%E5%9E%8B%E2%80%94%E2%80%94%E6%9C%80%E5%A4%A7%E6%9C%80%E5%B0%8F%E5%8C%96%E9%97%AE%E9%A2%98/"/>
      <url>/2020/03/01/%E6%95%B0%E5%AD%A6%E8%A7%84%E5%88%92%E6%A8%A1%E5%9E%8B%E2%80%94%E2%80%94%E6%9C%80%E5%A4%A7%E6%9C%80%E5%B0%8F%E5%8C%96%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="模型-的⼀般形式"><a href="#模型-的⼀般形式" class="headerlink" title="模型 的⼀般形式"></a>模型 的⼀般形式</h1><a id="more"></a><p>​       最大最小化模型在对策论中，我们常遇到这样的问题：在最不利的条件下，寻求最有利的策略.在实际问题中也有许多求最大值的最小化问题，例如急救中心选址问题就是要规划其到所有地点最大距离的最小值，在投资规划中要确定最大风险的最低限度等.为此，对每个$x属于R^{n}$，我们先求诸目标值$f_{i}(x)$的最大值，然后再求这些最大值中的最小值.<br>最大最小化问题的一般数学模型：</p><p><img src="https://gitee.com/pxlsdz/blogImage/raw/master/img/20200301135920.png" alt=""></p><h1 id="典型例题"><a href="#典型例题" class="headerlink" title="典型例题"></a>典型例题</h1><p>选址问题.</p><p>​        设某城市有某种物品的10个需求点，第i个需求点$p_{i}$的坐标为$(a_{i},b_{i})$（见表4-2），道路网与坐标轴平行，彼此正交.现打算建一个该物品的供应中心，且由于受到城市某些条件的限制，该供应中心只能设在x界于[3，8]，y界于[4，10]的范围之内.问该中心应建在何处为好？</p><p><img src="https://gitee.com/pxlsdz/blogImage/raw/master/img/20200301140302.png" alt=""></p><p>​       设供应中心的位置为（x，y），要求它到最远需求点的距离尽可能小，由于道路网与坐标轴平行，彼此正交，<strong>故采用沿道路行走计算距离</strong>，可知每个需求点$p_{i}$，到该中心的距离为$|x-a_{i}|+|y-b_{i}|$，于是模型为：<br>$$<br>\begin{aligned}<br>&amp;\min <em>{(x, y)}\left|\max _{i}\left[\left|x-a</em>{i}\right|+\left|y-b_{i}\right|\right]\right|\<br>&amp;\text { s. t. }\left{\begin{array}{l}<br>3 \leqslant x \leqslant 8 \<br>4 \leqslant y \leqslant 10<br>\end{array}\right.<br>\end{aligned}<br>$$</p><p><img src="https://gitee.com/pxlsdz/blogImage/raw/master/img/20200301145136.png" alt=""></p><p>代码</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% 最大最小化模型  :   min&#123;max[f1,f2,···,fm]&#125;</span></span><br><span class="line">x0 = [<span class="number">6</span>, <span class="number">6</span>];      <span class="comment">% 给定初始值</span></span><br><span class="line">lb = [<span class="number">3</span>, <span class="number">4</span>];  <span class="comment">% 决策变量的下界</span></span><br><span class="line">ub = [<span class="number">8</span>, <span class="number">10</span>];  <span class="comment">% 决策变量的上界</span></span><br><span class="line">[x,feval] = fminimax(@Fun,x0,[],[],[],[],lb,ub)</span><br><span class="line"><span class="built_in">max</span>(feval)</span><br><span class="line"><span class="comment">% x =</span></span><br><span class="line"><span class="comment">%     8.0000    8.5000</span></span><br><span class="line"><span class="comment">% feval =</span></span><br><span class="line"><span class="comment">%    13.5000    5.5000    5.000   12.5000    8.5000    8.5000    5.5000   13.5000    9.5000    0.5000</span></span><br><span class="line"><span class="comment">% 结论：</span></span><br><span class="line"><span class="comment">% 在坐标为(8,8.5)处建立供应中心可以使该点到各需求点的最大距离最小，最小的最大距离为13.5单位。</span></span><br></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span> = <span class="title">Fun</span><span class="params">(x)</span></span></span><br><span class="line">    a=[<span class="number">1</span> <span class="number">4</span> <span class="number">3</span> <span class="number">5</span> <span class="number">9</span> <span class="number">12</span> <span class="number">6</span> <span class="number">20</span> <span class="number">17</span> <span class="number">8</span>];</span><br><span class="line">    b=[<span class="number">2</span> <span class="number">10</span> <span class="number">8</span> <span class="number">18</span> <span class="number">1</span> <span class="number">4</span> <span class="number">5</span> <span class="number">10</span> <span class="number">8</span> <span class="number">9</span>];</span><br><span class="line">    <span class="comment">%  函数向量</span></span><br><span class="line">    f=<span class="built_in">zeros</span>(<span class="number">10</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="number">10</span></span><br><span class="line">        f(<span class="built_in">i</span>) = <span class="built_in">abs</span>(x(<span class="number">1</span>)-a(<span class="built_in">i</span>))+<span class="built_in">abs</span>(x(<span class="number">2</span>)-b(<span class="built_in">i</span>));  </span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="comment">% f(1) = abs(x(1)-a(1))+abs(x(2)-b(1));  </span></span><br><span class="line"><span class="comment">% f(2) = abs(x(1)-a(2))+abs(x(2)-b(2));</span></span><br><span class="line"><span class="comment">% f(3) = abs(x(1)-a(3))+abs(x(2)-b(3));</span></span><br><span class="line"><span class="comment">% f(4) = abs(x(1)-a(4))+abs(x(2)-b(4));</span></span><br><span class="line"><span class="comment">% f(5) = abs(x(1)-a(5))+abs(x(2)-b(5));</span></span><br><span class="line"><span class="comment">% f(6) = abs(x(1)-a(6))+abs(x(2)-b(6));</span></span><br><span class="line"><span class="comment">% f(7) = abs(x(1)-a(7))+abs(x(2)-b(7));</span></span><br><span class="line"><span class="comment">% f(8) = abs(x(1)-a(8))+abs(x(2)-b(8));</span></span><br><span class="line"><span class="comment">% f(9) = abs(x(1)-a(9))+abs(x(2)-b(9));</span></span><br><span class="line"><span class="comment">% f(10) = abs(x(1)-a(10))+abs(x(2)-b(10));</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MATLAB </tag>
            
            <tag> 数学规划模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络测试与分析--网络系统性能和网络流量测试(2)</title>
      <link href="/2020/02/29/%E7%BD%91%E7%BB%9C%E6%B5%8B%E8%AF%95%E4%B8%8E%E5%88%86%E6%9E%90-%E7%BD%91%E7%BB%9C%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E5%92%8C%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E6%B5%8B%E8%AF%95(2)/"/>
      <url>/2020/02/29/%E7%BD%91%E7%BB%9C%E6%B5%8B%E8%AF%95%E4%B8%8E%E5%88%86%E6%9E%90-%E7%BD%91%E7%BB%9C%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E5%92%8C%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E6%B5%8B%E8%AF%95(2)/</url>
      
        <content type="html"><![CDATA[<h1 id="网络容量"><a href="#网络容量" class="headerlink" title="网络容量"></a>网络容量</h1><a id="more"></a><h2 id="交换机的交换容量"><a href="#交换机的交换容量" class="headerlink" title="交换机的交换容量"></a>交换机的交换容量</h2><p>交换机的交换容量又称为背板带宽或交换带宽，是交换机接口处理器或接口卡和数据总线间所能<strong>吞吐的最大数据量</strong>。<br>$$<br>交换容量=缓存位宽*缓存总线频率<br>$$<br>eg:</p><p>交换机的缓存位宽为96bit、缓存总线频率为133MHz，那么其交换容量就为：<br>$$<br>96*133=12.8Gbps<br>$$</p><p>这是交换机实际能转发的速率，也是交换机的实际工作能力。</p><h2 id="端口容量"><a href="#端口容量" class="headerlink" title="端口容量"></a>端口容量</h2><p>由一台24个100Mbps口的交换机构成的子网段，各端口的连接介质都是5类的非屏蔽双绞线（速度能100Mbps），<strong>如果要求各端口都以全双工100Mbps的速度工作。</strong><br>则该交换机的端口容量是：<br>$$<br>端口容量=2<em>（n</em>100Mbps+m<em>1000Mbps）<br>             \=2</em>24*100Mbps=4.8Gbps<br>$$</p><p> n：表示交换机有n个100M端口，</p><p>m：表示交换机有m个1000M端口，含有其他速率的端口时其容量计算也类似。</p><p><strong>如果要保证该网段能够全线速工作，则该交换机的交换容量必须达到4.8Gbps以上。</strong></p><h2 id="帧的转发速度计算"><a href="#帧的转发速度计算" class="headerlink" title="帧的转发速度计算"></a>帧的转发速度计算</h2><p><strong>线速</strong>：物理介质上允许的最大传输速度。</p><p><strong>衡量一个二层设备的性能好坏时，主要使用的是帧转发速度。</strong></p><p>   一个普通的线速：物理介质上允许的最大传输速度。以太网数据帧大小可以从64字节到1518字节，长度是不固定的，那么帧的转发速度也就因帧的长度不同而各异。</p><p>   以10Mbps的Ethernet来说，最小的数据帧长度为64bytes，即512bit，<strong>帧间隙最小为12bytes,即96bits，帧的前同步位8bytes，即64bit</strong>。</p><p>因此10Mbps Ethernets所能达到的帧的最快转发速度为：<br>$$<br>10Mbps/（512+96+64）b\ =10^{7}bps/672b=14，881pps（帧每秒）<br>$$</p><h2 id="端口转发能力"><a href="#端口转发能力" class="headerlink" title="端口转发能力"></a>端口转发能力</h2><p>$$<br>线速度bps/[8*（每帧大小byte+20）]<br>$$</p><p>20:<strong>帧间隙最小为12bytes,即96bits，帧的前同步位8bytes，即64bit</strong></p><p>我们如何去衡量一个交换机的交换容量是否够用呢？</p><p>结论1.所有端口容量乘以端口数量之和的2倍应该<strong>小于交换容量</strong>，这样可实现<strong>全双工无阻塞交换</strong>，证明交换机具有发挥最大数据交换性能的条件。</p><p>结论2.<strong>满配置吞吐量（Mpps）&gt;=满配置端口数×1.488Mpps</strong>，其中1个千兆端口在包长为64字节时的理论吞吐量为1.488Mpps。</p><p>例如，一台最多可以提供64个千兆端口的交换机，其满配置吞吐量应达到64×1.488Mpps = 95.2Mpps，才能够确保在所有端口均线速工作时，提供<strong>无阻塞的包交换</strong>。</p><p>反例：如果一台交换机最多能够提供176个千兆端口，而宣称的吞吐量为不到261.8Mpps（176×1.488Mpps = 261.8Mpps），那么用户有理由认为该交换机采用的是<strong>有阻塞的结构设计</strong>。</p><h2 id="以太网有效吞吐量"><a href="#以太网有效吞吐量" class="headerlink" title="以太网有效吞吐量"></a>以太网有效吞吐量</h2><p>以太网有效吞吐量计算公式（即不含校验位、帧间隙和前<br>导位）则为：<br>$$<br>（帧大小byte*线速度bps）/（前导位+帧大小+校验位+帧间隙）<br>$$<br>例1：</p><p>100M以太网口，64字节帧的最大有效吞吐量为<br>$$<br>60*100/（8+60+4+12）=71.4Mbps<br>$$</p><p>例2：</p><p>计算两级24口100Mbps以太网交换机构成的网络容量，线路为5类非屏蔽双绞线，<strong>假设各端口的流量都须流经上联端口，且各端口均在满负载的情况下。</strong></p><p>最低端口分摊速度=100Mbps/23/23=189kbps<br>则其64字节帧的最大有效吞吐量为60*189kbps/（8+60+4+12）=135kbps</p><h1 id="网络性能"><a href="#网络性能" class="headerlink" title="网络性能"></a>网络性能</h1><p>​       最常见的以太网其二层协议采用的是CSMA/CD（载波监听多路访问/冲突检测方法）的存取访问方式，<strong>资源的争用冲突是必然存在的</strong>，但过多的冲突会导致网络性能下降，以至于严重时会出现瘫痪的情况。</p><p>​       例如通常交换机有3类数据包缓冲区，一类针对小型数据包，一类针对中型数据包，一类针对大型数据包。</p><ul><li><p>小包就直接用ping命令即可</p><p>当发送多个ping数据包时，该命令会自动计算并显示出这些数据包响应时间的平均值。<br>例如，ping  -n  10   211.84.7.10</p></li></ul><h1 id="网络利用率"><a href="#网络利用率" class="headerlink" title="网络利用率"></a>网络利用率</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><pre><code>某一网络链路的网络利用室就是在给定时间内，该链路上**收发信息字节数的总和**除以**该链路或设备接口的总容量**。</code></pre><h2 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h2><p>$$<br>利用率=（（发送数据数bytes+接收数据数bytes）<em>8）/（<br>线路容量</em>统计时间）*100%<br>$$</p><p>$$<br>两个远程端点之间的网络利用率=（（发送数据数bytes+<br>接收数据数bytes）<em>8）/（对应网络吞吐量</em>统计时间）<br>*100%<br>$$</p><h1 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h1><ol><li><p>一台交换机最多能够提供24个100M端口，而宣称的吞吐量为3Mpps，那么当每个端口均传输包长为64字节的以太网帧时，用户有理由认为该交换机采用的是（  ）<br>有阻塞的结构设计<br>无阻塞的结构设计</p></li><li><p>100M以太网口，128字节帧的最大有效吞吐量为                                                       Mbps。</p></li><li><p>可用于网络响应时间测试的命令为（ D  ）<br>Ping –t<br>Ping –l<br>Ping –r<br>Ping –n</p></li><li><p>在下图中，如果希望通过端口镜像在A机上监测B机的流量，则哪一个交换机端口应该被配置为镜像源端口？（ B ）哪一个交换机端口应该被配置为镜像目的端口？ （A  ）</p><p><img src="https://gitee.com/pxlsdz/blogImage/raw/master/img/20200304075504.png" alt=""></p><p>A. F0/1<br>B. F0/2<br>C. F0/3         </p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 网络测试与分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课堂笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络系统集成--实验</title>
      <link href="/2020/02/28/%E7%BD%91%E7%BB%9C%E7%B3%BB%E7%BB%9F%E9%9B%86%E6%88%90--%E5%AE%9E%E9%AA%8C%E5%92%8C%E5%91%BD%E4%BB%A4/"/>
      <url>/2020/02/28/%E7%BD%91%E7%BB%9C%E7%B3%BB%E7%BB%9F%E9%9B%86%E6%88%90--%E5%AE%9E%E9%AA%8C%E5%92%8C%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="实验1"><a href="#实验1" class="headerlink" title="实验1"></a>实验1</h1><h2 id="路由器的基本设置"><a href="#路由器的基本设置" class="headerlink" title="路由器的基本设置"></a>路由器的基本设置</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">输入命令将路由器名称配置为“R2”。</span><br><span class="line">Router<span class="comment"># configure terminal</span></span><br><span class="line">Enter configuration commands, one per line. End <span class="keyword">with</span> CNTL/Z.</span><br><span class="line">Router(config)<span class="comment"># configure terminal</span></span><br><span class="line">***您必须输入确切完整的命令。 包含名称或密码的命令区分大小写。***</span><br><span class="line">Router(config)<span class="comment"># hostname R2</span></span><br><span class="line">将加密密码配置为“<span class="class"><span class="keyword">class</span>”。</span></span><br><span class="line"><span class="class"><span class="title">R2</span><span class="params">(config)</span># <span class="title">enable</span> <span class="title">secret</span> <span class="title">class</span></span></span><br><span class="line"><span class="class">将控制台线路密码配置为“<span class="title">cisco</span>”并要求用户登录。 然后退出线路配置模式。</span></span><br><span class="line"><span class="class"><span class="title">R2</span><span class="params">(config)</span># <span class="title">line</span> <span class="title">console</span> 0</span></span><br><span class="line"><span class="class"><span class="title">R2</span><span class="params">(config-line)</span># <span class="title">password</span> <span class="title">cisco</span></span></span><br><span class="line"><span class="class"><span class="title">R2</span><span class="params">(config-line)</span># <span class="title">login</span></span></span><br><span class="line"><span class="class"><span class="title">R2</span><span class="params">(config-line)</span># <span class="title">exit</span></span></span><br><span class="line"><span class="class">将线路 0 到 4 的 <span class="title">vty</span> 密码配置为“<span class="title">cisco</span>”并要求用户登录。</span></span><br><span class="line"><span class="class"><span class="title">R2</span><span class="params">(config)</span># <span class="title">line</span> <span class="title">vty</span> 0 4</span></span><br><span class="line"><span class="class"><span class="title">R2</span><span class="params">(config-line)</span># <span class="title">password</span> <span class="title">cisco</span></span></span><br><span class="line"><span class="class"><span class="title">R2</span><span class="params">(config-line)</span># <span class="title">login</span></span></span><br><span class="line"><span class="class">退出线路配置模式，并加密所有明文密码。</span></span><br><span class="line"><span class="class"><span class="title">R2</span><span class="params">(config-line)</span># <span class="title">exit</span></span></span><br><span class="line"><span class="class"><span class="title">R2</span><span class="params">(config)</span># <span class="title">service</span> <span class="title">password</span>-<span class="title">encryption</span></span></span><br><span class="line"><span class="class">输入提示语“<span class="title">Authorized</span> <span class="title">Access</span> <span class="title">Only</span>!”并使用 # 作为定界符。</span></span><br><span class="line"><span class="class"><span class="title">R2</span><span class="params">(config)</span># <span class="title">banner</span> <span class="title">motd</span> #<span class="title">Authorized</span> <span class="title">Access</span> <span class="title">Only</span>!#</span></span><br><span class="line"><span class="class">退出全局配置模式，并保存配置。</span></span><br><span class="line"><span class="class"><span class="title">R2</span><span class="params">(config)</span># <span class="title">exit</span></span></span><br><span class="line"><span class="class"><span class="title">R2</span># <span class="title">copy</span> <span class="title">running</span>-<span class="title">config</span> <span class="title">startup</span>-<span class="title">config</span></span></span><br><span class="line"><span class="class"><span class="title">Destination</span> <span class="title">filename</span> [<span class="title">startup</span>-<span class="title">config</span>]? </span></span><br><span class="line"><span class="class"><span class="title">Building</span> <span class="title">configuration</span>...</span></span><br><span class="line"><span class="class">[<span class="title">OK</span>]</span></span><br><span class="line"><span class="class"><span class="title">R2</span>#</span></span><br><span class="line"><span class="class">您已成功配置 <span class="title">R2</span> 的初始设置。</span></span><br></pre></td></tr></table></figure><h2 id="配置-IPv4-路由器接口"><a href="#配置-IPv4-路由器接口" class="headerlink" title="配置 IPv4 路由器接口"></a>配置 IPv4 路由器接口</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">使用 IP 地址“<span class="number">10.1</span><span class="number">.1</span><span class="number">.1</span>”和子网掩码“<span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span>”来配置 GigabitEthernet <span class="number">0</span>/<span class="number">0</span> 接口。 将此链路描述为“LAN <span class="number">3</span> 的链路”并激活该接口。</span><br><span class="line">R2(config)<span class="comment"># interface gigabitethernet 0/0</span></span><br><span class="line">R2(config-<span class="keyword">if</span>)<span class="comment"># ip address 10.1.1.1 255.255.255.0</span></span><br><span class="line">R2(config-<span class="keyword">if</span>)<span class="comment"># description Link to LAN 3</span></span><br><span class="line">R2(config-<span class="keyword">if</span>)<span class="comment"># no shutdown</span></span><br><span class="line">%LINK<span class="number">-5</span>-CHANGED: Interface GigabitEthernet0/<span class="number">0</span>, changed state to up</span><br><span class="line">%LINEPROTO<span class="number">-5</span>-UPDOWN: Line protocol on Interface GigabitEthernet0/<span class="number">0</span>, changed state to up</span><br><span class="line">使用 IP 地址“<span class="number">10.1</span><span class="number">.2</span><span class="number">.1</span>”和子网掩码“<span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span>”来配置 GigabitEthernet <span class="number">0</span>/<span class="number">1</span> 接口。 将此链路描述为“LAN <span class="number">4</span> 的链路”并激活该接口。</span><br><span class="line">R2(config-<span class="keyword">if</span>)<span class="comment"># interface gigabitethernet 0/1</span></span><br><span class="line">R2(config-<span class="keyword">if</span>)<span class="comment"># ip address 10.1.2.1 255.255.255.0</span></span><br><span class="line">R2(config-<span class="keyword">if</span>)<span class="comment"># description Link to LAN 4</span></span><br><span class="line">R2(config-<span class="keyword">if</span>)<span class="comment"># no shutdown</span></span><br><span class="line">%LINK<span class="number">-5</span>-CHANGED: Interface GigabitEthernet0/<span class="number">1</span>, changed state to up</span><br><span class="line">%LINEPROTO<span class="number">-5</span>-UPDOWN: Line protocol on Interface GigabitEthernet0/<span class="number">1</span>, changed state to up</span><br><span class="line"></span><br><span class="line">使用 IP 地址“<span class="number">209.165</span><span class="number">.200</span><span class="number">.226</span>”和子网掩码“<span class="number">255.255</span><span class="number">.255</span><span class="number">.252</span>”配置 Serial <span class="number">0</span>/<span class="number">0</span>/<span class="number">0</span> 接口。 将此链路描述为“R1 的链路”并激活该接口。</span><br><span class="line">R2(config-<span class="keyword">if</span>)<span class="comment"># interface Serial 0/0/0</span></span><br><span class="line">R2(config-<span class="keyword">if</span>)<span class="comment"># ip address 209.165.200.226 255.255.255.252</span></span><br><span class="line">R2(config-<span class="keyword">if</span>)<span class="comment"># description Link to R1</span></span><br><span class="line">R2(config-<span class="keyword">if</span>)<span class="comment"># no shutdown</span></span><br><span class="line">%LINK<span class="number">-5</span>-CHANGED: Interface Serial0/<span class="number">0</span>/<span class="number">0</span>, changed state to up</span><br><span class="line">%LINEPROTO<span class="number">-5</span>-UPDOWN: Line protocol on Interface Serial0/<span class="number">0</span>/<span class="number">0</span>, changed state to up</span><br><span class="line"></span><br><span class="line">您已成功配置 R2 路由器接口。</span><br></pre></td></tr></table></figure><h2 id="配置-IPv6-路由器接口"><a href="#配置-IPv6-路由器接口" class="headerlink" title="配置 IPv6 路由器接口"></a>配置 IPv6 路由器接口</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">使用 Ipv6 地址 <span class="number">2001</span>:db8:acad:<span class="number">4</span>::<span class="number">1</span>/<span class="number">64</span> 来配置 GigabitEthernet <span class="number">0</span>/<span class="number">0</span> 接口。 将此链路描述为“LAN <span class="number">3</span> 的链路”并激活该接口。</span><br><span class="line">R2(config)<span class="comment"># interface gigabitethernet 0/0</span></span><br><span class="line">R2(config-<span class="keyword">if</span>)<span class="comment"># ipv6 address 2001:db8:acad:4::1/64</span></span><br><span class="line">R2(config-<span class="keyword">if</span>)<span class="comment"># description Link to LAN 3</span></span><br><span class="line">R2(config-<span class="keyword">if</span>)<span class="comment"># no shutdown</span></span><br><span class="line">%LINK<span class="number">-5</span>-CHANGED: Interface GigabitEthernet0/<span class="number">0</span>, changed state to up</span><br><span class="line">%LINEPROTO<span class="number">-5</span>-UPDOWN: Line protocol on Interface GigabitEthernet0/<span class="number">0</span>, changed state to up</span><br><span class="line">使用 Ipv6 地址 <span class="number">2001</span>:db8:acad:<span class="number">5</span>::<span class="number">1</span>/<span class="number">64</span> 来配置 GigabitEthernet <span class="number">0</span>/<span class="number">1</span> 接口。 将此链路描述为“LAN <span class="number">4</span> 的链路”并激活该接口。</span><br><span class="line">R2(config-<span class="keyword">if</span>)<span class="comment"># interface gigabitethernet 0/1</span></span><br><span class="line">R2(config-<span class="keyword">if</span>)<span class="comment"># ipv6 address 2001:db8:acad:5::1/64</span></span><br><span class="line">R2(config-<span class="keyword">if</span>)<span class="comment"># description Link to LAN 4</span></span><br><span class="line">R2(config-<span class="keyword">if</span>)<span class="comment"># no shutdown</span></span><br><span class="line">%LINK<span class="number">-5</span>-CHANGED: Interface GigabitEthernet0/<span class="number">1</span>, changed state to up</span><br><span class="line">%LINEPROTO<span class="number">-5</span>-UPDOWN: Line protocol on Interface GigabitEthernet0/<span class="number">1</span>, changed state to up</span><br><span class="line">使用 IPv6 地址 <span class="number">2001</span>:db8:acad:<span class="number">3</span>::<span class="number">2</span>/<span class="number">64</span> 配置串行 <span class="number">0</span>/<span class="number">0</span>/<span class="number">0</span> 接口。 将此链路描述为“R1 的链路”并激活该接口。</span><br><span class="line">R2(config-<span class="keyword">if</span>)<span class="comment"># interface Serial 0/0/0</span></span><br><span class="line">R2(config-<span class="keyword">if</span>)<span class="comment"># ipv6 address 2001:db8:acad:3::2/64</span></span><br><span class="line">R2(config-<span class="keyword">if</span>)<span class="comment"># description Link to R1</span></span><br><span class="line">R2(config-<span class="keyword">if</span>)<span class="comment"># no shutdown</span></span><br><span class="line">%LINK<span class="number">-5</span>-CHANGED: Interface Serial0/<span class="number">0</span>/<span class="number">0</span>, changed state to up</span><br><span class="line">%LINEPROTO<span class="number">-5</span>-UPDOWN: Line protocol on Interface Serial0/<span class="number">0</span>/<span class="number">0</span>, changed state to up</span><br><span class="line"></span><br><span class="line">您已成功配置 R2 IPv6 路由器接口</span><br></pre></td></tr></table></figure><h2 id="配置-IPv4-环回接口"><a href="#配置-IPv4-环回接口" class="headerlink" title="配置 IPv4 环回接口"></a>配置 IPv4 环回接口</h2><p>环回地址的启用和分配很简单：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Router(config)<span class="comment"># interface loopback number</span></span><br><span class="line"></span><br><span class="line">Router(config-<span class="keyword">if</span>)<span class="comment"># ip address ip-address subnet-mask</span></span><br><span class="line">Router(config-<span class="keyword">if</span>)<span class="comment"># exit</span></span><br></pre></td></tr></table></figure><h2 id="验证接口设置"><a href="#验证接口设置" class="headerlink" title="验证接口设置"></a>验证接口设置</h2><ul><li><p><strong>show ip interface brief</strong> - 显示所有接口的汇总，包括接口的 IPv4 地址和当前运行状态。</p></li><li><p><strong>show ip route</strong> - 显示存储在 RAM 中的 IPv4 路由表的内容。在思科 IOS 15 中，路由表中应当显示活动接口以及由代码“<strong>C</strong>”（连接）或“<strong>L</strong>”（本地）标识的两个相关条目。在较早的 IOS 版本中，只显示带有代码“<strong>C</strong>”的一个条目</p></li><li><p><strong>show running-config interface</strong> <em>interface-id</em> - 显示在指定接口上配置的命令。</p></li><li><p><strong>show interfaces</strong> - 显示设备上所有接口的接口信息和数据包流量计数。</p></li><li><p><strong>show ip interface</strong> - 显示路由器上所有接口的 IPv4 相关信息。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">输入该命令来验证 gigabitethernet <span class="number">0</span>/<span class="number">0</span> 接口设置。</span><br><span class="line">R1<span class="comment"># show interface gigabitethernet 0/0</span></span><br><span class="line"></span><br><span class="line">输入该命令来验证 gigabitethernet <span class="number">0</span>/<span class="number">1</span> 接口设置。</span><br><span class="line">R1<span class="comment"># show interface gigabitethernet 0/1</span></span><br><span class="line"></span><br><span class="line">输入命令检验 Serial <span class="number">0</span>/<span class="number">0</span>/<span class="number">0</span> 接口设置。</span><br><span class="line">R1<span class="comment"># show interface Serial 0/0/0</span></span><br><span class="line"></span><br><span class="line">输入“show ip interface”命令来验证 gigabitethernet <span class="number">0</span>/<span class="number">0</span> IP 接口设置。</span><br><span class="line">R1<span class="comment"># show ip interface gigabitethernet 0/0</span></span><br><span class="line"></span><br><span class="line">输入“show ip interface”命令来验证 gigabitethernet <span class="number">0</span>/<span class="number">1</span> IP 接口设置。</span><br><span class="line">R1<span class="comment"># show ip interface gigabitethernet 0/1</span></span><br><span class="line"></span><br><span class="line">输入“show ip interface”命令来检验 Serial <span class="number">0</span>/<span class="number">0</span>/<span class="number">0</span> IP 接口设置。</span><br><span class="line">R1<span class="comment"># show ip interface Serial 0/0/0</span></span><br></pre></td></tr></table></figure><h2 id="验证-IPv6-接口设置"><a href="#验证-IPv6-接口设置" class="headerlink" title="验证 IPv6 接口设置"></a>验证 IPv6 接口设置</h2><p>与IPv4类似</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">R1<span class="comment"># show ipv6 interface brief </span></span><br><span class="line"></span><br><span class="line">R1<span class="comment"># show ipv6 interface gigabitethernet 0/0</span></span><br><span class="line"></span><br><span class="line">R1<span class="comment">#  show ipv6 route</span></span><br></pre></td></tr></table></figure><h2 id="过滤-show-命令输出"><a href="#过滤-show-命令输出" class="headerlink" title="过滤 show 命令输出"></a>过滤 show 命令输出</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">输入命令过滤“line con”部分的 show running-config 输出。</span><br><span class="line">R1<span class="comment"># show running-config | section line con</span></span><br><span class="line">line con <span class="number">0</span></span><br><span class="line"> password <span class="number">7</span> <span class="number">110</span>A1016141D</span><br><span class="line"> login</span><br><span class="line">输入命令过滤简短列表中的“down”接口。</span><br><span class="line">R1<span class="comment"># show ip interface brief | include down</span></span><br><span class="line">Interface IP-Address OK? Method Status Protocol</span><br><span class="line">Embedded-Service-Engine0/<span class="number">0</span> unassigned YES unset administratively down down</span><br><span class="line">Serial0/<span class="number">0</span>/<span class="number">1</span> unassigned YES unset administratively down down</span><br><span class="line">输入命令排除简短列表中的“up”接口。</span><br><span class="line">R1<span class="comment"># show ip interface brief | exclude up</span></span><br><span class="line">Interface IP-Address OK? Method Status Protocol</span><br><span class="line">Embedded-Service-Engine0/<span class="number">0</span> unassigned YES unset administratively down down</span><br><span class="line">Serial0/<span class="number">0</span>/<span class="number">1</span> unassigned YES unset administratively down down</span><br><span class="line">输入命令过滤以单词 line 开头的 show running-config 输出。</span><br><span class="line">R1<span class="comment"># show running-config | begin line</span></span><br><span class="line">line con <span class="number">0</span> </span><br><span class="line"> password <span class="number">7</span> <span class="number">110</span>A1016141D </span><br><span class="line"> login </span><br><span class="line">line aux <span class="number">0</span> </span><br><span class="line">line <span class="number">2</span> </span><br><span class="line"> no activation-character </span><br><span class="line"> no <span class="keyword">exec</span> </span><br><span class="line"> transport preferred none </span><br><span class="line"> transport input all </span><br><span class="line"> transport output pad telnet rlogin lapb-ta mop udptn v120 </span><br><span class="line">ssh </span><br><span class="line"> stopbits <span class="number">1</span> </span><br><span class="line">line vty <span class="number">0</span> <span class="number">4</span> </span><br><span class="line"> password <span class="number">7</span> <span class="number">030752180500</span> </span><br><span class="line"> login </span><br><span class="line"> transport input all </span><br><span class="line">!  </span><br><span class="line">scheduler allocate <span class="number">20000</span> <span class="number">1000</span> </span><br><span class="line">!  </span><br><span class="line">end </span><br><span class="line"> </span><br><span class="line">R1<span class="comment"># </span></span><br><span class="line">您已成功执行了过滤 show 命令。</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Router(config)<span class="comment"># ip route 0.0.0.0 0.0.0.0</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 网络系统集成 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程笔记 </tag>
            
            <tag> 关键知识点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>蒙特卡罗（洛）模拟</title>
      <link href="/2020/02/27/%E8%92%99%E7%89%B9%E5%8D%A1%E7%BD%97%EF%BC%88%E6%B4%9B%EF%BC%89%E6%A8%A1%E6%8B%9F/"/>
      <url>/2020/02/27/%E8%92%99%E7%89%B9%E5%8D%A1%E7%BD%97%EF%BC%88%E6%B4%9B%EF%BC%89%E6%A8%A1%E6%8B%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="引例"><a href="#引例" class="headerlink" title="引例"></a>引例</h1><h2 id="布丰投针实验"><a href="#布丰投针实验" class="headerlink" title="布丰投针实验"></a>布丰投针实验</h2><a id="more"></a><p><img src="https://gitee.com/pxlsdz/blogImage/raw/master/img/20200228111554.png" alt=""></p><p>法国数学家<a href="https://baike.baidu.com/item/布丰" target="_blank" rel="noopener">布丰</a>（1707-1788）最早设计了投针试验。</p><p>这一方法的步骤是：</p><p>1） 取一张白纸，在上面画上许多条间距为a的平行线。</p><p>2） 取一根长度为l（l≤a） 的针，随机地向画有平行直线的纸上掷n次，观察针与直线相交的次数，记为m。</p><p>3）计算针与直线相交的概率．</p><p>18世纪，法国数学家<a href="https://baike.baidu.com/item/布丰" target="_blank" rel="noopener">布丰</a>提出的“投针问题”，记载于布丰1777年出版的著作中：“在平面上画有一组间距为a的<a href="https://baike.baidu.com/item/平行线" target="_blank" rel="noopener">平行线</a>，将一根长度为l（l≤a）的针任意掷在这个平面上，求此针与平行线中任一条相交的<a href="https://baike.baidu.com/item/概率" target="_blank" rel="noopener">概率</a>。”</p><p>布丰本人证明了，这个概率是：<br>$$<br>p=\frac{2l}{\pi a}<br>$$</p><p>(其中π为<a href="https://baike.baidu.com/item/圆周率" target="_blank" rel="noopener">圆周率</a>）</p><p>由于它与π有关，于是人们想到利用投针试验来估计圆周率的值。</p><p>布丰惊奇地发现：有利的扔出与不利的扔出两者次数的比，是一个包含π的表示式．如果针的长度等于a/2，那么有利扔出的<a href="https://baike.baidu.com/item/概率" target="_blank" rel="noopener">概率</a>为1/π．扔的次数越多，由此能求出越为精确的π的值。</p><p>下面是利用这个公式，用概率的方法得到圆周率的近似值的一些资料。</p><table><thead><tr><th align="left">试验者</th><th align="left">时间</th><th align="left">投掷次数</th><th align="left">相交次数</th><th align="left">圆周率估计值</th></tr></thead><tbody><tr><td align="left">Wolf</td><td align="left">1850年</td><td align="left">5000</td><td align="left">2532</td><td align="left">3.1596</td></tr><tr><td align="left">Smith</td><td align="left">1855年</td><td align="left">3204</td><td align="left">1218.5</td><td align="left">3.1554</td></tr><tr><td align="left">C.De Morgan</td><td align="left">1860年</td><td align="left">600</td><td align="left">382.5</td><td align="left">3.137</td></tr><tr><td align="left"><a href="https://baike.baidu.com/item/Fox" target="_blank" rel="noopener">Fox</a></td><td align="left">1884年</td><td align="left">1030</td><td align="left">489</td><td align="left">3.1595</td></tr><tr><td align="left">Lazzerini</td><td align="left">1901年</td><td align="left">3408</td><td align="left">1808</td><td align="left">3.1415929</td></tr><tr><td align="left">Reina</td><td align="left">1925年</td><td align="left">2520</td><td align="left">859</td><td align="left">3.1795</td></tr></tbody></table><h2 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h2><p><img src="https://gitee.com/pxlsdz/blogImage/raw/master/img/174f04ed9b0a3e2d3259cd4e06d849ee_r.jpg" alt=""></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%%  蒙特卡罗用于布丰投针实验</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% （1）预备知识</span></span><br><span class="line"><span class="comment">%  rand(m,n)函数产生由在[0,1]之间均匀分布的随机数组成的m行n列的矩阵（或称为数组）。</span></span><br><span class="line"><span class="built_in">rand</span>(<span class="number">5</span>,<span class="number">4</span>)</span><br><span class="line"><span class="comment">%     0.8300    0.1048    0.2396    0.4398</span></span><br><span class="line"><span class="comment">%     0.5663    0.1196    0.8559    0.5817</span></span><br><span class="line"><span class="comment">%     0.9281    0.2574    0.3013    0.9355</span></span><br><span class="line"><span class="comment">%     0.3910    0.3173    0.2108    0.1676</span></span><br><span class="line"><span class="comment">%     0.3645    0.4372    0.8819    0.9232</span></span><br><span class="line"><span class="built_in">rand</span>(<span class="number">3</span>) <span class="comment">% 若只给一个输入，则会生成一个方阵</span></span><br><span class="line"><span class="comment">%     0.1709    0.4951    0.0541</span></span><br><span class="line"><span class="comment">%     0.9374    0.8500    0.6155</span></span><br><span class="line"><span class="comment">%     0.2400    0.3156    0.5741</span></span><br><span class="line"><span class="comment">% a + rand(m,n)*(b-a) 可以输出在[a,b]之间均匀分布的随机数组成的m行n列的矩阵。</span></span><br><span class="line"><span class="number">-2</span> + <span class="built_in">rand</span>(<span class="number">3</span>,<span class="number">2</span>) * (<span class="number">2</span> - (<span class="number">-2</span>))  <span class="comment">% 输出在[-2,2]之间均匀分布的随机数组成的3行2列的矩阵。</span></span><br><span class="line"><span class="comment">%    -1.2743    0.6013</span></span><br><span class="line"><span class="comment">%    -1.3084    0.0766</span></span><br><span class="line"><span class="comment">%     1.5075    0.7563</span></span><br><span class="line"><span class="comment">% a + rand(m,n)*(b-a)等价于unifrnd(a,b,m,n)</span></span><br><span class="line">unifrnd(<span class="number">-2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">%% （2）代码部分</span></span><br><span class="line">l =  <span class="number">0.520</span>;     <span class="comment">% 针的长度（任意给的）</span></span><br><span class="line">a = <span class="number">1.314</span>;    <span class="comment">% 平行线的宽度(大于针的长度l即可)</span></span><br><span class="line">n = <span class="number">1000000</span>;    <span class="comment">% 做n次投针试验，n越大求出来的pi越准确</span></span><br><span class="line">m = <span class="number">0</span>;    <span class="comment">% 记录针与平行线相交的次数</span></span><br><span class="line">x = <span class="built_in">rand</span>(<span class="number">1</span>, n) * a / <span class="number">2</span> ;   <span class="comment">% 在[0, a/2]内服从均匀分布随机产生n个数， x中每一个元素表示针的中点和最近的一条平行线的距离</span></span><br><span class="line">phi = <span class="built_in">rand</span>(<span class="number">1</span>, n) * <span class="built_in">pi</span>;    <span class="comment">% 在[0, pi]内服从均匀分布随机产生n个数，phi中的每一个元素表示针和最近的一条平行线的夹角</span></span><br><span class="line"><span class="comment">% axis([0,pi, 0,a/2]);   box on;  % 画一个坐标轴的框架，x轴位于0-pi，y轴位于0-a/2， 并打开图形的边框</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:n  <span class="comment">% 开始循环，依次看每根针是否和直线相交</span></span><br><span class="line">    <span class="keyword">if</span> x(<span class="built_in">i</span>) &lt;= l / <span class="number">2</span> * <span class="built_in">sin</span>(phi (<span class="built_in">i</span>))     <span class="comment">% 如果针和平行线相交</span></span><br><span class="line">        m = m + <span class="number">1</span>;    <span class="comment">% 那么m就要加1</span></span><br><span class="line"><span class="comment">%         plot(phi(i), x(i), 'r.')   % 模仿书上的那个图，横坐标为phi，纵坐标为x , 用红色的小点进行标记</span></span><br><span class="line"><span class="comment">%         hold on  % 在原来的图形上继续绘制</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">p = m / n;    <span class="comment">% 针和平行线相交出现的频率</span></span><br><span class="line">mypi = (<span class="number">2</span> * l) / (a * p);  <span class="comment">% 我们根据公式计算得到的pi</span></span><br><span class="line"><span class="built_in">disp</span>([<span class="string">'蒙特卡罗方法得到pi为：'</span>, num2str(mypi)])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%% （3） 由于一次模拟的结果具有偶然性，因此我们可以重复100次后再来求一个平均的pi</span></span><br><span class="line">result = <span class="built_in">zeros</span>(<span class="number">100</span>,<span class="number">1</span>);  <span class="comment">% 初始化保存100次结果的矩阵</span></span><br><span class="line">l =  <span class="number">0.520</span>;     a = <span class="number">1.314</span>;</span><br><span class="line">n = <span class="number">1000000</span>;    </span><br><span class="line"><span class="keyword">for</span> num = <span class="number">1</span>:<span class="number">100</span></span><br><span class="line">    m = <span class="number">0</span>;  </span><br><span class="line">    x = <span class="built_in">rand</span>(<span class="number">1</span>, n) * a / <span class="number">2</span> ;</span><br><span class="line">    phi = <span class="built_in">rand</span>(<span class="number">1</span>, n) * <span class="built_in">pi</span>;</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:n</span><br><span class="line">        <span class="keyword">if</span> x(<span class="built_in">i</span>) &lt;= l / <span class="number">2</span> * <span class="built_in">sin</span>(phi (<span class="built_in">i</span>))</span><br><span class="line">            m = m + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    p = m / n;</span><br><span class="line">    mypi = (<span class="number">2</span> * l) / (a * p);</span><br><span class="line">    result(num) = mypi;  <span class="comment">% 把求出来的myphi保存到结果矩阵中</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">mymeanpi = <span class="built_in">mean</span>(result);  <span class="comment">% 计算result矩阵中保存的100次结果的均值</span></span><br><span class="line"><span class="built_in">disp</span>([<span class="string">'蒙特卡罗方法得到pi为：'</span>, num2str(mymeanpi)])</span><br></pre></td></tr></table></figure><h1 id="蒙特卡罗方法概述"><a href="#蒙特卡罗方法概述" class="headerlink" title="蒙特卡罗方法概述"></a>蒙特卡罗方法概述</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>​       蒙特卡罗⽅法⼜称统计模拟法，是⼀种随机模拟⽅法，以概率和统计理论⽅法为基础的⼀种计算⽅法，是使⽤随机数 （或更常⻅的伪随机数）来解决很多计算问题的⽅法。将所求解的问题同⼀定的概率模型相联系，⽤电⼦计算机实现统计模拟或抽样，以获得问题的近似解。为象征性地表明这⼀⽅法的概率统计特征，故借⽤赌城蒙特卡罗命名。</p><h2 id="提出"><a href="#提出" class="headerlink" title="提出"></a>提出</h2><p>​       蒙特卡罗⽅法于20世纪40年代美国在第⼆次世界⼤战中研制原⼦弹的“曼哈顿计划”计划的成员S.M.乌拉姆和J. 冯·诺伊曼⾸先提出。数学家冯·诺伊曼⽤驰名世界的赌城—摩纳哥的Monte Carlo—来命名这种⽅法，为它蒙上了⼀ 层神秘⾊彩。在这之前，蒙特卡罗⽅法就已经存在。1777年，法国Buffon提出⽤投针实验的⽅法求圆周率，这被认 为是蒙特卡罗⽅法的起源。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>由⼤数定理可知，当样本容量⾜够⼤时，事件的发⽣频率即为其概率。</p><h2 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h2><ol><li><p>蒙特卡罗是⼀种算法吗 ?</p><p>算法（Algorithm）是指解题⽅案的准确⽽完整的描述，是⼀系列解决问题的清晰指令。蒙特卡罗准确的来说只是⼀ 种思想，或者是是⼀种⽅法。如果我们所求解的问题与概率模型有⼀定的关联，那么我们就可以使⽤计算机多次模拟事 件发⽣，以获得问题的近似解。从数学建模⻆度来看，⼤家千万别认为蒙特卡罗有⼀个通⽤的代码。每个问题对应的代 码都是不同的，我们分析清楚题⽬后，就要⾃⼰进⾏编写适⽤于这个题⽬的代码。</p></li><li><p>蒙特卡罗与计算机仿真的关系</p><p> 计算机仿真（模拟）早期称为蒙特卡罗⽅法，是⼀⻔利⽤随机数实验求解随机问题的⽅法，其主要应⽤在复杂问题的数 值模拟上。但随着计算机的性能的提⾼以及各种新兴产业的发展，⽬前计算机仿真涉及的内容要⼴得多，例如过程控制、动 画仿真、图像静态模拟等都属于计算机仿真的应⽤（例如⽤计算机模拟原⼦弹爆炸的过程、使⽤计算机⽣成特效⼤⽚等）。 在数学建模中，我们不⽤刻意的去区分两者的区别，⼤家只需要知道如何使⽤计算机对问题进⾏模拟即可。</p></li><li><p>蒙特卡罗与枚举法</p><p>枚举法是我们中学就接触的算法，就是把所有可能发⽣情况都考虑进去，最终计算出来⼀个确定结果。这就与蒙特卡罗 ⽅法的想法很类似，蒙特卡罗法模拟的次数越多，计算的就越准确。由于⽣活中有许多事件发⽣的结果都有⽆限种可能（例如⼀个连续分布的取值）,因此我们不可能枚举出所有的结果，这时候就只能通过蒙特卡罗模拟，将⼀个不确定性的问题转 化成很多个确定性问题，并得到⼀个近似解，因此蒙特卡罗算法也可以看成是枚举法的⼀种变异。</p></li></ol><h2 id="已经学过的例⼦"><a href="#已经学过的例⼦" class="headerlink" title="已经学过的例⼦"></a>已经学过的例⼦</h2><p>第⼀期 视频 (AOL) 第七讲 : 多元回归分析 </p><p>探究内⽣性对回归结果的影响</p><p>第⼀期 视频 (AOL) 番外篇 : 基于熵权法对印的模型的修正 </p><p>信息熵和标准差的关系</p><h1 id="蒙特卡罗⽅法-的应⽤实例"><a href="#蒙特卡罗⽅法-的应⽤实例" class="headerlink" title="蒙特卡罗⽅法 的应⽤实例"></a>蒙特卡罗⽅法 的应⽤实例</h1><h2 id="三⻔问题"><a href="#三⻔问题" class="headerlink" title="三⻔问题"></a>三⻔问题</h2><p>​        你参加⼀档电视节⽬，节⽬组提供了ABC三扇⻔， 主持⼈告诉你，其中⼀扇⻔后边有辆汽⻋，其它两扇⻔ 后是空的。 假如你选择了B⻔，这时，主持⼈打开了C⻔，让你 看到C⻔后什么都没有，然后问你要不要改选A⻔？</p><h2 id="有约束的⾮线性规划问题"><a href="#有约束的⾮线性规划问题" class="headerlink" title="有约束的⾮线性规划问题"></a>有约束的⾮线性规划问题</h2><p><img src="https://gitee.com/pxlsdz/blogImage/raw/master/img/20200229112918.png" alt=""></p><p><img src="https://gitee.com/pxlsdz/blogImage/raw/master/img/20200229113257.png" alt=""></p><p><img src="https://gitee.com/pxlsdz/blogImage/raw/master/img/20200229113321.png" alt=""></p><p>代码</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%%  蒙特卡罗求解有约束的非线性规划问题</span></span><br><span class="line"><span class="comment">% max f(x) = x1*x2*x3</span></span><br><span class="line"><span class="comment">% s.t.</span></span><br><span class="line"><span class="comment">% (1) -x1+2*x2+2*x3&gt;=0</span></span><br><span class="line"><span class="comment">% (2) x1+2*x2+2*x3&lt;=72</span></span><br><span class="line"><span class="comment">% (3) x2&lt;=20 &amp; x2&gt;=10</span></span><br><span class="line"><span class="comment">% (4) x1-x2 == 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% （1）预备知识</span></span><br><span class="line"><span class="comment">%  (1) format long g  可以将Matlab的计算结果显示为一般的长数字格式（默认会保留四位小数，或使用科学计数法）</span></span><br><span class="line"><span class="number">5</span>/<span class="number">7</span></span><br><span class="line"><span class="number">5895</span>*<span class="number">514100</span></span><br><span class="line">format long g</span><br><span class="line"><span class="number">5</span>/<span class="number">7</span></span><br><span class="line"><span class="number">5895</span>*<span class="number">514100</span></span><br><span class="line"><span class="comment">%  (2)unifrnd(a,b,m,n)可以输出在[a,b]之间均匀分布的随机数组成的m行n列的矩阵。(等价于 a + rand(m,n)*(b-a))</span></span><br><span class="line">unifrnd(<span class="number">0</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>)</span><br><span class="line"><span class="comment">%           4.07361843196589          3.16179623112705          4.78753417717149</span></span><br><span class="line"><span class="comment">%            4.5289596853781         0.487702024997048          4.82444267599638</span></span><br><span class="line"><span class="comment">%           0.63493408146753          1.39249109433524         0.788065408387741</span></span><br><span class="line"><span class="comment">%            4.5668792806951          2.73440759602492          4.85296390880308</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% （2）代码部分</span></span><br><span class="line">clc,clear;</span><br><span class="line">tic <span class="comment">%计算tic和toc中间部分的代码的运行时间</span></span><br><span class="line">n=<span class="number">10000000</span>; <span class="comment">%生成的随机数组数</span></span><br><span class="line">x1=unifrnd(<span class="number">20</span>,<span class="number">30</span>,n,<span class="number">1</span>);  <span class="comment">% 生成在[20,30]之间均匀分布的随机数组成的n行1列的向量构成x1</span></span><br><span class="line">x2=x1 - <span class="number">10</span>;</span><br><span class="line">x3=unifrnd(<span class="number">-10</span>,<span class="number">16</span>,n,<span class="number">1</span>);  <span class="comment">% 生成在[-10,16]之间均匀分布的随机数组成的n行1列的向量构成x3</span></span><br><span class="line">fmax=-<span class="built_in">inf</span>; <span class="comment">% 初始化函数f的最大值为负无穷（后续只要找到一个比它大的我们就对其更新）</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:n</span><br><span class="line">    x = [x1(<span class="built_in">i</span>), x2(<span class="built_in">i</span>), x3(<span class="built_in">i</span>)];  <span class="comment">%构造x向量, 这里千万别写成了：x =[x1, x2, x3]</span></span><br><span class="line">    <span class="keyword">if</span> (-x(<span class="number">1</span>)+<span class="number">2</span>*x(<span class="number">2</span>)+<span class="number">2</span>*x(<span class="number">3</span>)&gt;=<span class="number">0</span>)  &amp;  (x(<span class="number">1</span>)+<span class="number">2</span>*x(<span class="number">2</span>)+<span class="number">2</span>*x(<span class="number">3</span>)&lt;=<span class="number">72</span>)     <span class="comment">% 判断是否满足条件</span></span><br><span class="line">        result = x(<span class="number">1</span>)*x(<span class="number">2</span>)*x(<span class="number">3</span>);  <span class="comment">% 如果满足条件就计算函数值</span></span><br><span class="line">        <span class="keyword">if</span>  result  &gt; fmax  <span class="comment">% 如果这个函数值大于我们之前计算出来的最大值</span></span><br><span class="line">            fmax = result;  <span class="comment">% 那么就更新这个函数值为新的最大值</span></span><br><span class="line">            X = x;  <span class="comment">% 并且将此时的x1 x2 x3保存到一个变量中</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">disp</span>(strcat(<span class="string">'蒙特卡罗模拟得到的最大值为'</span>,num2str(fmax)))</span><br><span class="line"><span class="built_in">disp</span>(<span class="string">'最大值处x1 x2 x3的取值为：'</span>)</span><br><span class="line"><span class="built_in">disp</span>(X)</span><br><span class="line">toc <span class="comment">%计算tic和toc中间部分的代码的运行时间</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%% （3）缩小范围重新模拟得到更加精确的取值</span></span><br><span class="line">clc,clear;</span><br><span class="line">tic <span class="comment">%计算tic和toc中间部分的代码的运行时间</span></span><br><span class="line">n=<span class="number">10000000</span>; <span class="comment">%生成的随机数组数</span></span><br><span class="line">x1=unifrnd(<span class="number">22</span>,<span class="number">23</span>,n,<span class="number">1</span>);  <span class="comment">% 生成在[22,23]之间均匀分布的随机数组成的n行1列的向量构成x1</span></span><br><span class="line">x2=x1 - <span class="number">10</span>;</span><br><span class="line">x3=unifrnd(<span class="number">11</span>,<span class="number">13</span>,n,<span class="number">1</span>);  <span class="comment">% 生成在[11,13]之间均匀分布的随机数组成的n行1列的向量构成x3</span></span><br><span class="line">fmax=-<span class="built_in">inf</span>; <span class="comment">% 初始化函数f的最大值为负无穷（后续只要找到一个比它大的我们就对其更新）</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:n</span><br><span class="line">    x = [x1(<span class="built_in">i</span>), x2(<span class="built_in">i</span>), x3(<span class="built_in">i</span>)];  <span class="comment">%构造x向量, 这里千万别写成了：x =[x1, x2, x3]</span></span><br><span class="line">    <span class="keyword">if</span> (-x(<span class="number">1</span>)+<span class="number">2</span>*x(<span class="number">2</span>)+<span class="number">2</span>*x(<span class="number">3</span>)&gt;=<span class="number">0</span>)  &amp;  (x(<span class="number">1</span>)+<span class="number">2</span>*x(<span class="number">2</span>)+<span class="number">2</span>*x(<span class="number">3</span>)&lt;=<span class="number">72</span>)     <span class="comment">% 判断是否满足条件</span></span><br><span class="line">        result = x(<span class="number">1</span>)*x(<span class="number">2</span>)*x(<span class="number">3</span>);  <span class="comment">% 如果满足条件就计算函数值</span></span><br><span class="line">        <span class="keyword">if</span>  result  &gt; fmax  <span class="comment">% 如果这个函数值大于我们之前计算出来的最大值</span></span><br><span class="line">            fmax = result;  <span class="comment">% 那么就更新这个函数值为新的最大值</span></span><br><span class="line">            X = x;  <span class="comment">% 并且将此时的x1 x2 x3保存到一个变量中</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">disp</span>(strcat(<span class="string">'蒙特卡罗模拟得到的最大值为'</span>,num2str(fmax)))</span><br><span class="line"><span class="built_in">disp</span>(<span class="string">'最大值处x1 x2 x3的取值为：'</span>)</span><br><span class="line"><span class="built_in">disp</span>(X)</span><br><span class="line">toc <span class="comment">%计算tic和toc中间部分的代码的运行时间</span></span><br></pre></td></tr></table></figure><h2 id="书店-买书-问题-0-1-规划-无脑"><a href="#书店-买书-问题-0-1-规划-无脑" class="headerlink" title="书店 买书 问题 ( 0 - 1 规划)(无脑)"></a>书店 买书 问题 ( 0 - 1 规划)(无脑)</h2><p><img src="https://gitee.com/pxlsdz/blogImage/raw/master/img/20200229121057.png" alt=""></p><p><img src="https://gitee.com/pxlsdz/blogImage/raw/master/img/20200229121137.png" alt=""></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% 书店买书问题的蒙特卡罗的模拟</span></span><br><span class="line"><span class="comment">%% （1）预备知识</span></span><br><span class="line"><span class="comment">% (1)unique函数: 剔除一个矩阵或者向量的重复值，并将结果按照从小到大的顺序排列  </span></span><br><span class="line"><span class="comment">% adj.唯一的; 独一无二的   [ju'ni:k]</span></span><br><span class="line">unique([<span class="number">1</span> <span class="number">2</span> <span class="number">5</span>; <span class="number">6</span> <span class="number">8</span> <span class="number">9</span>;<span class="number">2</span> <span class="number">4</span> <span class="number">6</span>])   </span><br><span class="line">unique([<span class="number">5</span> <span class="number">6</span> <span class="number">8</span> <span class="number">8</span> <span class="number">4</span> <span class="number">1</span> <span class="number">6</span> <span class="number">2</span> <span class="number">2</span> <span class="number">4</span> <span class="number">8</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">% (2)randi([a,b],m,n)函数可在指定区间[a,b]内随机取出大小为m*n的整数矩阵</span></span><br><span class="line">randi([<span class="number">-5</span>,<span class="number">5</span>],<span class="number">2</span>,<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">%% （2）代码求解</span></span><br><span class="line">min_money = +Inf;  <span class="comment">% 初始化最小的花费为无穷大，后续只要找到比它小的就更新</span></span><br><span class="line">min_result = randi([<span class="number">1</span>, <span class="number">6</span>],<span class="number">1</span>,<span class="number">5</span>);  <span class="comment">% 初始化五本书都在哪一家书店购买，后续我们不断对其更新</span></span><br><span class="line"><span class="comment">%若min_result = [5 3 6 2 3]，则解释为：第1本书在第5家店买，第2本书在第3家店买，第3本书在第6家店买，第4本书在第2家店买，第5本书在第3家店买  </span></span><br><span class="line">n = <span class="number">100000</span>;  <span class="comment">% 蒙特卡罗模拟的次数</span></span><br><span class="line">M = [<span class="number">18</span> <span class="number">39</span><span class="number">29</span><span class="number">48</span><span class="number">59</span></span><br><span class="line">        <span class="number">24</span><span class="number">45</span><span class="number">23</span><span class="number">54</span><span class="number">44</span></span><br><span class="line">        <span class="number">22</span><span class="number">45</span><span class="number">23</span><span class="number">53</span><span class="number">53</span></span><br><span class="line">        <span class="number">28</span><span class="number">47</span><span class="number">17</span><span class="number">57</span><span class="number">47</span></span><br><span class="line">        <span class="number">24</span><span class="number">42</span><span class="number">24</span><span class="number">47</span><span class="number">59</span></span><br><span class="line">        <span class="number">27</span><span class="number">48</span><span class="number">20</span><span class="number">55</span><span class="number">53</span>];  <span class="comment">% m_ij  第j本书在第i家店的售价</span></span><br><span class="line">freight = [<span class="number">10</span> <span class="number">15</span> <span class="number">15</span> <span class="number">10</span> <span class="number">10</span> <span class="number">15</span>];  <span class="comment">% 第i家店的运费</span></span><br><span class="line"><span class="keyword">for</span> k = <span class="number">1</span>:n  <span class="comment">% 开始循环</span></span><br><span class="line">    result = k([<span class="number">1</span>, <span class="number">6</span>],<span class="number">1</span>,<span class="number">5</span>); <span class="comment">% 在1-6这些整数中随机抽取一个1*5的向量，表示这五本书分别在哪家书店购买</span></span><br><span class="line">    index = unique(result);  <span class="comment">% 在哪些商店购买了商品，因为我们等下要计算运费</span></span><br><span class="line">    money = sum(freight(index)); <span class="comment">% 计算买书花费的运费</span></span><br><span class="line">    <span class="comment">% 计算总花费：刚刚计算出来的运费 + 五本书的售价</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="number">5</span>   </span><br><span class="line">        money = money + M(result(<span class="built_in">i</span>),<span class="built_in">i</span>);  </span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">if</span> money &lt; min_money  <span class="comment">% 判断刚刚随机生成的这组数据的花费是否小于最小花费，如果小于的话</span></span><br><span class="line">        min_money = money  <span class="comment">% 我们更新最小的花费</span></span><br><span class="line">        min_result = result <span class="comment">% 用这组数据更新最小花费的结果</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">min_money   <span class="comment">% 18+39+48+17+47+20</span></span><br><span class="line">min_result</span><br></pre></td></tr></table></figure><h2 id="导弹追踪问题"><a href="#导弹追踪问题" class="headerlink" title="导弹追踪问题"></a>导弹追踪问题</h2><p><img src="https://gitee.com/pxlsdz/blogImage/raw/master/img/20200229124042.png" alt=""></p><p><img src="https://gitee.com/pxlsdz/blogImage/raw/master/img/20200229124115.png" alt=""></p><p><img src="https://gitee.com/pxlsdz/blogImage/raw/master/img/20200229124153.png" alt=""></p><p><img src="https://gitee.com/pxlsdz/blogImage/raw/master/img/20200229124305.png" alt=""></p><p><img src="https://gitee.com/pxlsdz/blogImage/raw/master/img/20200229124322.png" alt=""></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%%  蒙特卡罗用于模拟导弹追击问题</span></span><br><span class="line">clear;clc</span><br><span class="line"><span class="comment">%% （1）预备知识</span></span><br><span class="line"><span class="comment">% mod(m,n)表示求m/n的余数</span></span><br><span class="line"><span class="built_in">mod</span>(<span class="number">8</span>,<span class="number">3</span>)</span><br><span class="line"><span class="built_in">mod</span>(<span class="number">1000</span>,<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">% 设置横纵坐标的范围并标上字符</span></span><br><span class="line">x = <span class="number">1</span>:<span class="number">0.01</span>:<span class="number">3</span>;</span><br><span class="line">y = x .^ <span class="number">2</span>;</span><br><span class="line"><span class="built_in">plot</span>(x,y)  <span class="comment">% 画出x和y的图形</span></span><br><span class="line">axis([<span class="number">0</span> <span class="number">3</span> <span class="number">0</span> <span class="number">10</span>])  <span class="comment">% 设置横坐标范围为[0, 3] 纵坐标范围为[0, 10]</span></span><br><span class="line">pause(<span class="number">3</span>)  <span class="comment">% 暂停3秒后再继续接下来的命令</span></span><br><span class="line">text(<span class="number">2</span>,<span class="number">4</span>,<span class="string">'清风'</span>)  <span class="comment">% 在坐标为(2,4)的点上标上字符串：清风</span></span><br><span class="line">close <span class="comment">% 关闭图形窗口</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%% (2) 代码求解</span></span><br><span class="line"><span class="comment">% 1. 不画追击的示意图</span></span><br><span class="line">clear;clc</span><br><span class="line">v=<span class="number">200</span>; <span class="comment">% 任意给定B船的速度（后期我们可以再改的）</span></span><br><span class="line">dt=<span class="number">0.0000001</span>; <span class="comment">% 定义时间间隔</span></span><br><span class="line">x=[<span class="number">0</span>,<span class="number">20</span>]; <span class="comment">% 定义导弹和B船的横坐标分别为x(1)和x(2)</span></span><br><span class="line">y=[<span class="number">0</span>,<span class="number">0</span>]; <span class="comment">% 定义导弹和B船的纵坐标分别为y(1)和y(2)</span></span><br><span class="line">t=<span class="number">0</span>; <span class="comment">% 初始化导弹击落B船的时间</span></span><br><span class="line">d=<span class="number">0</span>; <span class="comment">% 初始化导弹飞行的距离</span></span><br><span class="line">m=<span class="built_in">sqrt</span>(<span class="number">2</span>)/<span class="number">2</span>;   <span class="comment">% 将sqrt(2)/2定义为一个常量，使后面看起来很简洁</span></span><br><span class="line">dd=<span class="built_in">sqrt</span>((x(<span class="number">2</span>)-x(<span class="number">1</span>))^<span class="number">2</span>+(y(<span class="number">2</span>)-y(<span class="number">1</span>))^<span class="number">2</span>); <span class="comment">% 导弹与B船的距离</span></span><br><span class="line"><span class="keyword">while</span>(dd&gt;=<span class="number">0.001</span>)  <span class="comment">% 只要两者的距离足够大，就一直循环下去。（两者距离足够小时表示导弹击中，这里的临界值要结合dt来取，否则可能导致错过交界处的情况）</span></span><br><span class="line">    t=t+dt; <span class="comment">% 更新导弹击落B船的时间</span></span><br><span class="line">    d=d+<span class="number">3</span>*v*dt; <span class="comment">% 更新导弹飞行的距离</span></span><br><span class="line">    x(<span class="number">2</span>)=<span class="number">20</span>+t*v*m;  y(<span class="number">2</span>)=t*v*m;   <span class="comment">% 计算新的B船的位置 （注：m=sqrt(2)/2）</span></span><br><span class="line">    dd=<span class="built_in">sqrt</span>((x(<span class="number">2</span>)-x(<span class="number">1</span>))^<span class="number">2</span>+(y(<span class="number">2</span>)-y(<span class="number">1</span>))^<span class="number">2</span>);  <span class="comment">% 更新导弹与B船的距离</span></span><br><span class="line">    tan_alpha=(y(<span class="number">2</span>)-y(<span class="number">1</span>))/(x(<span class="number">2</span>)-x(<span class="number">1</span>));   <span class="comment">% 计算斜率，即tan(α)</span></span><br><span class="line">    cos_alpha=<span class="built_in">sqrt</span>(<span class="number">1</span>/(<span class="number">1</span>+tan_alpha^<span class="number">2</span>));   <span class="comment">% sec(α)^2 = (1+tan(α)^2)</span></span><br><span class="line">    sin_alpha=<span class="built_in">sqrt</span>(<span class="number">1</span>-cos_alpha^<span class="number">2</span>);  <span class="comment">% sin(α)^2 +cos(α)^2 = 1</span></span><br><span class="line">    x(<span class="number">1</span>)=x(<span class="number">1</span>)+<span class="number">3</span>*v*dt*cos_alpha;   y(<span class="number">1</span>)=y(<span class="number">1</span>)+<span class="number">3</span>*v*dt*sin_alpha; <span class="comment">% 计算新的导弹的位置</span></span><br><span class="line">    <span class="keyword">if</span> d&gt;<span class="number">50</span>  <span class="comment">% 导弹的有效射程为50个单位</span></span><br><span class="line">        <span class="built_in">disp</span>(<span class="string">'导弹没有击中B船'</span>);</span><br><span class="line">        <span class="keyword">break</span>;  <span class="comment">% 退出循环</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">if</span> d&lt;=<span class="number">50</span> &amp; dd&lt;<span class="number">0.001</span>   <span class="comment">% 导弹飞行的距离小于50个单位且导弹和B船的距离小于0.001（表示击中）</span></span><br><span class="line">        <span class="built_in">disp</span>([<span class="string">'导弹飞行'</span>,num2str(d),<span class="string">'单位后击中B船'</span>])</span><br><span class="line">        <span class="built_in">disp</span>([<span class="string">'导弹飞行的时间为'</span>,num2str(t*<span class="number">60</span>),<span class="string">'分钟'</span>])</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 2. 画追击的示意图</span></span><br><span class="line">clear;clc</span><br><span class="line">v=<span class="number">200</span>; <span class="comment">% 任意给定B船的速度（后期我们可以再改的）</span></span><br><span class="line">dt=<span class="number">0.0000001</span>; <span class="comment">% 定义时间间隔</span></span><br><span class="line">x=[<span class="number">0</span>,<span class="number">20</span>]; <span class="comment">% 定义导弹和B船的横坐标分别为x(1)和x(2)</span></span><br><span class="line">y=[<span class="number">0</span>,<span class="number">0</span>]; <span class="comment">% 定义导弹和B船的纵坐标分别为y(1)和y(2)</span></span><br><span class="line">t=<span class="number">0</span>; <span class="comment">% 初始化导弹击落B船的时间</span></span><br><span class="line">d=<span class="number">0</span>; <span class="comment">% 初始化导弹飞行的距离</span></span><br><span class="line">m=<span class="built_in">sqrt</span>(<span class="number">2</span>)/<span class="number">2</span>;   <span class="comment">% 将sqrt(2)/2定义为一个常量，使后面看起来很简洁</span></span><br><span class="line">dd=<span class="built_in">sqrt</span>((x(<span class="number">2</span>)-x(<span class="number">1</span>))^<span class="number">2</span>+(y(<span class="number">2</span>)-y(<span class="number">1</span>))^<span class="number">2</span>); <span class="comment">% 导弹与B船的距离</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:<span class="number">2</span></span><br><span class="line">    <span class="built_in">plot</span>(x(<span class="built_in">i</span>),y(<span class="built_in">i</span>),<span class="string">'.k'</span>,<span class="string">'MarkerSize'</span>,<span class="number">1</span>);  <span class="comment">% 画出导弹和B船所在的坐标，点的大小为1，颜色为黑色(k)，用小点表示</span></span><br><span class="line">    grid on;  <span class="comment">% 打开网格线</span></span><br><span class="line">    <span class="built_in">hold</span> on;  <span class="comment">% 不关闭图形，继续画图</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">axis([<span class="number">0</span> <span class="number">30</span> <span class="number">0</span> <span class="number">10</span>])  <span class="comment">% 固定x轴的范围为0-30  固定y轴的范围为0-10</span></span><br><span class="line">k = <span class="number">0</span>;  <span class="comment">% 引入一个变量  为了控制画图的速度（因为Matlab中画图的速度超级慢）</span></span><br><span class="line"><span class="keyword">while</span>(dd&gt;=<span class="number">0.001</span>)  <span class="comment">% 只要两者的距离足够大，就一直循环下去。（两者距离足够小时表示导弹击中，这里的临界值要结合dt来取，否则可能导致错过交界处的情况）</span></span><br><span class="line">    t=t+dt; <span class="comment">% 更新导弹击落B船的时间</span></span><br><span class="line">    d=d+<span class="number">3</span>*v*dt; <span class="comment">% 更新导弹飞行的距离</span></span><br><span class="line">    x(<span class="number">2</span>)=<span class="number">20</span>+t*v*m;  y(<span class="number">2</span>)=t*v*m;   <span class="comment">% 计算新的B船的位置 （注：m=sqrt(2)/2）</span></span><br><span class="line">    dd=<span class="built_in">sqrt</span>((x(<span class="number">2</span>)-x(<span class="number">1</span>))^<span class="number">2</span>+(y(<span class="number">2</span>)-y(<span class="number">1</span>))^<span class="number">2</span>);  <span class="comment">% 更新导弹与B船的距离</span></span><br><span class="line">    tan_alpha=(y(<span class="number">2</span>)-y(<span class="number">1</span>))/(x(<span class="number">2</span>)-x(<span class="number">1</span>));   <span class="comment">% 计算斜率，即tan(α)</span></span><br><span class="line">    cos_alpha=<span class="built_in">sqrt</span>(<span class="number">1</span>/(<span class="number">1</span>+tan_alpha^<span class="number">2</span>));   <span class="comment">% 利用公式：sec(α)^2 = (1+tan(α)^2)  计算出cos(α)</span></span><br><span class="line">    sin_alpha=<span class="built_in">sqrt</span>(<span class="number">1</span>-cos_alpha^<span class="number">2</span>);  <span class="comment">% 利用公式： sin(α)^2 +cos(α)^2 = 1  计算出sin(α)</span></span><br><span class="line">    x(<span class="number">1</span>)=x(<span class="number">1</span>)+<span class="number">3</span>*v*dt*cos_alpha;   y(<span class="number">1</span>)=y(<span class="number">1</span>)+<span class="number">3</span>*v*dt*sin_alpha;   <span class="comment">% 计算新的导弹的位置</span></span><br><span class="line">    k = k +<span class="number">1</span> ;  </span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">mod</span>(k,<span class="number">500</span>) == <span class="number">0</span>   <span class="comment">% 每刷新500次时间就画出下一个导弹和B船所在的坐标  mod(m,n)表示求m/n的余数</span></span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:<span class="number">2</span></span><br><span class="line">            <span class="built_in">plot</span>(x(<span class="built_in">i</span>),y(<span class="built_in">i</span>),<span class="string">'.k'</span>,<span class="string">'MarkerSize'</span>,<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">hold</span> on; <span class="comment">% 不关闭图形，继续画图</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        pause(<span class="number">0.001</span>);  <span class="comment">% 暂停0.001s后再继续下面的操作</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">if</span> d&gt;<span class="number">50</span>  <span class="comment">% 导弹的有效射程为50个单位</span></span><br><span class="line">        <span class="built_in">disp</span>(<span class="string">'导弹没有击中B船'</span>);</span><br><span class="line">        <span class="keyword">break</span>;  <span class="comment">% 退出循环</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">if</span> d&lt;=<span class="number">50</span> &amp; dd&lt;<span class="number">0.001</span>   <span class="comment">% 导弹飞行的距离小于50个单位且导弹和B船的距离小于0.001（表示击中）</span></span><br><span class="line">        <span class="built_in">disp</span>([<span class="string">'导弹飞行'</span>,num2str(d),<span class="string">'个单位后击中B船'</span>])</span><br><span class="line">        <span class="built_in">disp</span>([<span class="string">'导弹飞行的时间为'</span>,num2str(t*<span class="number">60</span>),<span class="string">'分钟'</span>])</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h1 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h1><h2 id="作业1"><a href="#作业1" class="headerlink" title="作业1"></a>作业1</h2><p><img src="https://gitee.com/pxlsdz/blogImage/raw/master/img/20200229113852.png" alt=""></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%%  蒙特卡罗求解非线性规划问题</span></span><br><span class="line"><span class="comment">% min f(x) =2*(x1^2)+x2^2-x1*x2-8*x1-3*x2</span></span><br><span class="line"><span class="comment">% s.t.</span></span><br><span class="line"><span class="comment">% (1) 3*x1+x2&gt;9</span></span><br><span class="line"><span class="comment">% (2) x1+2*x2&lt;16</span></span><br><span class="line"><span class="comment">% (3) x1&gt;0 &amp; x2&gt;0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% （1）初次寻找最小值的代码</span></span><br><span class="line">clc,clear;</span><br><span class="line">format long g   <span class="comment">%可以将Matlab的计算结果显示为一般的长数字格式（默认会保留四位小数，或使用科学计数法）</span></span><br><span class="line">tic <span class="comment">%计算tic和toc中间部分的代码的运行时间</span></span><br><span class="line">n=<span class="number">10000000</span>; <span class="comment">%生成的随机数组数</span></span><br><span class="line">x1=unifrnd(<span class="number">0</span>,<span class="number">16</span>,n,<span class="number">1</span>);  <span class="comment">% 生成在[0,16]之间均匀分布的随机数组成的n行1列的向量构成x1</span></span><br><span class="line">x2=unifrnd(<span class="number">0</span>,<span class="number">8</span>,n,<span class="number">1</span>);  <span class="comment">% 生成在[0,8]之间均匀分布的随机数组成的n行1列的向量构成x2</span></span><br><span class="line">fmin=+<span class="built_in">inf</span>; <span class="comment">% 初始化函数f的最小值为正无穷（后续只要找到一个比它小的我们就对其更新）</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:n</span><br><span class="line">    x = [x1(<span class="built_in">i</span>), x2(<span class="built_in">i</span>)];  <span class="comment">%构造x向量, 这里千万别写成了：x =[x1, x2]</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">3</span>*x(<span class="number">1</span>)+x(<span class="number">2</span>)&gt;<span class="number">9</span>)  &amp;  (x(<span class="number">1</span>)+<span class="number">2</span>*x(<span class="number">2</span>)&lt;<span class="number">16</span>)     <span class="comment">% 判断是否满足条件</span></span><br><span class="line">        result = <span class="number">2</span>*(x(<span class="number">1</span>)^<span class="number">2</span>)+x(<span class="number">2</span>)^<span class="number">2</span>-x(<span class="number">1</span>)*x(<span class="number">2</span>)<span class="number">-8</span>*x(<span class="number">1</span>)<span class="number">-3</span>*x(<span class="number">2</span>);  <span class="comment">% 如果满足条件就计算函数值</span></span><br><span class="line">        <span class="keyword">if</span>  result  &lt; fmin  <span class="comment">% 如果这个函数值小于我们之前计算出来的最小值</span></span><br><span class="line">            fmin = result;  <span class="comment">% 那么就更新这个函数值为新的最小值</span></span><br><span class="line">            X = x;  <span class="comment">% 并且将此时的x1 x2 保存到相应的变量中</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">disp</span>(strcat(<span class="string">'蒙特卡罗模拟得到的最小值为'</span>,num2str(fmin)))</span><br><span class="line"><span class="built_in">disp</span>(<span class="string">'最小值处x1 x2的取值为：'</span>)</span><br><span class="line"><span class="built_in">disp</span>(X)</span><br><span class="line">toc <span class="comment">%计算tic和toc中间部分的代码的运行时间</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%% （2）缩小范围重新模拟得到更加精确的取值</span></span><br><span class="line">clc,clear;</span><br><span class="line">tic <span class="comment">%计算tic和toc中间部分的代码的运行时间</span></span><br><span class="line">n=<span class="number">10000000</span>; <span class="comment">%生成的随机数组数</span></span><br><span class="line">x1=unifrnd(<span class="number">2</span>,<span class="number">3</span>,n,<span class="number">1</span>);  <span class="comment">% 生成在[2,3]之间均匀分布的随机数组成的n行1列的向量构成x1</span></span><br><span class="line">x2=unifrnd(<span class="number">2</span>,<span class="number">3</span>,n,<span class="number">1</span>);  <span class="comment">% 生成在[2,3]之间均匀分布的随机数组成的n行1列的向量构成x2</span></span><br><span class="line">fmin=+<span class="built_in">inf</span>; <span class="comment">% 初始化函数f的最小值为正无穷（后续只要找到一个比它小的我们就对其更新）</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:n</span><br><span class="line">    x = [x1(<span class="built_in">i</span>), x2(<span class="built_in">i</span>)];  <span class="comment">%构造x向量, 这里千万别写成了：x =[x1, x2]</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">3</span>*x(<span class="number">1</span>)+x(<span class="number">2</span>)&gt;<span class="number">9</span>)  &amp;  (x(<span class="number">1</span>)+<span class="number">2</span>*x(<span class="number">2</span>)&lt;<span class="number">16</span>)     <span class="comment">% 判断是否满足条件</span></span><br><span class="line">        result = <span class="number">2</span>*(x(<span class="number">1</span>)^<span class="number">2</span>)+x(<span class="number">2</span>)^<span class="number">2</span>-x(<span class="number">1</span>)*x(<span class="number">2</span>)<span class="number">-8</span>*x(<span class="number">1</span>)<span class="number">-3</span>*x(<span class="number">2</span>);  <span class="comment">% 如果满足条件就计算函数值</span></span><br><span class="line">        <span class="keyword">if</span>  result  &lt; fmin  <span class="comment">% 如果这个函数值小于我们之前计算出来的最小值</span></span><br><span class="line">            fmin = result;  <span class="comment">% 那么就更新这个函数值为新的最小值</span></span><br><span class="line">            X = x;  <span class="comment">% 并且将此时的x1 x2 保存到相应的变量中</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">disp</span>(strcat(<span class="string">'蒙特卡罗模拟得到的最小值为'</span>,num2str(fmin)))</span><br><span class="line"><span class="built_in">disp</span>(<span class="string">'最小值处x1 x2的取值为：'</span>)</span><br><span class="line"><span class="built_in">disp</span>(X)</span><br><span class="line">toc <span class="comment">%计算tic和toc中间部分的代码的运行时间</span></span><br></pre></td></tr></table></figure><h2 id="作业2"><a href="#作业2" class="headerlink" title="作业2"></a>作业2</h2><p>​       某设备上安装有四只型号规格完全相同的电子管，已知电子管寿命（假定为整数）为1000h~2000h之间的均匀分布.当电子管损坏时有两种维修方案，一是每次更换损坏的那一只；二是当其中一只损坏时四只同时更换.已知更换时间为换一只时需1h，4只同时换为2h.更换时机器因停止运转每小时的损失为20元，又每只电子管价格10元，试用模拟方法决定哪一个方案经济合理？</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% 选择决策方案的模拟</span></span><br><span class="line"><span class="comment">% 某设备上安装有四只型号规格完全相同的电子管，已知电子管寿命为1000--2000小时之间的均匀分布(假定为整数)。</span></span><br><span class="line"><span class="comment">% 当电子管损坏时有两种维修方案，一是每次更换损坏的那一只；二是当其中一只损坏时四只同时更换。</span></span><br><span class="line"><span class="comment">% 已知更换时间为换一只时需1小时，4只同时换为2小时。</span></span><br><span class="line"><span class="comment">% 更换时机器因停止运转每小时的损失为20元，又每只电子管价格10元，</span></span><br><span class="line"><span class="comment">% 试用模拟方法决定哪一个方案经济合理？</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% （1）预备知识</span></span><br><span class="line"><span class="comment">% randi([a,b],m,n)  随机生成m*n的矩阵，矩阵中的每个元素都是[a,b]中的随机整数</span></span><br><span class="line">randi([<span class="number">1</span>, <span class="number">5</span>],<span class="number">3</span>,<span class="number">2</span>)</span><br><span class="line">randi([<span class="number">1</span>, <span class="number">5</span>])  <span class="comment">% 不写m*n代表只生成1个随机数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% find函数的用法</span></span><br><span class="line"><span class="comment">% find函数的用法在第一期视频：层次分析法那一节讲过，我们当时找最大特征值的位置</span></span><br><span class="line">a = [<span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">1</span> <span class="number">7</span> <span class="number">5</span>];</span><br><span class="line"><span class="built_in">find</span>(a)  <span class="comment">% 找到a中所有非0元素的位置</span></span><br><span class="line"><span class="built_in">find</span>(a == <span class="number">5</span>)  <span class="comment">% 找到a中等于5的元素的位置</span></span><br><span class="line"><span class="built_in">find</span>(a == <span class="number">5</span>,<span class="number">1</span>)  <span class="comment">% 找到a中第一个等于5的元素的位置</span></span><br><span class="line"><span class="built_in">find</span>(a == <span class="built_in">min</span>(a))   <span class="comment">% 找到a中最小元素的位置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% （2）代码部分</span></span><br><span class="line">clear;clc</span><br><span class="line">T = <span class="number">100000000</span>;   <span class="comment">% T表示模拟的总时间（单位为小时）</span></span><br><span class="line">t = <span class="number">0</span>;   <span class="comment">% 初始化当前时刻为0小时</span></span><br><span class="line">c1 = <span class="number">0</span>; c2 = <span class="number">0</span>;  <span class="comment">% 初始化两种方案的总花费都为0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%%  方案一</span></span><br><span class="line">life = randi([<span class="number">1000</span>,<span class="number">2000</span>],<span class="number">1</span>,<span class="number">4</span>);  <span class="comment">% 随机生成四个电子管的寿命，假设为整数</span></span><br><span class="line"><span class="keyword">while</span> t &lt; T  <span class="comment">% 只要现在的时刻没有超过总时刻，就不断循环下去</span></span><br><span class="line">    result = <span class="built_in">min</span>(life);  <span class="comment">% 找出寿命最短的那一个电子管的寿命</span></span><br><span class="line">    t = t+result+<span class="number">1</span>;  <span class="comment">% 现在的时间更改到有电子管损坏的时刻（加上1表示更换电子管需要花费的时间）</span></span><br><span class="line">    c1 = c1 + <span class="number">20</span> * <span class="number">1</span> +<span class="number">10</span>;  <span class="comment">% 更新方案一的花费 </span></span><br><span class="line">    k = <span class="built_in">find</span>(life == result,<span class="number">1</span>);   <span class="comment">% 找到哪一个电子管是坏的</span></span><br><span class="line">    life = life - result <span class="number">-1</span>; <span class="comment">% 更新所有电子管的寿命    </span></span><br><span class="line">    life(k) = randi([<span class="number">1000</span>,<span class="number">2000</span>]);  <span class="comment">% 把坏掉的那个电子管的寿命重置</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%%  方案二</span></span><br><span class="line">t = <span class="number">0</span>;   <span class="comment">% 初始化当前时刻为0小时</span></span><br><span class="line"><span class="keyword">while</span> t &lt; T  <span class="comment">% 只要现在的时刻没有超过总时刻，就不断循环下去</span></span><br><span class="line">    life = randi([<span class="number">1000</span>,<span class="number">2000</span>],<span class="number">1</span>,<span class="number">4</span>); <span class="comment">% 随机生成四个电子管的寿命，假设为整数</span></span><br><span class="line">    result = <span class="built_in">min</span>(life); <span class="comment">% 找出寿命最小的那一个电子管的寿命</span></span><br><span class="line">    t = t+result+<span class="number">2</span>;  <span class="comment">% 现在的时间更改到有电子管损坏的时刻（加上2表示更换所有电子管需要花费的时间）</span></span><br><span class="line">    c2 =c2 + <span class="number">20</span> * <span class="number">2</span> +<span class="number">40</span>;  <span class="comment">% 更新方案二的花费 </span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 两种方案的花费</span></span><br><span class="line">c1</span><br><span class="line">c2</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MATLAB </tag>
            
            <tag> 蒙特卡罗模拟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络系统集成--概述</title>
      <link href="/2020/02/27/%E7%BD%91%E7%BB%9C%E7%B3%BB%E7%BB%9F%E9%9B%86%E6%88%90--%E6%A6%82%E8%BF%B0/"/>
      <url>/2020/02/27/%E7%BD%91%E7%BB%9C%E7%B3%BB%E7%BB%9F%E9%9B%86%E6%88%90--%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><a id="more"></a><p>美国信息技术协会（ITAA）对系统集成的定义：</p><p>  <strong>根据一个复杂的信息系统或子系统的要求，验明多种技术和产品，并建立一个完整的解决方案的过程。</strong></p><p>信息系统=网络系统+硬件系统+软件系统</p><ul><li>硬件设备：不同产品的接口兼容性。</li><li>软件产品：不同软件之间数据格式的转换。</li><li>网络系统：不同系统之间信号交换和路由。</li></ul><p>机房建设：制冷，距离，存储</p>]]></content>
      
      
      <categories>
          
          <category> 网络系统集成 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数学规划模型——多目标规划问题</title>
      <link href="/2020/02/27/%E6%95%B0%E5%AD%A6%E8%A7%84%E5%88%92%E6%A8%A1%E5%9E%8B%E2%80%94%E2%80%94%E5%A4%9A%E7%9B%AE%E6%A0%87%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98/"/>
      <url>/2020/02/27/%E6%95%B0%E5%AD%A6%E8%A7%84%E5%88%92%E6%A8%A1%E5%9E%8B%E2%80%94%E2%80%94%E5%A4%9A%E7%9B%AE%E6%A0%87%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="求解思路"><a href="#求解思路" class="headerlink" title="求解思路"></a>求解思路</h1><a id="more"></a><p>​        若⼀个规划问题中有多个⽬标, 例如企业在保证利润最大时也要保证⽣产时产⽣的污染最少这种情况下我们可以对多⽬标函数进⾏加权组合, 使问题变为单⽬标规划 , 然后再利⽤之前学的知识进⾏求解。</p><p>注意</p><ol><li>要先将多个⽬标函数统⼀为最大化或最小化问题后才可以进行加权组合 </li><li>如果⽬标函数的量纲不相同 , 则需要对其进⾏标准化 后再进行加权, 标准化的方法⼀般 是用目标函数 除以某⼀个常量 , 该常量是这个⽬标函数的某个取值, 具体取何值可根据经验确定 </li><li>对多⽬标函数进⾏加权求和时, 权重需要由该问题领域的专家给定 , 在实际建模⽐赛中, 若⽆特殊说明,我们拎权重相同。</li></ol><h1 id="典型例题"><a href="#典型例题" class="headerlink" title="典型例题"></a>典型例题</h1><p>​     【例题】某化工厂今年拟生产两种新产品A和B，其生产费用分别为2万元/吨和5万元/吨。这两种产品均将造成环境污染，每生产一吨A产品会产生0.4吨的污染，每生产一吨B产品会产生0.3吨的污染。由于条件限制，工厂生产产品A和B的最大生产能力各为每月5吨和6吨，而市场需要这两种产品的总量每月不少于7吨。该工厂决策认为，这两个目标中环境污染应优先考虑，且根据经验生产费用的参考值为30万元，污染量参考值为2吨。试问工厂如何安排生产计划，在满足市场需要的前提下，使设备的花费和产生的污染均达最小。</p><p>​       解：设工厂每月生产产品$Ax_{1}$吨，$Bx_{2}$吨，那么产生的污染分别为$0.4x_{1}$吨和$0.3x_{2}$吨。问题的数学模型表达为多目标规划问题：<br>$$<br>\left{\begin{array}{l}<br>\min f_{1}=2 x_{1}+5 x_{2} \<br>\min f_{2}=0.4 x_{1}+0.3 x_{2} \<br>\text { st. }\left{\begin{array}{l}<br>x_{1}+x_{2} \geq 7 \<br>0 \leq x_{1} \leq 5 \<br>0 \leq x_{2} \leq 6<br>\end{array}\right.<br>\end{array}\right.<br>$$<br>​       下面我们将其转换为一个单目标规划问题，即对上面的两个目标函数进行加权。由于该工厂决策认为环境污染应优先考虑，因此我们可以选取$f_{1}$和$f_{2}$的权重分别为0.4和0.6。注意到两个目标函数的单位不同，一个为“万元”，一个为“吨”，因此我们需要首先对目标函数进行标准化来消除量纲的影响，然后再进行加权。由于题目中已经给了产品费用和污染量的参考值，因此我们将这两个目标函数分别除以其参考值来消除量纲。<br>那么加权组合后的目标函数：<br>$$<br>f=0.4 \times \frac{f_{1}}{30}+0.6 \times \frac{f_{2}}{2}=\frac{0.4}{30} \times\left(2 x_{1}+5 x_{2}\right)+\frac{0.6}{2} \times\left(0.4 x_{1}+0.3 x_{2}\right)<br>$$<br>那么我们就得到了一个单目标规划问题，利用Matlab求解可以得到：<br>$$<br>x_{1}=5,x_{2}=2,f_{1}=20,f_{2}=2.6<br>$$<br>​       下面我们对结果进行敏感性分析，<strong>敏感性分析</strong>是指从定量分析的角度研究有关因素发生某种变化对某一个或一组关键指标影响程度的一种不确定分析技术。<strong>其实质是通过逐一改变相关变量数值的方法来解释关键指标受这些因素变动影响大小的规律。</strong><br>下面我们改变$f_{1}$和$f_{2}$的危的权重，来观察对结果的影响。（由于两个权重和为1，因此我们只需要改变$f_{1}$的权重即可），下面是图形：</p><p><img src="https://gitee.com/pxlsdz/blogImage/raw/master/img/2020-030-1.png" alt=""></p><p><img src="https://gitee.com/pxlsdz/blogImage/raw/master/img/2020.png" alt=""></p><p><img src="https://gitee.com/pxlsdz/blogImage/raw/master/img/599856.png" alt="">       </p><p>​        可以看出，f的权重的转折点在0.333-0.334之间，当f1的权重小于这个转折点时，x1=1，x2=6，大于转折点时，x1=5，x2=2。其主要原因是：当f1的权重越小时，厂家对环境污染的权重就越大，那么厂家就更加倾向于生产污染较少的产品B，尽管B的生产费用要远高于产品A。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%%  多目标规划问题</span></span><br><span class="line">w1 = <span class="number">0.4</span>;  w2 = <span class="number">0.6</span>;  <span class="comment">% 两个目标函数的权重  x1 = 5  x2 = 2</span></span><br><span class="line">w1 = <span class="number">0.5</span>;  w2 = <span class="number">0.5</span>;  <span class="comment">% 两个目标函数的权重  x1 = 5  x2 = 2</span></span><br><span class="line">w1 = <span class="number">0.3</span>;  w2 = <span class="number">0.7</span>;  <span class="comment">% 两个目标函数的权重  x1 = 1  x2 = 6</span></span><br><span class="line">c = [w1/<span class="number">30</span>*<span class="number">2</span>+w2/<span class="number">2</span>*<span class="number">0.4</span> ;w1/<span class="number">30</span>*<span class="number">5</span>+w2/<span class="number">2</span>*<span class="number">0.3</span>];  <span class="comment">% 线性规划目标函数的系数</span></span><br><span class="line">A = [<span class="number">-1</span> <span class="number">-1</span>];  b = <span class="number">-7</span>; <span class="comment">% 不等式约束</span></span><br><span class="line">lb = [<span class="number">0</span> <span class="number">0</span>]'; ub = [<span class="number">5</span> <span class="number">6</span>]'; <span class="comment">% 上下界</span></span><br><span class="line">[x,fval] = linprog(c,A,b,[],[],lb,ub)</span><br><span class="line">f1 = <span class="number">2</span>*x(<span class="number">1</span>)+<span class="number">5</span>*x(<span class="number">2</span>)</span><br><span class="line">f2 = <span class="number">0.4</span>*x(<span class="number">1</span>) + <span class="number">0.3</span>*x(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 敏感性分析</span></span><br><span class="line">clear;clc</span><br><span class="line">W1 = <span class="number">0.1</span>:<span class="number">0.001</span>:<span class="number">0.5</span>;  W2 = <span class="number">1</span>- W1;  </span><br><span class="line">n =<span class="built_in">length</span>(W1);</span><br><span class="line">F1 = <span class="built_in">zeros</span>(n,<span class="number">1</span>);  F2 = <span class="built_in">zeros</span>(n,<span class="number">1</span>);   X1 = <span class="built_in">zeros</span>(n,<span class="number">1</span>);  X2 = <span class="built_in">zeros</span>(n,<span class="number">1</span>);   FVAL = <span class="built_in">zeros</span>(n,<span class="number">1</span>);</span><br><span class="line">A = [<span class="number">-1</span> <span class="number">-1</span>];  b = <span class="number">-7</span>; <span class="comment">% 不等式约束</span></span><br><span class="line">lb = [<span class="number">0</span> <span class="number">0</span>]; ub = [<span class="number">5</span> <span class="number">6</span>]; <span class="comment">% 上下界</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:n</span><br><span class="line">    w1 = W1(<span class="built_in">i</span>);  w2 = W2(<span class="built_in">i</span>);</span><br><span class="line">    c = [w1/<span class="number">30</span>*<span class="number">2</span>+w2/<span class="number">2</span>*<span class="number">0.4</span> ;w1/<span class="number">30</span>*<span class="number">5</span>+w2/<span class="number">2</span>*<span class="number">0.3</span>];  <span class="comment">% 线性规划目标函数的系数</span></span><br><span class="line">    [x,fval] = linprog(c,A,b,[],[],lb,ub);</span><br><span class="line">    F1(<span class="built_in">i</span>) = <span class="number">2</span>*x(<span class="number">1</span>)+<span class="number">5</span>*x(<span class="number">2</span>);</span><br><span class="line">    F2(<span class="built_in">i</span>) = <span class="number">0.4</span>*x(<span class="number">1</span>) + <span class="number">0.3</span>*x(<span class="number">2</span>);</span><br><span class="line">    X1(<span class="built_in">i</span>) = x(<span class="number">1</span>);</span><br><span class="line">    X2(<span class="built_in">i</span>) = x(<span class="number">2</span>);</span><br><span class="line">    FVAL(<span class="built_in">i</span>) = fval;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 「Matlab」“LaTex字符汇总”讲解：https://blog.csdn.net/Robot_Starscream/article/details/89386748</span></span><br><span class="line"><span class="comment">% 在图上可以加上数据游标，按住Alt加鼠标左键可以设置多个数据游标出来。</span></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">1</span>) </span><br><span class="line"><span class="built_in">plot</span>(W1,F1,W1,F2)</span><br><span class="line">xlabel(<span class="string">'f_&#123;1&#125;的权重'</span>) </span><br><span class="line">ylabel(<span class="string">'f_&#123;1&#125;和f_&#123;2&#125;的取值'</span>)</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">'f_&#123;1&#125;'</span>,<span class="string">'f_&#123;2&#125;'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">plot</span>(W1,X1,W1,X2)</span><br><span class="line">xlabel(<span class="string">'f_&#123;1&#125;的权重'</span>) </span><br><span class="line">ylabel(<span class="string">'x_&#123;1&#125;和x_&#123;2&#125;的取值'</span>)</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">'x_&#123;1&#125;'</span>,<span class="string">'x_&#123;2&#125;'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">plot</span>(W1,FVAL)  <span class="comment">% 看起来是两个直线组合起来的下半部分</span></span><br><span class="line">xlabel(<span class="string">'f_&#123;1&#125;的权重'</span>) </span><br><span class="line">ylabel(<span class="string">'综合指标的值'</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MATLAB </tag>
            
            <tag> 数学规划模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数学规划模型——整数规划问题</title>
      <link href="/2020/02/27/%E6%95%B0%E5%AD%A6%E8%A7%84%E5%88%92%E6%A8%A1%E5%9E%8B%E2%80%94%E2%80%94%E6%95%B4%E6%95%B0%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98/"/>
      <url>/2020/02/27/%E6%95%B0%E5%AD%A6%E8%A7%84%E5%88%92%E6%A8%A1%E5%9E%8B%E2%80%94%E2%80%94%E6%95%B4%E6%95%B0%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="整数规划"><a href="#整数规划" class="headerlink" title="整数规划"></a>整数规划</h1><a id="more"></a><p>整数规划：</p><ol><li><p>线性整数规划 - Matlab可进⾏求解 （线性的意思 在线性规划的基础上 , 加⼊决策变量取整数的条件) </p></li><li><p>⾮线性整数规划 → ⽆特定算法, 只能⽤近似算法 , 如蒙特卡罗模拟 、 智能算法 ( 后续会讲到) </p></li></ol><p>特例： 特殊的整数规划 , Matlab中也只能求解线性01规划, 对于⾮线性 0-1规划也只能近似求解 。 (数模⽐赛中常出现) </p><h1 id="Matlab整数规划求解"><a href="#Matlab整数规划求解" class="headerlink" title="Matlab整数规划求解"></a>Matlab整数规划求解</h1><h2 id="线性整数规划求解"><a href="#线性整数规划求解" class="headerlink" title="线性整数规划求解"></a>线性整数规划求解</h2><p>[x ,fval] = linprog [ c, A, b,  Aeq, beq, lb, ub, <strong>X0</strong>] -&gt; 线性规划的函数 </p><p>[x ,fval] = intlinprog [ c, <strong>intcon</strong>A, b,  Aeq, beq, lb, ub]→ 线性整数规划的求解 </p><p>注 : </p><ol><li>intlinpng 不能指定初始值 ; </li><li>加⼊了 inton 参数可以指定哪些决策变量是整数。 </li></ol><p>例如决策变量有三个 : x1,x2,x3 ; 若x1和x3,是整数 , 则 intcon= [1 , 3] 。</p><h2 id="线性-0-1规划求解"><a href="#线性-0-1规划求解" class="headerlink" title="线性 0-1规划求解"></a>线性 0-1规划求解</h2><p>仍然使⽤intlinprog 函数 , 只不过在 lb和ub上作⽂章 。 </p><p>例如决策变量有三个 : x1,x2,x3 ; 若x1和x3是0-1变量，x2不限制, 则 intcon= [1 , 3] ，lb=[0 -inf 0]’,ub=[1,+inf,1]。</p><h1 id="小例题"><a href="#小例题" class="headerlink" title="小例题"></a>小例题</h1><p><img src="https://gitee.com/pxlsdz/blogImage/raw/master/img/6.png" alt=""></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% 线性整数规划问题</span></span><br><span class="line"><span class="comment">%% 例1</span></span><br><span class="line">c=[<span class="number">-20</span>,<span class="number">-10</span>]';</span><br><span class="line">intcon=[<span class="number">1</span>,<span class="number">2</span>];  <span class="comment">% x1和x2限定为整数</span></span><br><span class="line">A=[<span class="number">5</span>,<span class="number">4</span>;</span><br><span class="line">      <span class="number">2</span>,<span class="number">5</span>];</span><br><span class="line">b=[<span class="number">24</span>;<span class="number">13</span>];</span><br><span class="line">lb=<span class="built_in">zeros</span>(<span class="number">2</span>,<span class="number">1</span>);  </span><br><span class="line">[x,fval]=intlinprog(c,intcon,A,b,[],[],lb)</span><br><span class="line">fval = -fval</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 例2</span></span><br><span class="line">c=[<span class="number">18</span>,<span class="number">23</span>,<span class="number">5</span>]';</span><br><span class="line">intcon=<span class="number">3</span>;  <span class="comment">% x3限定为整数</span></span><br><span class="line">A=[<span class="number">107</span>,<span class="number">500</span>,<span class="number">0</span>;</span><br><span class="line">      <span class="number">72</span>,<span class="number">121</span>,<span class="number">65</span>;</span><br><span class="line">      <span class="number">-107</span>,<span class="number">-500</span>,<span class="number">0</span>;</span><br><span class="line">      <span class="number">-72</span>,<span class="number">-121</span>,<span class="number">-65</span>];</span><br><span class="line">b=[<span class="number">50000</span>;<span class="number">2250</span>;<span class="number">-500</span>;<span class="number">-2000</span>];</span><br><span class="line">lb=<span class="built_in">zeros</span>(<span class="number">3</span>,<span class="number">1</span>);</span><br><span class="line">[x,fval]=intlinprog(c,intcon,A,b,[],[],lb)</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 例3</span></span><br><span class="line">c=[<span class="number">-3</span>;<span class="number">-2</span>;<span class="number">-1</span>]; intcon=<span class="number">3</span>; <span class="comment">% x3限定为整数</span></span><br><span class="line">A=<span class="built_in">ones</span>(<span class="number">1</span>,<span class="number">3</span>); b=<span class="number">7</span>;</span><br><span class="line">Aeq=[<span class="number">4</span> <span class="number">2</span> <span class="number">1</span>]; beq=<span class="number">12</span>;</span><br><span class="line">lb=<span class="built_in">zeros</span>(<span class="number">3</span>,<span class="number">1</span>); ub=[+<span class="built_in">inf</span>;+<span class="built_in">inf</span>;<span class="number">1</span>]; <span class="comment">%x(3)为0-1变量</span></span><br><span class="line">[x,fval]=intlinprog(c,intcon,A,b,Aeq,beq,lb,ub)</span><br></pre></td></tr></table></figure><h1 id="整数规划的典型例题"><a href="#整数规划的典型例题" class="headerlink" title="整数规划的典型例题"></a>整数规划的典型例题</h1><h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><p><img src="https://gitee.com/pxlsdz/blogImage/raw/master/img/7.png" alt=""></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% 背包问题（货车运送货物的问题）</span></span><br><span class="line">c = -[<span class="number">540</span> <span class="number">200</span> <span class="number">180</span> <span class="number">350</span> <span class="number">60</span> <span class="number">150</span> <span class="number">280</span> <span class="number">450</span> <span class="number">320</span> <span class="number">120</span>];  <span class="comment">% 目标函数的系数矩阵(最大化问题记得加负号)</span></span><br><span class="line">intcon=[<span class="number">1</span>:<span class="number">10</span>];  <span class="comment">% 整数变量的位置(一共10个决策变量，均为0-1整数变量)</span></span><br><span class="line">A = [<span class="number">6</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">4</span> <span class="number">2</span>];  b = <span class="number">30</span>;   <span class="comment">% 线性不等式约束的系数矩阵和常数项向量（物品的重量不能超过30）</span></span><br><span class="line">Aeq = []; beq =[];  <span class="comment">% 不存在线性等式约束</span></span><br><span class="line">lb = <span class="built_in">zeros</span>(<span class="number">10</span>,<span class="number">1</span>);  <span class="comment">% 约束变量的范围下限</span></span><br><span class="line">ub = <span class="built_in">ones</span>(<span class="number">10</span>,<span class="number">1</span>);  <span class="comment">% 约束变量的范围上限</span></span><br><span class="line"><span class="comment">%最后调用intlinprog()函数</span></span><br><span class="line">[x,fval]=intlinprog(c,intcon,A,b,Aeq,beq,lb,ub)</span><br><span class="line">fval = -fval</span><br></pre></td></tr></table></figure><h2 id="指派问题"><a href="#指派问题" class="headerlink" title="指派问题"></a>指派问题</h2><p><img src="https://gitee.com/pxlsdz/blogImage/raw/master/img/8.png" alt=""></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% 指派问题（选择队员去进行游泳接力比赛）</span></span><br><span class="line">clear;clc</span><br><span class="line">c = [<span class="number">66.8</span> <span class="number">75.6</span> <span class="number">87</span> <span class="number">58.6</span> <span class="number">57.2</span> <span class="number">66</span> <span class="number">66.4</span> <span class="number">53</span> <span class="number">78</span> <span class="number">67.8</span> <span class="number">84.6</span> <span class="number">59.4</span> <span class="number">70</span> <span class="number">74.2</span> <span class="number">69.6</span> <span class="number">57.2</span> <span class="number">67.4</span> <span class="number">71</span> <span class="number">83.8</span> <span class="number">62.4</span>]';  <span class="comment">% 目标函数的系数矩阵（先列后行的写法）</span></span><br><span class="line">intcon = [<span class="number">1</span>:<span class="number">20</span>];  <span class="comment">% 整数变量的位置(一共20个决策变量，均为0-1整数变量)</span></span><br><span class="line"><span class="comment">% 线性不等式约束的系数矩阵和常数项向量（每个人只能入选四种泳姿之一，一共五个约束）</span></span><br><span class="line">A = [<span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">       <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">       <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">       <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">       <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span>];</span><br><span class="line"><span class="comment">% A = zeros(5,20);</span></span><br><span class="line"><span class="comment">% for i = 1:5</span></span><br><span class="line"><span class="comment">%     A(i, (4*i-3): 4*i) = 1;</span></span><br><span class="line"><span class="comment">% end</span></span><br><span class="line">b = [<span class="number">1</span>;<span class="number">1</span>;<span class="number">1</span>;<span class="number">1</span>;<span class="number">1</span>];</span><br><span class="line"><span class="comment">% 线性等式约束的系数矩阵和常数项向量 （每种泳姿有且仅有一人参加，一共四个约束）</span></span><br><span class="line">Aeq = [<span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">          <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">          <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span>;</span><br><span class="line">          <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span>];</span><br><span class="line"><span class="comment">% Aeq = [eye(4),eye(4),eye(4),eye(4),eye(4)];  % 或者写成 repmat(eye(4),1,5) </span></span><br><span class="line"><span class="comment">% Aeq=zeros(4,20);</span></span><br><span class="line"><span class="comment">% for i = 1:4</span></span><br><span class="line"><span class="comment">%     for j =1:20</span></span><br><span class="line"><span class="comment">%         if mod(j,4)==i</span></span><br><span class="line"><span class="comment">%             Aeq(i,j)=1;</span></span><br><span class="line"><span class="comment">%         end</span></span><br><span class="line"><span class="comment">%         if i==4</span></span><br><span class="line"><span class="comment">%             if mod(j,4)==0</span></span><br><span class="line"><span class="comment">%                 Aeq(i,j)=1;</span></span><br><span class="line"><span class="comment">%             end</span></span><br><span class="line"><span class="comment">%         end</span></span><br><span class="line"><span class="comment">%     end</span></span><br><span class="line"><span class="comment">% end  </span></span><br><span class="line"></span><br><span class="line">beq = [<span class="number">1</span>;<span class="number">1</span>;<span class="number">1</span>;<span class="number">1</span>];</span><br><span class="line">lb = <span class="built_in">zeros</span>(<span class="number">20</span>,<span class="number">1</span>);  <span class="comment">% 约束变量的范围下限</span></span><br><span class="line">ub = <span class="built_in">ones</span>(<span class="number">20</span>,<span class="number">1</span>);  <span class="comment">% 约束变量的范围上限</span></span><br><span class="line"><span class="comment">%最后调用intlinprog()函数</span></span><br><span class="line">[x,fval] = intlinprog(c,intcon,A,b,Aeq,beq,lb,ub)</span><br><span class="line"><span class="comment">% reshape(x,4,5)'</span></span><br><span class="line"><span class="comment">%      0     0     0     1    甲自由泳</span></span><br><span class="line"><span class="comment">%      1     0     0     0    乙蝶泳</span></span><br><span class="line"><span class="comment">%      0     1     0     0    丙仰泳</span></span><br><span class="line"><span class="comment">%      0     0     1     0    丁蛙泳</span></span><br><span class="line"><span class="comment">%      0     0     0     0    戊不参加</span></span><br></pre></td></tr></table></figure><h2 id="钢管切割问题"><a href="#钢管切割问题" class="headerlink" title="钢管切割问题"></a>钢管切割问题</h2><p><img src="https://gitee.com/pxlsdz/blogImage/raw/master/img/20200227164012.png" alt=""></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% 钢管切割问题</span></span><br><span class="line"><span class="comment">%% (1)枚举法找出同一个原材料上所有的切割方法</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">0</span>: <span class="number">2</span>  <span class="comment">% 2.9m长的圆钢的数量</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">0</span>: <span class="number">3</span>  <span class="comment">% 2.1m长的圆钢的数量</span></span><br><span class="line">        <span class="keyword">for</span> k = <span class="number">0</span>:<span class="number">6</span>   <span class="comment">% 1m长的圆钢的数量</span></span><br><span class="line">            <span class="keyword">if</span> <span class="number">2.9</span>*<span class="built_in">i</span>+<span class="number">2.1</span>*<span class="built_in">j</span>+<span class="number">1</span>*k &gt;= <span class="number">6</span> &amp; <span class="number">2.9</span>*<span class="built_in">i</span>+<span class="number">2.1</span>*<span class="built_in">j</span>+<span class="number">1</span>*k &lt;= <span class="number">6.9</span></span><br><span class="line">                <span class="built_in">disp</span>([<span class="built_in">i</span>, <span class="built_in">j</span>, k])</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% (2) 线性整数规划问题的求解</span></span><br><span class="line">c = <span class="built_in">ones</span>(<span class="number">7</span>,<span class="number">1</span>);  <span class="comment">% 目标函数的系数矩阵</span></span><br><span class="line">intcon=[<span class="number">1</span>:<span class="number">7</span>];  <span class="comment">%  整数变量的位置(一共7个决策变量，均为整数变量)</span></span><br><span class="line">A = -[<span class="number">1</span> <span class="number">2</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span>;  </span><br><span class="line">         <span class="number">0</span> <span class="number">0</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span>;</span><br><span class="line">         <span class="number">4</span> <span class="number">1</span> <span class="number">0</span> <span class="number">2</span> <span class="number">4</span> <span class="number">6</span> <span class="number">1</span>];  <span class="comment">% 线性不等式约束的系数矩阵</span></span><br><span class="line">b = -[<span class="number">100</span> <span class="number">100</span> <span class="number">100</span>]'; <span class="comment">%  线性不等式约束的常数项向量</span></span><br><span class="line">lb = <span class="built_in">zeros</span>(<span class="number">7</span>,<span class="number">1</span>); <span class="comment">% 约束变量的范围下限</span></span><br><span class="line">[x,fval]=intlinprog(c,intcon,A,b,[],[],lb)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MATLAB </tag>
            
            <tag> 数学规划模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数学规划模型——非线性规划问题</title>
      <link href="/2020/02/26/%E6%95%B0%E5%AD%A6%E8%A7%84%E5%88%92%E6%A8%A1%E5%9E%8B%E2%80%94%E2%80%94%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98/"/>
      <url>/2020/02/26/%E6%95%B0%E5%AD%A6%E8%A7%84%E5%88%92%E6%A8%A1%E5%9E%8B%E2%80%94%E2%80%94%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="Matlab-中⾮线性规划的标准型"><a href="#Matlab-中⾮线性规划的标准型" class="headerlink" title="Matlab 中⾮线性规划的标准型"></a>Matlab 中⾮线性规划的标准型</h1><a id="more"></a><p>$$<br>min \ f(x) \<br>\ \<br>s.t. \ \begin{cases}<br> &amp; \text{} AX&lt;=b,Aeq*x=beq \quad 线性约束\<br> &amp; \text{} c(x)&lt;=0,ceg(x)=0\quad 非线性约束 \<br> &amp; \text{}lb&lt;=x&lt;=ub \quad 上下界约束(也可以当成不等式约束)<br>\end{cases}<br>$$</p><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><p><img src="https://gitee.com/pxlsdz/blogImage/raw/master/img/20200227170054.png" alt=""></p><h1 id="Matlab求解⾮线性规划的函数"><a href="#Matlab求解⾮线性规划的函数" class="headerlink" title="Matlab求解⾮线性规划的函数"></a>Matlab求解⾮线性规划的函数</h1><p>[x,fval] = fmincon(@fun,x0,A,b,Aeq,beq,lb,ub,@nonlfun,option)</p><ol><li><p>⾮线性规划中对于初始值 x0 的选取⾮常重要 , 因为⾮线性规划的算法求解出来的 是⼀个局部优解 。 (线性规划不存在这个问题 )</p></li><li><p>如果要求全局优解! 有两种思路 : </p><ul><li>给定不同的初始值 , 在⾥⾯找到⼀个优解 ;</li><li>先⽤蒙特卡罗模拟, 得到⼀个蒙特卡罗解 , 然后将这个解作为初始值来求优解 </li></ul></li><li><p>“option” 选项可以给定求解的算法, ⼀共有四种 :</p><ul><li><p>interior.point (内点法)  </p></li><li><p>sqp(序列⼆次规划法) </p></li><li><p>active.set (有效集法) </p></li><li><p>trust-region.reflective (信赖域 反射算法) 。</p></li></ul></li><li><p>不同的算法有其各⾃的优缺点和适⽤情况 , 我们可以改变求解的算法来看求解的结果是否变好了 。 如何改变求解的算法请参考代码演示 。 (数模⽐赛中可以都尝试 下, 这可以体现出稳健性, 也是你的优点) </p></li><li><p>“@fun” 表示⽬标函数<br>我们要编写⼀个独⽴的 m ⽂件来存⽬标函数 :</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span> = <span class="title">fun</span> <span class="params">( x)</span> </span></span><br><span class="line">    f=...</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><ul><li>注 fun 可以任意取名 ,  只 要符合 Matlab 命名规范 , 保存的m ⽂件 也是这个名 。</li><li>f 也可以任意取名, 但返回的 f 和 函数内部的f得 完全⼀致; </li><li>这⾥的x实际上是表示决策变量的向量 ,其行列方向取决于初始值。 </li><li>调⽤函数 : fmincon(@fun,…) 求解 。</li></ul></li><li><p>“ @nonlfun “ 表示⾮线性部分的约束 , 我们同样得编写⼀个独⽴的 m ⽂件储存非线性约束条件 : </p><p><img src="https://gitee.com/pxlsdz/blogImage/raw/master/img/20200227173858.png" alt=""></p><ul><li>nonlfun 同样可任意取名 , 别和上⾯的fun相同即可, 保存的m文件也得是  这个 名字。 </li><li>c,ceq中可能有多个约束 因此我们写成<strong>列向量</strong>的形式 ;</li><li>若不存在⾮线性不等式约束 , 则可以令 C = [] </li><li>调⽤函数 fmincon(…….,@nonlfun.options) 求解 。 </li></ul></li><li><p>注意要把下标改写为扩号 , 例如$f=x_{1}^2+3x_{2}$名 写成 Matlab 能识别的就应该为 : $f=x(1)^2+3*x(2)$</p></li><li><p>若 不存在某种约束 , 则 可⽤ “ [] “替代 , 若后⾯全为 “[ ] “ 且 不指定option(使⽤默认的求解⽅法) , 则”[]”也可以省略掉 。</p></li></ol><h1 id="练习题代码"><a href="#练习题代码" class="headerlink" title="练习题代码"></a>练习题代码</h1><h2 id="code-m"><a href="#code-m" class="headerlink" title="code.m"></a>code.m</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 非线性规划的函数</span></span><br><span class="line"><span class="comment">% [x,fval] = fmincon(@fun,x0,A,b,Aeq,beq,lb,ub,@nonlfun,option)</span></span><br><span class="line"><span class="comment">% x0表示给定的初始值（用行向量或者列向量表示），必须得写</span></span><br><span class="line"><span class="comment">% A b表示线性不等式约束</span></span><br><span class="line"><span class="comment">% Aeq beq 表示线性等式约束</span></span><br><span class="line"><span class="comment">% lb ub 表示上下界约束</span></span><br><span class="line"><span class="comment">% @fun表示目标函数</span></span><br><span class="line"><span class="comment">% @nonlfun表示非线性约束的函数</span></span><br><span class="line"><span class="comment">% option 表示求解非线性规划使用的方法</span></span><br><span class="line">clear;clc</span><br><span class="line">format long g   <span class="comment">%可以将Matlab的计算结果显示为一般的长数字格式（默认会保留四位小数，或使用科学计数法）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 例题1的求解</span></span><br><span class="line"><span class="comment">% max f(x) = x1^2 +x2^2 -x1*x2 -2x1 -5x2</span></span><br><span class="line"><span class="comment">% s.t. -(x1-1)^2 +x2 &gt;= 0 ;  2x1-3x2+6 &gt;= 0</span></span><br><span class="line">x0 = [<span class="number">0</span> <span class="number">0</span>];  <span class="comment">%任意给定一个初始值 </span></span><br><span class="line">A = [<span class="number">-2</span> <span class="number">3</span>]; b = <span class="number">6</span>;</span><br><span class="line">[x,fval] = fmincon(@fun1,x0,A,b,[],[],[],[],@nonlfun1)  <span class="comment">% 注意 fun1.m文件和nonfun1.m文件都必须在当前文件夹目录下</span></span><br><span class="line">fval = -fval</span><br><span class="line"><span class="comment">% 一个值得讨论的地方，能不能把线性不等式约束Ax &lt;= b也写到nonlfun1函数中？</span></span><br><span class="line"><span class="comment">% 先把nonlfun1中的c改为下面这样：</span></span><br><span class="line"><span class="comment">% c = [(x(1)-1)^2-x(2); </span></span><br><span class="line"><span class="comment">%        -2*x(1)+3*x(2)-6];</span></span><br><span class="line"><span class="comment">%  [x,fval] = fmincon(@fun1,x0,[],[],[],[],[],[],@nonlfun1)</span></span><br><span class="line"><span class="comment">% 结果也是可以计算出来的，但并不推荐这样做~</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 使用其他算法对例题1求解</span></span><br><span class="line"><span class="comment">% edit fmincon  % 查看fmincon的“源代码”</span></span><br><span class="line"><span class="comment">% Matlab2017a默认使用的算法是'interior-point' 内点法</span></span><br><span class="line"><span class="comment">% 使用interior point算法 （内点法）</span></span><br><span class="line">option = optimoptions(<span class="string">'fmincon'</span>,<span class="string">'Algorithm'</span>,<span class="string">'interior-point'</span>)</span><br><span class="line">[x,fval] = fmincon(@fun1,x0,A,b,[],[],[],[],@nonlfun1,option)  </span><br><span class="line">fval = -fval</span><br><span class="line"><span class="comment">% 使用SQP算法 （序列二次规划法）</span></span><br><span class="line">option = optimoptions(<span class="string">'fmincon'</span>,<span class="string">'Algorithm'</span>,<span class="string">'sqp'</span>)</span><br><span class="line">[x,fval] = fmincon(@fun1,x0,A,b,[],[],[],[],@nonlfun1,option)  </span><br><span class="line">fval = -fval   <span class="comment">%得到-4.358，远远大于内点法得到的-1,猜想是初始值的影响</span></span><br><span class="line"><span class="comment">% 改变初始值试试</span></span><br><span class="line">x0 = [<span class="number">1</span> <span class="number">1</span>];  <span class="comment">%任意给定一个初始值 </span></span><br><span class="line">[x,fval] = fmincon(@fun1,x0,A,b,[],[],[],[],@nonlfun1,option)  <span class="comment">% 最小值为-1，和内点法相同（这说明内点法的适应性要好）</span></span><br><span class="line">fval = -fval  </span><br><span class="line"><span class="comment">% 使用active set算法 （有效集法）</span></span><br><span class="line">option = optimoptions(<span class="string">'fmincon'</span>,<span class="string">'Algorithm'</span>,<span class="string">'active-set'</span>)</span><br><span class="line">[x,fval] = fmincon(@fun1,x0,A,b,[],[],[],[],@nonlfun1,option)</span><br><span class="line">fval = -fval  </span><br><span class="line"><span class="comment">% 使用trust region reflective (信赖域反射算法)</span></span><br><span class="line">option = optimoptions(<span class="string">'fmincon'</span>,<span class="string">'Algorithm'</span>,<span class="string">'trust-region-reflective'</span>)</span><br><span class="line">[x,fval] = fmincon(@fun1,x0,A,b,[],[],[],[],@nonlfun1,option)  </span><br><span class="line">fval = -fval  </span><br><span class="line"><span class="comment">% this algorithm does not solve problems with the constraints you have specified. </span></span><br><span class="line"><span class="comment">% 这说明这个算法不适用我们这个约束条件，所以以后遇到了不能求解的情况，记得更换其他算法试试！！！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 选取初始值得到的结果可能会不满足限定条件，出现了一个Bug 因此选择的初始值很重要</span></span><br><span class="line">x0 = [<span class="number">40.8</span>, <span class="number">10.8</span>];</span><br><span class="line">option = optimoptions(<span class="string">'fmincon'</span>,<span class="string">'Algorithm'</span>,<span class="string">'interior-point'</span>)</span><br><span class="line">[x,fval] = fmincon(@fun1,x0,A,b,[],[],[],[],@nonlfun1,option)  </span><br><span class="line">fval = -fval  </span><br><span class="line"><span class="comment">% https://cn.mathworks.com/help/optim/ug/fmincon.html</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 生成不同的随机初始值来优化代码，有一定几率会触发上面那个Bug，因此不推荐</span></span><br><span class="line">n = <span class="number">10</span>;  <span class="comment">% 重复n次</span></span><br><span class="line">Fval = +<span class="built_in">inf</span>; X = [<span class="number">0</span>,<span class="number">0</span>];  <span class="comment">%初始化最优的结果</span></span><br><span class="line">A = [<span class="number">-2</span> <span class="number">3</span>]; b = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:n</span><br><span class="line">    x0 = [<span class="built_in">rand</span>()*<span class="number">10</span> , <span class="built_in">rand</span>()*<span class="number">10</span>];  <span class="comment">%用随机数生成一个初始值（随机数的范围自己根据题目条件设置） </span></span><br><span class="line">    [x,f  al] = fmincon(@fun1,x0,A,b,[],[],[],[],@nonlfun1,option); <span class="comment">% 注意 fun1.m文件和nonfun1.m文件都必须在当前文件夹目录下</span></span><br><span class="line">    <span class="keyword">if</span> fval &lt; Fval  <span class="comment">% 如果找到了更小的值，那么就代替最优的结果</span></span><br><span class="line">        Fval = fval;</span><br><span class="line">        X = x;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">Fval = -Fval</span><br><span class="line">X</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 使用蒙特卡罗的方法来找初始值(推荐）</span></span><br><span class="line">clc,clear;</span><br><span class="line">n=<span class="number">10000000</span>; <span class="comment">%生成的随机数组数</span></span><br><span class="line">x1=unifrnd(<span class="number">-100</span>,<span class="number">100</span>,n,<span class="number">1</span>);  <span class="comment">% 生成在[-100,100]之间均匀分布的随机数组成的n行1列的向量构成x1</span></span><br><span class="line">x2=unifrnd(<span class="number">-100</span>,<span class="number">100</span>,n,<span class="number">1</span>);  <span class="comment">% 生成在[-100,100]之间均匀分布的随机数组成的n行1列的向量构成x2</span></span><br><span class="line">fmin=+<span class="built_in">inf</span>; <span class="comment">% 初始化函数f的最小值为正无穷（后续只要找到一个比它小的我们就对其更新）</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:n</span><br><span class="line">    x = [x1(<span class="built_in">i</span>), x2(<span class="built_in">i</span>)];  <span class="comment">%构造x向量, 这里千万别写成了：x =[x1, x2]</span></span><br><span class="line">    <span class="keyword">if</span> ((x(<span class="number">1</span>)<span class="number">-1</span>)^<span class="number">2</span>-x(<span class="number">2</span>)&lt;=<span class="number">0</span>)  &amp; (<span class="number">-2</span>*x1(<span class="built_in">i</span>)+<span class="number">3</span>*x2(<span class="built_in">i</span>)<span class="number">-6</span> &lt;= <span class="number">0</span>)     <span class="comment">% 判断是否满足条件</span></span><br><span class="line">        result = -x(<span class="number">1</span>)^<span class="number">2</span>-x(<span class="number">2</span>)^<span class="number">2</span> +x(<span class="number">1</span>)*x(<span class="number">2</span>)+<span class="number">2</span>*x(<span class="number">1</span>)+<span class="number">5</span>*x(<span class="number">2</span>) ;  <span class="comment">% 如果满足条件就计算函数值</span></span><br><span class="line">        <span class="keyword">if</span>  result  &lt; fmin  <span class="comment">% 如果这个函数值小于我们之前计算出来的最小值</span></span><br><span class="line">            fmin = result;  <span class="comment">% 那么就更新这个函数值为新的最小值</span></span><br><span class="line">            x0 = x;  <span class="comment">% 并且将此时的x1 x2更新为初始值</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">disp</span>(<span class="string">'蒙特卡罗选取的初始值为：'</span>); <span class="built_in">disp</span>(x0)</span><br><span class="line">A = [<span class="number">-2</span> <span class="number">3</span>]; b = <span class="number">6</span>;</span><br><span class="line">[x,fval] = fmincon(@fun1,x0,A,b,[],[],[],[],@nonlfun1)</span><br><span class="line">fval = -fval  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 例题二的求解</span></span><br><span class="line">x0 = [<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>];  <span class="comment">%任意给定一个初始值 </span></span><br><span class="line">lb = [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span>];  <span class="comment">% 决策变量的下界</span></span><br><span class="line">[x,fval] = fmincon(@fun2,x0,[],[],[],[],lb,[],@nonlfun2)  <span class="comment">% 注意 fun2.m文件和nonfun2.m文件都必须在当前文件夹目录下</span></span><br><span class="line"><span class="comment">% x =</span></span><br><span class="line"><span class="comment">%          0.552167405729277          1.20325915507969         0.947824046150443</span></span><br><span class="line"><span class="comment">% fval =</span></span><br><span class="line"><span class="comment">%           10.6510918606939</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 使用蒙特卡罗的方法来找初始值(推荐）</span></span><br><span class="line">clc,clear;</span><br><span class="line">n=<span class="number">1000000</span>; <span class="comment">%生成的随机数组数</span></span><br><span class="line">x1= unifrnd(<span class="number">0</span>,<span class="number">2</span>,n,<span class="number">1</span>);   <span class="comment">% 生成在[0,2]之间均匀分布的随机数组成的n行1列的向量构成x1</span></span><br><span class="line">x2 = <span class="built_in">sqrt</span>(<span class="number">2</span>-x1);  <span class="comment">% 根据非线性等式约束用x1计算出x2</span></span><br><span class="line">x3 = <span class="built_in">sqrt</span>((<span class="number">3</span>-x2)/<span class="number">2</span>); <span class="comment">% 根据非线性等式约束用x2计算出x3</span></span><br><span class="line">fmin=+<span class="built_in">inf</span>; <span class="comment">% 初始化函数f的最小值为正无穷（后续只要找到一个比它小的我们就对其更新）</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:n</span><br><span class="line">    x = [x1(<span class="built_in">i</span>), x2(<span class="built_in">i</span>), x3(<span class="built_in">i</span>)];  <span class="comment">%构造x向量, 这里千万别写成了：x =[x1, x2, x3]</span></span><br><span class="line">    <span class="keyword">if</span> (-x(<span class="number">1</span>)^<span class="number">2</span>+x(<span class="number">2</span>)-x(<span class="number">3</span>)^<span class="number">2</span>&lt;=<span class="number">0</span>) &amp; (x(<span class="number">1</span>)+x(<span class="number">2</span>)^<span class="number">2</span>+x(<span class="number">3</span>)^<span class="number">2</span><span class="number">-20</span>&lt;=<span class="number">0</span>)   <span class="comment">% 判断是否满足条件</span></span><br><span class="line">        result =sum(x.*x) + <span class="number">8</span> ;  <span class="comment">% 如果满足条件就计算函数值</span></span><br><span class="line">        <span class="keyword">if</span>  result  &lt; fmin  <span class="comment">% 如果这个函数值小于我们之前计算出来的最小值</span></span><br><span class="line">            fmin = result;  <span class="comment">% 那么就更新这个函数值为新的最小值</span></span><br><span class="line">            x0 = x;  <span class="comment">% 并且将此时的x1 x2 x3更新为初始值</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">disp</span>(<span class="string">'蒙特卡罗选取的初始值为：'</span>); <span class="built_in">disp</span>(x0)</span><br><span class="line">lb = [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span>];  <span class="comment">% 决策变量的下界</span></span><br><span class="line">[x,fval] = fmincon(@fun2,x0,[],[],[],[],lb,[],@nonlfun2)  <span class="comment">% 注意 fun2.m文件和nonfun2.m文件都必须在当前文件夹目录下</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 例题三的求解(蒙特卡罗模拟那一讲的例题)</span></span><br><span class="line">clear;clc</span><br><span class="line"><span class="comment">% 蒙特卡罗模拟得到的最大值为3445.6014</span></span><br><span class="line"><span class="comment">% 最大值处x1 x2 x3的取值为：</span></span><br><span class="line"><span class="comment">%           22.5823101903968          12.5823101903968          12.1265223966757</span></span><br><span class="line">A = [<span class="number">1</span> <span class="number">-2</span> <span class="number">-2</span>;  <span class="number">1</span> <span class="number">2</span> <span class="number">2</span>];  b = [<span class="number">0</span> <span class="number">72</span>];</span><br><span class="line">x0 = [ <span class="number">22.58</span>   <span class="number">12.58</span>  <span class="number">12.13</span>];</span><br><span class="line">Aeq = [<span class="number">1</span> <span class="number">-1</span> <span class="number">0</span>]; beq = <span class="number">10</span>;</span><br><span class="line">lb = [-<span class="built_in">inf</span> <span class="number">10</span> -<span class="built_in">inf</span>];  ub = [<span class="built_in">inf</span> <span class="number">20</span> <span class="built_in">inf</span>];  </span><br><span class="line">[x,fval] = fmincon(@fun3,x0,A,b,Aeq,beq,lb,ub,[])  <span class="comment">% 注意没有非线性约束，所以这里可以用[]替代，或者干脆不写</span></span><br><span class="line">fval = -fval</span><br></pre></td></tr></table></figure><p>fun1.m</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span> = <span class="title">fun1</span><span class="params">(x)</span></span></span><br><span class="line">    <span class="comment">% 注意：这里的f实际上就是目标函数，函数的返回值也是f</span></span><br><span class="line">    <span class="comment">% 输入值x实际上就是决策变量，由x1和x2组成的向量</span></span><br><span class="line">    <span class="comment">% fun1是函数名称，到时候会被fmincon函数调用, 可以任意取名</span></span><br><span class="line">    <span class="comment">% 保存的m文件和函数名称得一致，也要为fun1.m</span></span><br><span class="line"><span class="comment">%      max  f(x) = x1^2 +x2^2 -x1*x2 -2x1 -5x2</span></span><br><span class="line">    f = -x(<span class="number">1</span>)^<span class="number">2</span>-x(<span class="number">2</span>)^<span class="number">2</span> +x(<span class="number">1</span>)*x(<span class="number">2</span>)+<span class="number">2</span>*x(<span class="number">1</span>)+<span class="number">5</span>*x(<span class="number">2</span>) ; </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>fun2.m</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span> = <span class="title">fun2</span><span class="params">(x)</span></span></span><br><span class="line">    <span class="comment">%     f = x(1)^2+x(2)^2 +x(3)^2+8 ; </span></span><br><span class="line">    f = sum(x.*x) + <span class="number">8</span>;  <span class="comment">% 可别忘了x实际上是一个向量，我们可以使用矩阵的运算符号对其计算</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>fun3.m</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span> = <span class="title">fun3</span><span class="params">(x)</span></span></span><br><span class="line">    f = -prod(x);  <span class="comment">% 可别忘了x实际上是一个向量（prod表示连乘符号，用法和sum类似）</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>nonlfun1.m</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[c,ceq]</span> = <span class="title">nonlfun1</span><span class="params">(x)</span></span></span><br><span class="line">    <span class="comment">% 注意：这里的c实际上就是非线性不等式约束，ceq实际上就是非线性等式约束</span></span><br><span class="line">    <span class="comment">% 输入值x实际上就是决策变量，由x1和x2组成的一个向量</span></span><br><span class="line">    <span class="comment">% 返回值有两个，一个是非线性不等式约束c，一个是非线性等式约束ceq</span></span><br><span class="line">    <span class="comment">% nonlfun1是函数名称，到时候会被fmincon函数调用, 可以任意取名，但不能和目标函数fun1重名</span></span><br><span class="line">    <span class="comment">% 保存的m文件和函数名称得一致，也要为nonlfun1.m</span></span><br><span class="line"><span class="comment">%     -(x1-1)^2 +x2 &gt;= 0 </span></span><br><span class="line">   c = [(x(<span class="number">1</span>)<span class="number">-1</span>)^<span class="number">2</span>-x(<span class="number">2</span>)];   <span class="comment">% 千万別写成了: (x1-1)^2 -x2</span></span><br><span class="line">   ceq = [];  <span class="comment">% 不存在非线性等式约束，所以用[]表示</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>nonlfun2.m</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[c,ceq]</span> = <span class="title">nonlfun2</span><span class="params">(x)</span></span></span><br><span class="line">    <span class="comment">% 非线性不等式约束</span></span><br><span class="line">    c = [-x(<span class="number">1</span>)^<span class="number">2</span>+x(<span class="number">2</span>)-x(<span class="number">3</span>)^<span class="number">2</span>;   <span class="comment">% 一定要注意写法的规范，再次强调这里的x是一个向量！不能把x(1)写成x1</span></span><br><span class="line">            x(<span class="number">1</span>)+x(<span class="number">2</span>)^<span class="number">2</span>+x(<span class="number">3</span>)^<span class="number">2</span><span class="number">-20</span>];</span><br><span class="line">    <span class="comment">% 非线性等式约束</span></span><br><span class="line">    ceq = [-x(<span class="number">1</span>)-x(<span class="number">2</span>)^<span class="number">2</span>+<span class="number">2</span>;</span><br><span class="line">                x(<span class="number">2</span>)+<span class="number">2</span>*x(<span class="number">3</span>)^<span class="number">2</span><span class="number">-3</span>]; </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h1 id="典型例题"><a href="#典型例题" class="headerlink" title="典型例题"></a>典型例题</h1><h2 id="选址问题"><a href="#选址问题" class="headerlink" title="选址问题"></a>选址问题</h2><p><img src="https://gitee.com/pxlsdz/blogImage/raw/master/img/20200229202832.png" alt=""></p><p><img src="https://gitee.com/pxlsdz/blogImage/raw/master/img/20200229203058.png" alt=""></p><p><img src="https://gitee.com/pxlsdz/blogImage/raw/master/img/20200229203233.png" alt=""></p><p><img src="https://gitee.com/pxlsdz/blogImage/raw/master/img/20200229203215.png" alt=""></p><p><img src="https://gitee.com/pxlsdz/blogImage/raw/master/img/20200229203248.png" alt=""></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% 选址问题</span></span><br><span class="line">clear;clc</span><br><span class="line">format long g   <span class="comment">%可以将Matlab的计算结果显示为一般的长数字格式（默认会保留四位小数，或使用科学计数法）</span></span><br><span class="line"><span class="comment">% % (1) 系数向量（原来线性规划问题的写法,我们只需要在此基础上改动一点就可以了）</span></span><br><span class="line"><span class="comment">% a=[1.25  8.75  0.5  5.75  3  7.25];  % 工地的横坐标</span></span><br><span class="line"><span class="comment">% b=[1.25  0.75  4.755  6.5  7.25];   % 工地的纵坐标</span></span><br><span class="line"><span class="comment">% x = [5  2];  % 料场的横坐标</span></span><br><span class="line"><span class="comment">% y = [1  7];  % 料场的纵坐标</span></span><br><span class="line"><span class="comment">% c = [];  % 初始化用来保存工地和料场距离的向量 (这个向量就是我们的系数向量）</span></span><br><span class="line"><span class="comment">% for  j =1:2</span></span><br><span class="line"><span class="comment">%     for i = 1:6</span></span><br><span class="line"><span class="comment">%         c = [c;  sqrt( (a(i)-x(j))^2 + (b(i)-y(j))^2)];  % 每循环一次就在c的末尾插入新的元素</span></span><br><span class="line"><span class="comment">%     end</span></span><br><span class="line"><span class="comment">% end</span></span><br><span class="line"><span class="comment">% (2) 不等式约束</span></span><br><span class="line">A =<span class="built_in">zeros</span>(<span class="number">2</span>,<span class="number">16</span>);  <span class="comment">% 注意这里要改成16</span></span><br><span class="line">A(<span class="number">1</span>,<span class="number">1</span>:<span class="number">6</span>) = <span class="number">1</span>;</span><br><span class="line">A(<span class="number">2</span>,<span class="number">7</span>:<span class="number">12</span>) = <span class="number">1</span>;</span><br><span class="line">b = [<span class="number">20</span>,<span class="number">20</span>]';</span><br><span class="line"><span class="comment">% (3) 等式约束</span></span><br><span class="line">Aeq = <span class="built_in">zeros</span>(<span class="number">6</span>,<span class="number">16</span>);  <span class="comment">% 注意这里要改成16</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="number">6</span></span><br><span class="line">    Aeq(<span class="built_in">i</span>,<span class="built_in">i</span>) = <span class="number">1</span>;  Aeq(<span class="built_in">i</span>,<span class="built_in">i</span>+<span class="number">6</span>) = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">beq = [<span class="number">3</span> <span class="number">5</span> <span class="number">4</span> <span class="number">7</span> <span class="number">6</span> <span class="number">11</span>]';  <span class="comment">% 每个工地的日需求量</span></span><br><span class="line"><span class="comment">%（4）上下界</span></span><br><span class="line">lb = <span class="built_in">zeros</span>(<span class="number">16</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 进行求解</span></span><br><span class="line">x0 = [<span class="number">3</span> <span class="number">5</span> <span class="number">0</span> <span class="number">7</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">4</span> <span class="number">0</span> <span class="number">6</span> <span class="number">10</span> <span class="number">5</span> <span class="number">1</span> <span class="number">2</span> <span class="number">7</span>];  <span class="comment">% 用第一问的结果作为初始值</span></span><br><span class="line">[x,fval] = fmincon(@fun5,x0,A,b,Aeq,beq,lb)  <span class="comment">% 注意没有非线性约束，所以这里可以用[]替代，或者干脆不写</span></span><br><span class="line"><span class="built_in">reshape</span>(x(<span class="number">1</span>:<span class="number">12</span>),<span class="number">6</span>,<span class="number">2</span>)  <span class="comment">% 将x的前12个元素变为6行2列便于观察（reshape函数是按照列的顺序进行转换的，也就是第一列读完，读第二列，即x1对应x_1,1，x2对应x_2,1）</span></span><br><span class="line"><span class="comment">% 新坐标（5.74，4.99） （7.25，7.25）</span></span><br><span class="line"><span class="comment">% fval =</span></span><br><span class="line"><span class="comment">%           89.9231692432933</span></span><br><span class="line"><span class="comment">% 第一问的fval =</span></span><br><span class="line"><span class="comment">%           135.281541790676</span></span><br><span class="line"><span class="number">135.281541790676</span> - <span class="number">89.9231692432933</span>  <span class="comment">%  45.3583725473827</span></span><br></pre></td></tr></table></figure><p>fun5.m</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span> = <span class="title">fun5</span><span class="params">(xx)</span>  % 注意为了避免和下面的<span class="title">x</span>同号，我们把决策变量的向量符号用<span class="title">xx</span>表示（注意<span class="title">xx</span>的长度为16）</span></span><br><span class="line">    a=[<span class="number">1.25</span>  <span class="number">8.75</span>  <span class="number">0.5</span>  <span class="number">5.75</span>  <span class="number">3</span>  <span class="number">7.25</span>];  <span class="comment">% 工地的横坐标</span></span><br><span class="line">    b=[<span class="number">1.25</span>  <span class="number">0.75</span>  <span class="number">4.75</span><span class="number">5</span>  <span class="number">6.5</span>  <span class="number">7.25</span>];   <span class="comment">% 工地的纵坐标</span></span><br><span class="line">    x = [xx(<span class="number">13</span>)  xx(<span class="number">15</span>)];  <span class="comment">% 新料场的横坐标</span></span><br><span class="line">    y = [xx(<span class="number">14</span>)  xx(<span class="number">16</span>)];  <span class="comment">% 新料场的纵坐标</span></span><br><span class="line">    c = [];  <span class="comment">% 初始化用来保存工地和料场距离的向量 (这个向量就是我们的系数向量）</span></span><br><span class="line">    <span class="keyword">for</span>  <span class="built_in">j</span> =<span class="number">1</span>:<span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="number">6</span></span><br><span class="line">            c = [c;  <span class="built_in">sqrt</span>( (a(<span class="built_in">i</span>)-x(<span class="built_in">j</span>))^<span class="number">2</span> + (b(<span class="built_in">i</span>)-y(<span class="built_in">j</span>))^<span class="number">2</span>)];  <span class="comment">% 每循环一次就在c的末尾插入新的元素</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">% 下面我们要求吨千米数，注意c是列向量，我们计算非线性规划时给定的初始值x0是行向量</span></span><br><span class="line">    f = xx(<span class="number">1</span>:<span class="number">12</span>) * c;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="飞行管理问题"><a href="#飞行管理问题" class="headerlink" title="飞行管理问题"></a>飞行管理问题</h2><p>（1995年国赛A题）在约10，000米高空的某边长160公里的正方形区域内，经常有若干架飞机作水平飞行。区域内每架飞机的位置和速度均由计算机记录其数据，以便进行飞行管理。当一架欲进入该区域的飞机到达区域边缘，记录其数据后，要立即计算并判断是否会与区域内的飞机发生碰撞。如果会碰撞，则应计算如何调整各架（包括新进入的）飞机飞行方向角，以避免碰撞。现假定条件如下：<br>1）不碰撞的标准为任意两架飞机的距离大于8公里；<br>2）飞机飞行方向角调整的幅度不应超过30度；<br>3）所有飞机飞行速度均为每小时800公里；<br>4）进入该区域的飞机在到达区域边缘时，与区域内飞机的距离应在60公里以上；<br>5）最多需考虑6架飞机；<br>6）不必考虑飞机离开此区域后的状况。</p><p>设该区域4个顶点的坐标为（0，0），（160，0），（160，160），（0，160）。请你对这个避免碰撞的飞行管理问题建立数学模型，列出计算步骤，对以下数据进行计算（方向角误差不超过0.01度），要求飞机飞行方向角调整的幅度尽量小。<br>记录数据为：</p><p><img src="https://gitee.com/pxlsdz/blogImage/raw/master/img/20200301005419.png" alt=""></p><p><img src="https://gitee.com/pxlsdz/blogImage/raw/master/img/20200301005440.png" alt=""></p><p><img src="https://gitee.com/pxlsdz/blogImage/raw/master/img/20200301005800.png" alt=""></p><p><img src="https://gitee.com/pxlsdz/blogImage/raw/master/img/20200301005729.png" alt=""></p><p>code</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% 飞行管理问题</span></span><br><span class="line">format long g</span><br><span class="line"><span class="comment">%%  （1）画六架飞机的位置</span></span><br><span class="line">clear;clc</span><br><span class="line"><span class="built_in">figure</span>(<span class="number">1</span>)  <span class="comment">% 生成一个图形</span></span><br><span class="line">box on  <span class="comment">% 显示为封闭的盒子</span></span><br><span class="line"><span class="comment">% 绘制飞机的初始位置</span></span><br><span class="line">data = [<span class="number">150</span><span class="number">140</span><span class="number">243</span>;</span><br><span class="line">    <span class="number">85</span><span class="number">85</span><span class="number">236</span>;</span><br><span class="line">    <span class="number">150</span><span class="number">155</span><span class="number">220.5</span>;</span><br><span class="line">    <span class="number">145</span><span class="number">50</span><span class="number">159</span>;</span><br><span class="line">    <span class="number">130</span><span class="number">150</span><span class="number">230</span>;</span><br><span class="line">    <span class="number">0</span><span class="number">0</span><span class="number">52</span>];</span><br><span class="line"><span class="built_in">plot</span>(data(:,<span class="number">1</span>),data(:,<span class="number">2</span>),<span class="string">'.r'</span>)</span><br><span class="line">axis([<span class="number">0</span> <span class="number">160</span>,<span class="number">0</span>,<span class="number">160</span>]);<span class="comment">% 设置坐标轴刻度范围</span></span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line"><span class="comment">% 在图上标上注释</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="number">6</span></span><br><span class="line">    txt = [<span class="string">'飞机'</span>,num2str(<span class="built_in">i</span>)];</span><br><span class="line">    text(data(<span class="built_in">i</span>,<span class="number">1</span>)+<span class="number">2</span>,data(<span class="built_in">i</span>,<span class="number">2</span>)+<span class="number">2</span>,txt,<span class="string">'FontSize'</span>,<span class="number">8</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">% 把Matlab做出来的图可以导出，然后再放到PPT中画出飞机飞行方向的箭头（就和讲义上的类似）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 求解非线性规划问题</span></span><br><span class="line">x0 = [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>];  <span class="comment">% 初始值</span></span><br><span class="line">lb = -<span class="built_in">pi</span>/<span class="number">6</span>*<span class="built_in">ones</span>(<span class="number">6</span>,<span class="number">1</span>);</span><br><span class="line">ub = <span class="built_in">pi</span>/<span class="number">6</span>*<span class="built_in">ones</span>(<span class="number">6</span>,<span class="number">1</span>);</span><br><span class="line">[x,fval] = fmincon(@fun6,x0,[],[],[],[],lb,ub,@nonlfun6)</span><br><span class="line">x = x * <span class="number">180</span> / <span class="built_in">pi</span>    <span class="comment">% 将弧度转换为度数</span></span><br><span class="line"><span class="comment">% 定义一：fval = 3.7315° </span></span><br><span class="line"><span class="comment">% 定义二:  fval = 6.9547((°)^2)</span></span><br></pre></td></tr></table></figure><p>nonlfun.m</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[c,ceq]</span> = <span class="title">nonlfun6</span><span class="params">(delta)</span>   % 决策变量<span class="title">delta</span>为六架飞机调整的角度</span></span><br><span class="line">     x = [<span class="number">150</span> <span class="number">85</span> <span class="number">150</span> <span class="number">145</span> <span class="number">130</span>  <span class="number">0</span>]; <span class="comment">% 飞机初始位置的横坐标</span></span><br><span class="line">     y = [<span class="number">140</span> <span class="number">85</span> <span class="number">155</span>  <span class="number">50</span> <span class="number">150</span>  <span class="number">0</span>]; <span class="comment">% 飞机初始位置的纵坐标</span></span><br><span class="line">     theta = [<span class="number">243</span> <span class="number">236</span> <span class="number">220.5</span> <span class="number">159</span> <span class="number">230</span> <span class="number">52</span>] * <span class="built_in">pi</span> / <span class="number">180</span>; <span class="comment">% 飞机初始的飞行方向角 </span></span><br><span class="line">     v = <span class="number">800</span>;  <span class="comment">% 飞机速度</span></span><br><span class="line">     co = <span class="built_in">cos</span>(theta + delta);  <span class="comment">% 包含6个元素的向量</span></span><br><span class="line">     si = <span class="built_in">sin</span>(theta + delta);  <span class="comment">% 包含6个元素的向量</span></span><br><span class="line">     <span class="comment">% 下面开始计算飞机i和j之间的最短距离（只需要计算矩阵的一半即可）</span></span><br><span class="line">     d = <span class="built_in">zeros</span>(<span class="number">6</span>);  <span class="comment">% 初始化飞机两两之间的最短距离矩阵</span></span><br><span class="line">     <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">2</span>: <span class="number">6</span></span><br><span class="line">         <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>: <span class="built_in">i</span><span class="number">-1</span></span><br><span class="line">             <span class="comment">% 套用我们推导出来的公式计算飞机i和飞机j相距最近的时间</span></span><br><span class="line">             fenzi = ((y(<span class="built_in">j</span>)-y(<span class="built_in">i</span>))*(si(<span class="built_in">j</span>)-si(<span class="built_in">i</span>)) +(x(<span class="built_in">j</span>)-x(<span class="built_in">i</span>))*(co(<span class="built_in">j</span>)-co(<span class="built_in">i</span>))) ;  <span class="comment">% 分子</span></span><br><span class="line">             fenmu =  v * ((co(<span class="built_in">j</span>)-co(<span class="built_in">i</span>))^<span class="number">2</span> + (si(<span class="built_in">j</span>)-si(<span class="built_in">i</span>))^<span class="number">2</span>);  <span class="comment">% 分母</span></span><br><span class="line">             t(<span class="built_in">i</span>,<span class="built_in">j</span>) =- fenzi / fenmu;</span><br><span class="line">             <span class="keyword">if</span> t(<span class="built_in">i</span>,<span class="built_in">j</span>) &lt;<span class="number">0</span>  </span><br><span class="line">                 d(<span class="built_in">i</span>, <span class="built_in">j</span>) = <span class="number">1000</span>; <span class="comment">% 此时最初的位置就是相距最近的点，因为最初的时候所有飞机两两之间的距离就大于8，因此未来绝不会相撞，我们令它们的距离为一个特别大的数</span></span><br><span class="line">             <span class="keyword">else</span></span><br><span class="line">                 d(<span class="built_in">i</span>, <span class="built_in">j</span>) = <span class="built_in">sqrt</span>((x(<span class="built_in">j</span>)-x(<span class="built_in">i</span>)+v*t(<span class="built_in">i</span>,<span class="built_in">j</span>)*(co(<span class="built_in">j</span>)-co(<span class="built_in">i</span>)))^<span class="number">2</span>+(y(<span class="built_in">j</span>)-y(<span class="built_in">i</span>)+v*t(<span class="built_in">i</span>,<span class="built_in">j</span>)*(si(<span class="built_in">j</span>)-si(<span class="built_in">i</span>)))^<span class="number">2</span>); </span><br><span class="line">             <span class="keyword">end</span> </span><br><span class="line">         <span class="keyword">end</span></span><br><span class="line">     <span class="keyword">end</span></span><br><span class="line">     <span class="comment">% 非线性不等式约束</span></span><br><span class="line">     c =<span class="built_in">ones</span>(<span class="number">15</span>,<span class="number">1</span>)*<span class="number">8.000001</span> - [d(<span class="number">2</span>,<span class="number">1</span>); d(<span class="number">3</span>,<span class="number">1</span>:<span class="number">2</span>)'; d(<span class="number">4</span>,<span class="number">1</span>:<span class="number">3</span>)'; d(<span class="number">5</span>,<span class="number">1</span>:<span class="number">4</span>)'; d(<span class="number">6</span>,<span class="number">1</span>:<span class="number">5</span>)'];  </span><br><span class="line">     <span class="comment">% 12个非线性不等式约束: “最短距离&gt;8” 等价于 “8 - 最短距离&lt;0”</span></span><br><span class="line">     <span class="comment">% 注意： 由于Matlab标准型中取的是小于等于号，因此这里取一个比8略大的数：8.000001-最短距离&lt;=0 </span></span><br><span class="line">     ceq = [];  <span class="comment">% 没有非线性等式约束</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>fun.m</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span> = <span class="title">fun6</span><span class="params">(delta)</span>   % 决策变量<span class="title">delta</span>为六架飞机调整的角度</span></span><br><span class="line">   <span class="comment">%         f =sum(abs(delta)) * 180 /  pi;   % 目标函数第一种定义：绝对值的和（将弧度转换为度数）</span></span><br><span class="line">  f = sum(delta .* delta) * (<span class="number">180</span> /  <span class="built_in">pi</span>)^<span class="number">2</span>;  <span class="comment">% 目标函数第二种定义：平方和（将弧度转换为度数）</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MATLAB </tag>
            
            <tag> 数学规划模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数学规划模型——线性规划问题</title>
      <link href="/2020/02/26/%E6%95%B0%E5%AD%A6%E8%A7%84%E5%88%92%E6%A8%A1%E5%9E%8B%E2%80%94%E2%80%94%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98/"/>
      <url>/2020/02/26/%E6%95%B0%E5%AD%A6%E8%A7%84%E5%88%92%E6%A8%A1%E5%9E%8B%E2%80%94%E2%80%94%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="Matlab中线性规划的标准型"><a href="#Matlab中线性规划的标准型" class="headerlink" title="Matlab中线性规划的标准型"></a>Matlab中线性规划的标准型</h1><a id="more"></a><h2 id="标准型"><a href="#标准型" class="headerlink" title="标准型"></a>标准型</h2><p>$$<br>min \ C^{T}X \<br>\ \<br>s.t. \ \begin{cases}<br> &amp; \text{} AX&lt;=b  \quad 不等式约束\<br> &amp; \text{}Aeg*x=beg \quad 等式约束 \<br> &amp; \text{}lb&lt;=x&lt;=ub \quad 上下界约束(也可以当成不等式约束)<br>\end{cases}<br>$$<br>向量的内积 ,<br>$$<br>c=\begin{pmatrix}<br>C_{1}\<br>C_{2}\<br>…\<br>C_{n}<br>\end{pmatrix}<br>\quad<br>x=\begin{pmatrix}<br>x_{1}\<br>x_{2}\<br>…\<br>x_{n}<br>\end{pmatrix},n是决策变量的个数<br>$$</p><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><p><img src="https://gitee.com/pxlsdz/blogImage/raw/master/img/2.png" alt=""></p><ol><li><p>min-&gt;maxm 加负号</p></li><li><p>不等式约束的标准是&lt;=,&gt;=需要转换</p></li><li><p>变量如果不在约束条件，用inf与-inf巧妙转换</p></li></ol><h2 id="Matlab-求解线性规划-的函数"><a href="#Matlab-求解线性规划-的函数" class="headerlink" title="Matlab 求解线性规划 的函数"></a>Matlab 求解线性规划 的函数</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[x ,fval] = linprog [ c, A, b,  Aeq, beq, lb, ub, X0]</span><br></pre></td></tr></table></figure><p>① X0 表示给定Matlab迭代求解的初始值 ( ⼀般不⽤给)</p><p>② c, A, b,  Aeq, beq, lb, ub的意义和 标准型中的意义⼀致 </p><p>③ 若不存在不等式约束, 可⽤ “ [ ] “ 替代 A和b</p><p>④ 若不存在等式约束, 可⽤ “ [ ] “替代 Aeq 和 beq </p><p>⑤ 苦某个 x⽆下界或上界, 则设置lb(i)=-inf,ub(i)=+inf</p><p>⑥ 返回的 x表示⼩值处的 x取值 ; fval表示优解处时取得的最小值</p><p>7.不是所有的线性规划都有唯一解，可能无解或有无穷多的解。<br>8.如果求的是最大值，别忘在最后给fval加一个负号。</p><p>上⾯三个题的代码 ：</p><ol><li><p>[x, fval]=linprog[c, A, b, [], [], lb]</p></li><li><p>[x, fval]=linprog[c, A, b,Aeg, beg, lb]</p></li><li><p>[x, fval]=linprog[c, A, b,Aeg, beg, lb]</p><p>fval=-fval</p></li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% Matlab求解线性规划</span></span><br><span class="line"><span class="comment">% [x fval] = linprog(c, A, b, Aeq, beq, lb,ub, x0)  </span></span><br><span class="line"><span class="comment">% c是目标函数的系数向量，A是不等式约束Ax&lt;=b的系数矩阵，b是不等式约束Ax&lt;=b的常数项</span></span><br><span class="line"><span class="comment">% Aeq是等式约束Aeq x=beq的系数矩阵，beq是等式约束Aeq x=beq的常数项</span></span><br><span class="line"><span class="comment">% lb是X的下限，ub是X的上限，X是向量[x1,x2,...xn]' , 即决策变量。</span></span><br><span class="line"><span class="comment">% 迭代的初始值为x0（一般不用给）</span></span><br><span class="line"><span class="comment">% 更多该函数的用法说明请看讲义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 例题1</span></span><br><span class="line">c = [<span class="number">-5</span> <span class="number">-4</span> <span class="number">-6</span>]';  <span class="comment">% 加单引号表示转置</span></span><br><span class="line"><span class="comment">% c = [-5 -4 -6];  % 写成行向量也是可以的，不过不推荐，我们按照标准型来写看起来比较正规</span></span><br><span class="line">A = [<span class="number">1</span> <span class="number">-1</span> <span class="number">1</span>;</span><br><span class="line">        <span class="number">3</span> <span class="number">2</span> <span class="number">4</span>;</span><br><span class="line">        <span class="number">3</span> <span class="number">2</span> <span class="number">0</span>];</span><br><span class="line">b = [<span class="number">20</span> <span class="number">42</span> <span class="number">30</span>]';   </span><br><span class="line">lb = [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]'; </span><br><span class="line">[x fval] = linprog(c, A, b, [], [], lb)  <span class="comment">% ub我们直接不写，则意味着没有上界的约束</span></span><br><span class="line"><span class="comment">% x =</span></span><br><span class="line"><span class="comment">%          0</span></span><br><span class="line"><span class="comment">%    15.0000</span></span><br><span class="line"><span class="comment">%     3.0000</span></span><br><span class="line"><span class="comment">% </span></span><br><span class="line"><span class="comment">% fval =</span></span><br><span class="line"><span class="comment">%    -78</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 例题2</span></span><br><span class="line">c = [<span class="number">0.04</span> <span class="number">0.15</span> <span class="number">0.1</span> <span class="number">0.125</span>]';  </span><br><span class="line">A = [<span class="number">-0.03</span> <span class="number">-0.3</span> <span class="number">0</span> <span class="number">-0.15</span>;</span><br><span class="line">        <span class="number">0.14</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0.07</span>];</span><br><span class="line">b = [<span class="number">-32</span> <span class="number">42</span>]';</span><br><span class="line">Aeq = [<span class="number">0.05</span> <span class="number">0</span> <span class="number">0.2</span> <span class="number">0.1</span>];</span><br><span class="line">beq = <span class="number">24</span>;</span><br><span class="line">lb = [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]';</span><br><span class="line">[x fval] = linprog(c, A, b, Aeq, beq, lb)</span><br><span class="line"><span class="comment">% x =</span></span><br><span class="line"><span class="comment">%          0</span></span><br><span class="line"><span class="comment">%   106.6667</span></span><br><span class="line"><span class="comment">%   120.0000</span></span><br><span class="line"><span class="comment">%          0</span></span><br><span class="line"><span class="comment">% </span></span><br><span class="line"><span class="comment">% fval =</span></span><br><span class="line"><span class="comment">%     28</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 这个题可能有多个解，即有多个x可以使得目标函数的最小值为28（不同的Matlab版本可能得到的x的值不同，但最后的最小值一定是28）</span></span><br><span class="line"><span class="comment">% 例如我们更改一个限定条件：令x1要大于0（注意Matlab中线性规划的标准型要求的不等式约束的符号是小于等于0）</span></span><br><span class="line"><span class="comment">% x1 &gt;0  等价于  -x1 &lt; 0，那么给定 -x1 &lt;= -0.1 (根据实际问题可以给一个略小于0的数-0.1)，这样能将小于号转换为小于等于号，满足Matlab的标准型</span></span><br><span class="line">c = [<span class="number">0.04</span> <span class="number">0.15</span> <span class="number">0.1</span> <span class="number">0.125</span>]';  </span><br><span class="line">A = [<span class="number">-0.03</span> <span class="number">-0.3</span> <span class="number">0</span> <span class="number">-0.15</span>;</span><br><span class="line">        <span class="number">0.14</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0.07</span></span><br><span class="line">        <span class="number">-1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>];</span><br><span class="line">b = [<span class="number">-32</span> <span class="number">42</span> <span class="number">-0.1</span>]';</span><br><span class="line">Aeq = [<span class="number">0.05</span> <span class="number">0</span> <span class="number">0.2</span> <span class="number">0.1</span>];</span><br><span class="line">beq = <span class="number">24</span>;</span><br><span class="line">lb = [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]';</span><br><span class="line">[x fval] = linprog(c, A, b, Aeq, beq, lb)</span><br><span class="line"><span class="comment">% x =</span></span><br><span class="line"><span class="comment">%     0.1000</span></span><br><span class="line"><span class="comment">%   106.6567</span></span><br><span class="line"><span class="comment">%   119.9750</span></span><br><span class="line"><span class="comment">%          0</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">% fval =</span></span><br><span class="line"><span class="comment">%    28.0000</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 例题3</span></span><br><span class="line">c = [<span class="number">-2</span> <span class="number">-3</span> <span class="number">5</span>]';</span><br><span class="line">A = [<span class="number">-2</span> <span class="number">5</span> <span class="number">-1</span>;</span><br><span class="line">          <span class="number">1</span> <span class="number">3</span> <span class="number">1</span>];</span><br><span class="line">b = [<span class="number">-10</span> <span class="number">12</span>];</span><br><span class="line">Aeq = <span class="built_in">ones</span>(<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line">beq = <span class="number">7</span>;</span><br><span class="line">lb = <span class="built_in">zeros</span>(<span class="number">3</span>,<span class="number">1</span>);</span><br><span class="line">[x fval] = linprog(c, A, b, Aeq, beq, lb)</span><br><span class="line">fval = -fval <span class="comment">% 注意这个fval要取负号（原来是求最大值，我们添加负号变成了最小值问题）</span></span><br><span class="line"><span class="comment">% x =</span></span><br><span class="line"><span class="comment">%     6.4286</span></span><br><span class="line"><span class="comment">%     0.5714</span></span><br><span class="line"><span class="comment">%          0</span></span><br><span class="line"><span class="comment">% fval =</span></span><br><span class="line"><span class="comment">%   -14.5714</span></span><br><span class="line"><span class="comment">% fval =</span></span><br><span class="line"><span class="comment">%    14.5714</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 多个解的情况</span></span><br><span class="line"><span class="comment">% 例如 ： min z = x1 + x2   s.t.  x1 + x2 &gt;= 10</span></span><br><span class="line">c = [<span class="number">1</span> <span class="number">1</span>]';   </span><br><span class="line">A = [<span class="number">-1</span> <span class="number">-1</span>];</span><br><span class="line">b = <span class="number">-10</span>;</span><br><span class="line">[x fval] = linprog(c, A, b)   <span class="comment">% Aeq, beq, lb和ub我们都没写，意味着没有等式约束和上下界约束</span></span><br><span class="line"><span class="comment">% x有多个解时，Matlab会给我们返回其中的一个解</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 不存在解的情况</span></span><br><span class="line"><span class="comment">% 例如 ： min z = x1 + x2   s.t.  x1 + x2 = 10 、 x1 + 2*x2 &lt;= 8、 x1 &gt;=0 ，x2 &gt;=0 </span></span><br><span class="line">c = [<span class="number">1</span> <span class="number">1</span>]'; </span><br><span class="line">A = [<span class="number">1</span> <span class="number">2</span>];</span><br><span class="line">b = <span class="number">8</span>;</span><br><span class="line">Aeq = [<span class="number">1</span> <span class="number">1</span>];</span><br><span class="line">beq = <span class="number">10</span>;</span><br><span class="line">lb = [<span class="number">0</span> <span class="number">0</span>]';</span><br><span class="line">[x fval] = linprog(c, A, b, Aeq, beq, lb)  <span class="comment">% Linprog stopped because no point satisfies the constraints.（没有任何一个点满足约束条件）</span></span><br></pre></td></tr></table></figure><h1 id="线性规划的典型例题"><a href="#线性规划的典型例题" class="headerlink" title="线性规划的典型例题"></a>线性规划的典型例题</h1><h2 id="例题1"><a href="#例题1" class="headerlink" title="例题1"></a>例题1</h2><p><img src="https://gitee.com/pxlsdz/blogImage/raw/master/img/3.png" alt=""></p><p><img src="https://gitee.com/pxlsdz/blogImage/raw/master/img/4.png" alt=""></p><p>设备有效台：</p><p>你有100台设备，每月工作22天，每天工作8小时，设备每天只有5小时有效运作（生产），则你的设备有效台时=5×22×100=11000台时，你的工作台时=8×22×100=17600台时，设备有效作业率=5/8=62.5%</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% 生产决策问题</span></span><br><span class="line">format long g   <span class="comment">%可以将Matlab的计算结果显示为一般的长数字格式（默认会保留四位小数，或使用科学计数法）</span></span><br><span class="line"><span class="comment">% (1) 系数向量</span></span><br><span class="line">c = <span class="built_in">zeros</span>(<span class="number">9</span>,<span class="number">1</span>); <span class="comment">% 初始化目标函数的系数向量全为0</span></span><br><span class="line">c(<span class="number">1</span>) = <span class="number">1.25</span> <span class="number">-0.25</span> <span class="number">-300</span>/<span class="number">6000</span>*<span class="number">5</span>;  <span class="comment">% x1前面的系数是c1</span></span><br><span class="line">c(<span class="number">2</span>) = <span class="number">1.25</span> <span class="number">-0.25</span> <span class="number">-321</span>/<span class="number">10000</span>*<span class="number">7</span>;</span><br><span class="line">c(<span class="number">3</span>) = <span class="number">-250</span> / <span class="number">4000</span> * <span class="number">6</span>;</span><br><span class="line">c(<span class="number">4</span>)  = <span class="number">-783</span>/<span class="number">7000</span>*<span class="number">4</span>;</span><br><span class="line">c(<span class="number">5</span>) = <span class="number">-200</span>/<span class="number">4000</span> * <span class="number">7</span>;</span><br><span class="line">c(<span class="number">6</span>) = <span class="number">-300</span>/<span class="number">6000</span>*<span class="number">10</span>;</span><br><span class="line">c(<span class="number">7</span>) = <span class="number">-321</span> / <span class="number">10000</span> * <span class="number">9</span>;</span><br><span class="line">c(<span class="number">8</span>) = <span class="number">2</span><span class="number">-0.35</span><span class="number">-250</span>/<span class="number">4000</span>*<span class="number">8</span>;</span><br><span class="line">c(<span class="number">9</span>) = <span class="number">2.8</span><span class="number">-0.5</span><span class="number">-321</span>/<span class="number">10000</span>*<span class="number">12</span><span class="number">-783</span>/<span class="number">7000</span>*<span class="number">11</span>;</span><br><span class="line">c = -c;  <span class="comment">% 我们求的是最大值，所以这里需要改变符号</span></span><br><span class="line"><span class="comment">% (2) 不等式约束</span></span><br><span class="line">A = <span class="built_in">zeros</span>(<span class="number">5</span>,<span class="number">9</span>);</span><br><span class="line">A(<span class="number">1</span>,<span class="number">1</span>) = <span class="number">5</span>;  A(<span class="number">1</span>,<span class="number">6</span>) = <span class="number">10</span>;</span><br><span class="line">A(<span class="number">2</span>,<span class="number">2</span>) = <span class="number">7</span>;  A(<span class="number">2</span>,<span class="number">7</span>) = <span class="number">9</span>; A(<span class="number">2</span>,<span class="number">9</span>) = <span class="number">12</span>;</span><br><span class="line">A(<span class="number">3</span>,<span class="number">3</span>) = <span class="number">6</span>;  A(<span class="number">3</span>,<span class="number">8</span>) = <span class="number">8</span>;</span><br><span class="line">A(<span class="number">4</span>,<span class="number">4</span>) = <span class="number">4</span>;  A(<span class="number">4</span>,<span class="number">9</span>) = <span class="number">11</span>;</span><br><span class="line">A(<span class="number">5</span>,<span class="number">5</span>) = <span class="number">7</span>;  </span><br><span class="line">b = [<span class="number">6000</span> <span class="number">10000</span> <span class="number">4000</span> <span class="number">7000</span> <span class="number">4000</span>]';</span><br><span class="line"><span class="comment">% (3) 等式约束</span></span><br><span class="line">Aeq = [<span class="number">1</span> <span class="number">1</span> <span class="number">-1</span> <span class="number">-1</span> <span class="number">-1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">            <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">-1</span> <span class="number">0</span>];</span><br><span class="line">beq = [<span class="number">0</span> <span class="number">0</span>]';</span><br><span class="line"><span class="comment">%（4）上下界</span></span><br><span class="line">lb = <span class="built_in">zeros</span>(<span class="number">9</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 进行求解</span></span><br><span class="line">[x fval] = linprog(c, A, b, Aeq, beq, lb)</span><br><span class="line">fval = -fval</span><br><span class="line"><span class="comment">% fval =</span></span><br><span class="line"><span class="comment">%           1146.56650246305</span></span><br><span class="line"><span class="comment">%  注意，本题应该是一个整数规划的例子，我们在后面的整数规划部分再来重新求解。</span></span><br><span class="line">intcon = <span class="number">1</span>:<span class="number">9</span>;</span><br><span class="line">[x,fval]=intlinprog(c,intcon,A,b,Aeq,beq,lb)</span><br><span class="line">fval = -fval</span><br></pre></td></tr></table></figure><h2 id="例题2"><a href="#例题2" class="headerlink" title="例题2"></a>例题2</h2><p><img src="https://gitee.com/pxlsdz/blogImage/raw/master/img/5.png" alt=""></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% 投料问题</span></span><br><span class="line">clear,clc</span><br><span class="line">format long g   <span class="comment">%可以将Matlab的计算结果显示为一般的长数字格式（默认会保留四位小数，或使用科学计数法）</span></span><br><span class="line"><span class="comment">% (1) 系数向量</span></span><br><span class="line">a=[<span class="number">1.25</span>  <span class="number">8.75</span>  <span class="number">0.5</span>  <span class="number">5.75</span>  <span class="number">3</span>  <span class="number">7.25</span>];  <span class="comment">% 工地的横坐标</span></span><br><span class="line">b=[<span class="number">1.25</span>  <span class="number">0.75</span>  <span class="number">4.75</span><span class="number">5</span>  <span class="number">6.5</span>  <span class="number">7.25</span>];   <span class="comment">% 工地的纵坐标</span></span><br><span class="line">x = [<span class="number">5</span>  <span class="number">2</span>];  <span class="comment">% 料场的横坐标</span></span><br><span class="line">y = [<span class="number">1</span>  <span class="number">7</span>];  <span class="comment">% 料场的纵坐标</span></span><br><span class="line">c = [];  <span class="comment">% 初始化用来保存工地和料场距离的向量 (这个向量就是我们的系数向量）</span></span><br><span class="line"><span class="keyword">for</span>  <span class="built_in">j</span> =<span class="number">1</span>:<span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="number">6</span></span><br><span class="line">        c = [c;  <span class="built_in">sqrt</span>( (a(<span class="built_in">i</span>)-x(<span class="built_in">j</span>))^<span class="number">2</span> + (b(<span class="built_in">i</span>)-y(<span class="built_in">j</span>))^<span class="number">2</span>)];  <span class="comment">% 每循环一次就在c的末尾插入新的元素</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">% (2) 不等式约束</span></span><br><span class="line">A =<span class="built_in">zeros</span>(<span class="number">2</span>,<span class="number">12</span>);</span><br><span class="line">A(<span class="number">1</span>,<span class="number">1</span>:<span class="number">6</span>) = <span class="number">1</span>;</span><br><span class="line">A(<span class="number">2</span>,<span class="number">7</span>:<span class="number">12</span>) = <span class="number">1</span>;</span><br><span class="line">b = [<span class="number">20</span>,<span class="number">20</span>]';</span><br><span class="line"><span class="comment">% (3) 等式约束</span></span><br><span class="line">Aeq = <span class="built_in">zeros</span>(<span class="number">6</span>,<span class="number">12</span>);  </span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="number">6</span></span><br><span class="line">    Aeq(<span class="built_in">i</span>,<span class="built_in">i</span>) = <span class="number">1</span>;  Aeq(<span class="built_in">i</span>,<span class="built_in">i</span>+<span class="number">6</span>) = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">% Aeq = [eye(6),eye(6)]  % 两个单位矩阵横着拼起来</span></span><br><span class="line">beq = [<span class="number">3</span> <span class="number">5</span> <span class="number">4</span> <span class="number">7</span> <span class="number">6</span> <span class="number">11</span>]';  <span class="comment">% 每个工地的日需求量</span></span><br><span class="line"><span class="comment">%（4）上下界</span></span><br><span class="line">lb = <span class="built_in">zeros</span>(<span class="number">12</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 进行求解</span></span><br><span class="line">[x fval] = linprog(c, A, b, Aeq, beq, lb)</span><br><span class="line">x = <span class="built_in">reshape</span>(x,<span class="number">6</span>,<span class="number">2</span>)  <span class="comment">% 将x变为6行2列便于观察（reshape函数是按照列的顺序进行转换的，也就是第一列读完，读第二列，即x1对应x_1,1，x2对应x_2,1）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% fval =</span></span><br><span class="line"><span class="comment">%           135.281541790676</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MATLAB </tag>
            
            <tag> 数学规划模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数学规划模型——概述</title>
      <link href="/2020/02/26/%E6%95%B0%E5%AD%A6%E8%A7%84%E5%88%92%E6%A8%A1%E5%9E%8B%E2%80%94%E2%80%94%E6%A6%82%E8%BF%B0/"/>
      <url>/2020/02/26/%E6%95%B0%E5%AD%A6%E8%A7%84%E5%88%92%E6%A8%A1%E5%9E%8B%E2%80%94%E2%80%94%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是数学规划"><a href="#什么是数学规划" class="headerlink" title="什么是数学规划?"></a>什么是数学规划?</h1><a id="more"></a><p>数学规划是运筹学的⼀个分⽀ , 其⽤来研究: 在给定的条件 下 (约束条件), 如何按照某⼀衡量指标 (<strong>⽬标函数</strong>)来寻求计划、 管理⼯作中的优⽅案 。</p><p> 总结：<font color=red><strong>求⽬标函数在 ⼀定约束条件下的极值问题</strong> </font></p><h1 id="数学规划的⼀般形式"><a href="#数学规划的⼀般形式" class="headerlink" title="数学规划的⼀般形式"></a>数学规划的⼀般形式</h1><p>$$<br>min(或者 max) Z = f(x)  \   </p><p>s.t. \quad   g_{i}(x)&lt;=0,i=1,2,…m(不等式约束)<br>\  (也可能有等式约束 , 整数约束 或 两者皆有)<br>$$</p><ul><li>x: 决策变量 ( ⼀般有多个⾃变量)   </li><li>f(x): ⽬标函数 </li><li>不等式约束 ,等式约束,整数约束 : 约束条件</li><li>s.t.：subiectto</li></ul><h1 id="数学规划的分类"><a href="#数学规划的分类" class="headerlink" title="数学规划的分类"></a>数学规划的分类</h1><h2 id="①-线性规划-Lineupngramming"><a href="#①-线性规划-Lineupngramming" class="headerlink" title="① 线性规划 ( Lineupngramming)"></a>① 线性规划 ( Lineupngramming)</h2><p>​       如果⽬标函数 和 和约束条件均是决策变量的线性表达式 , 那么此时的数学规划问题就属于线性规划。<br>​       1947年, 美国数学家丹⻬格 ( GB.Dantz.in)提出了 求解线性规划的单纯形法 , 奠定了这⻔学科的基础 。 </p><h2 id="②-⾮线性规划-nonlinear-pogramming"><a href="#②-⾮线性规划-nonlinear-pogramming" class="headerlink" title="② ⾮线性规划 (nonlinear pogramming)"></a>② ⾮线性规划 (nonlinear pogramming)</h2><p>​       当⽬标函数和或者约束条件中有⼀个是决策变量 ㄨ 的⾮线性表达式, 那么 此时的数学规划问题就属于⾮线性规划 。 </p><p>​       解决⾮线性规划要⽐线性规划困难得多 , ⽬前没有通⽤算法, ⼤多数算法都是在选定决策变量的初始值后 ,通过定的搜索⽅法 寻求优的决策变量。 </p><h2 id="③整数规划-integer-pogramming）"><a href="#③整数规划-integer-pogramming）" class="headerlink" title="③整数规划 (integer pogramming）"></a>③整数规划 (integer pogramming）</h2><p>整数 规划是⼀类要求变量取整数值的数学规划 ：</p><ul><li><p>线性整数规划 (在线性规划模型中, 有决策变量限定为整数）</p></li><li><p>⾮线性整数规划 </p></li></ul><p>⽬前, 所流⾏的 求解整数规划的算法往往只适⽤于线性整数规划, 所以本节学习的求解均针对线性整数规划。 </p><h2 id="④-0-1规划-0-1-pogramming"><a href="#④-0-1规划-0-1-pogramming" class="headerlink" title="④ 0-1规划 (0-1 pogramming)"></a>④ 0-1规划 (0-1 pogramming)</h2><p>整数规划的特例 , 整数变量的取值只能为 0 和 1 。</p><h1 id="学习框架"><a href="#学习框架" class="headerlink" title="学习框架"></a>学习框架</h1><p><img src="https://gitee.com/pxlsdz/blogImage/raw/master/img/1.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MATLAB </tag>
            
            <tag> 数学规划模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机专业英语--COMPUTER ORGANIZATION</title>
      <link href="/2020/02/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%8B%B1%E8%AF%AD--COMPUTER%20ORGANIZATION/"/>
      <url>/2020/02/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%8B%B1%E8%AF%AD--COMPUTER%20ORGANIZATION/</url>
      
        <content type="html"><![CDATA[<h1 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h1><ol><li><p>Function of computer</p><p>计算机功能</p></li></ol><a id="more"></a><ol start="2"><li><p>mainframe,auxiliary device</p><p>主机与外设</p></li><li><p>macro 巨大的</p><p>micro  微小的</p></li><li><p>analog 模拟</p></li><li><p>modem 调制解调器</p></li><li><p><strong>general-purpose machine通用（计算）机<br>special-purpose machine 专用（计算）机</strong></p></li><li><p><strong>information processing</strong></p></li><li><p><strong>set of instruction 指令</strong></p></li><li><p><strong>main memory 主存储器</strong></p></li><li><p><strong>mainframe主机，特大型机</strong></p></li><li><p><strong>operating system 操作系统</strong></p></li><li><p>disk 磁盘</p></li><li><p>vi~  代表视觉的意思</p></li><li><p><strong>peripheral 外围；外围设备</strong></p><p>auxiliary device</p></li><li><p><strong>interface接口</strong></p></li><li><p>illustrates 说明</p></li><li><p>component 组件；组成</p></li><li><p>organization 组织</p><p>configurations 配置；组织解救</p></li><li><p>arbitrary 随意的；任意的</p></li><li><p>generic 普通的</p></li><li><p>cabinet 柜子</p></li><li><p>briefcase 公文包</p></li><li><p>As technology advances</p><p>with the development of technology</p></li></ol><h1 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h1><ol><li><p>Explain the difference between general-purpose  machines and special-purpose machines.</p><p>Computers are valuable because they are general-purpose machines that can solve many different kinds of problems, as opposed to special-purpose machines that can each solve only one kind of problem.</p></li><li><p>Point the purposes of computer.</p><p>To solve problems.</p></li><li><p>How many components are used to build a computer ? List them.</p><p>Every computer has four basic hardware components:</p><p>​        ● Input devices </p><p>​        ● Output devices </p><p>​        ● Main memory </p><p>​        ● Central processing unit(CPU)</p></li><li><p>Describe the classification of computers according to its physical size.</p><p>● Small microcomputer;</p><p>● Medium minicomputer;</p><p>● Large mainframe. </p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 英语 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无线网络--无线传输技术基础</title>
      <link href="/2020/02/26/%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C--%E6%97%A0%E7%BA%BF%E4%BC%A0%E8%BE%93%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/"/>
      <url>/2020/02/26/%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C--%E6%97%A0%E7%BA%BF%E4%BC%A0%E8%BE%93%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="无线传输媒体"><a href="#无线传输媒体" class="headerlink" title="无线传输媒体"></a><strong>无线传输媒体</strong></h1><a id="more"></a><p>传输媒体：</p><ul><li><p>引导性媒体（线缆媒体）：电磁波沿固态媒体传播</p></li><li><p>非引导性媒体（无线媒体）：提供传输信号的手段但不加以引导</p></li></ul><p>波长（λ）：两个相邻波峰之间的距离</p><p>频率（f）：电磁波每秒振动的次数</p><p>波长和频率的关系：<br>$$<br>λf=c<br>$$</p><p>（光速c：电磁波在真空中的传播速3*10^8m/s）</p><p>电磁波的分类:</p><ul><li><p>微波</p></li><li><p>红外线</p></li></ul><h1 id="无线传输方式"><a href="#无线传输方式" class="headerlink" title="无线传输方式"></a>无线传输方式</h1><ol><li><p>地面波（ground wave）</p><ul><li>沿着地球轮廓线</li><li>可以传播很远</li><li>频率高达2MHz</li><li>例如:AM radio调幅无线电</li></ul></li><li><p>天空波（sky wave）</p><ul><li><p>信号从大气电离层反射回地球</p></li><li><p>信号能传播上几个来回，在电离层和地球表面之间上下</p></li><li><p>比地面波范围还要远</p></li><li><p>反射效果由折射引发</p></li><li><p>例如</p><p>业余无线电</p><p>民用波段无线电</p></li></ul></li><li><p>直线传播（line of sight）</p><ul><li><p>传输和接收天线必须在视线内</p></li><li><p>视距传播的距离一般为20～50Km</p></li></ul></li></ol><h1 id="无线传输损伤"><a href="#无线传输损伤" class="headerlink" title="无线传输损伤"></a>无线传输损伤</h1><ol><li><p>衰退（fading）</p><ul><li>传输媒体或者路径使得接收信号的能量发生变化</li><li>在固定环境下：大气层条件的变化（例如：下雨）</li><li>在移动环境下：障碍物的相对位置随时间发生变化，造成复杂的传输效果— — 多径传播</li></ul></li><li><p>反射：信号遇到表面大于信号波长（地球表面、高大建筑物）的障碍物导致相位漂移</p></li><li><p>衍射 </p><ul><li>信号遇到大于边长的不可穿透无边缘</li><li>即使没有来自发送器的视线信号（LOS）也可接收到信号</li></ul></li><li><p>散射：</p><p>入境信号遇到波长较小的物体（树叶、街牌、灯柱）后发散为数个弱的出境信号</p><ul><li>对于LOS，衍射和散射信号不重要</li><li>对于非LOS，衍射和散射是接收的主要手段</li></ul></li></ol><p><strong>多径（Multipath）传播</strong></p><p><strong>从发射机天线发射的信号沿两个或多个路径到达接收机天线的传播现象</strong></p><h1 id="信号编码技术"><a href="#信号编码技术" class="headerlink" title="信号编码技术"></a>信号编码技术</h1>]]></content>
      
      
      <categories>
          
          <category> 无线网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课堂笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无线网络--概述</title>
      <link href="/2020/02/26/%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C--%E6%A6%82%E8%BF%B0/"/>
      <url>/2020/02/26/%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C--%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="无线网络的应用"><a href="#无线网络的应用" class="headerlink" title="无线网络的应用"></a>无线网络的应用</h1><a id="more"></a><ul><li>无线抄表</li><li>无线支付</li><li>移动互联网、物联网和增强现实技术相结合，可提供对空间和运动的感知能力，如谷歌的Project Tango项目。</li><li>无线网络和移动计算常联系，二者并不相同，兼顾移动和无线的应用。</li></ul><h1 id="计算机网络的协议体系"><a href="#计算机网络的协议体系" class="headerlink" title="计算机网络的协议体系"></a>计算机网络的协议体系</h1><ul><li><p>网络技术中为数据交换而设置的标准、规则和约定的集合称协议。</p></li><li><p>具体某个协议往往关注具体某一层，用于同层实体间通信的相关规则约定的集合。</p></li><li><p>协议三要素：语义、语法和定时。</p><ul><li><p>语义——协议控制信息的具体含义；</p></li><li><p>语法——数据和控制信息的格式、编码规则；</p></li><li><p>时序——数据和控制信息的收发同步和排序。</p></li></ul></li></ul><p> 划分规则</p><ul><li>各层对等实体间逻辑通信。各种逻辑通信均有对应协议，本层为上层提供服务，也享受下层服务。</li><li>各层相互独立、功能明确。</li><li>功能作为分层基础，每一层只需与上下层相关，各司其职，各尽其责。</li></ul><p>实体、服务和服务访问点</p><ul><li><p>实体：发送或接收信息的任一硬件或软件进程。协议控制下，本层为上一层提供服务,<strong>成对出现，任何层</strong>。</p></li><li><p>服务访问点SAP：同一主机相邻两层实体交换信息的位置，实际上是逻辑接口。</p></li><li><p>协议数据单元PDU：层与层之间交换的数据单位。</p><p> ISO/OSI模型（上到下）：</p></li><li><p>上层协议（应用层、表示层、会话层、传输层）</p></li><li><p>通信子网（网络层、链路层、物理层）</p><p> TCP/IP模型（上到下）：</p></li><li><p>应用层（报文）、传输层（TCP报文段、UDP数据报）、网际互联层（IP分组/数据包）、网络接口层（MAC数据帧）</p></li></ul><p>介质访问控制(medium access control)简称MAC。 是解决当前局域网中共用信道的使用产生竞争时，如何分配信道的使用权问题。</p><h1 id="无线网络的协议层次特点"><a href="#无线网络的协议层次特点" class="headerlink" title="无线网络的协议层次特点"></a>无线网络的协议层次特点</h1><ul><li>无线网络协议体系也基于分层。不同类型无线网络关注的层次不同。WLAN一般无路由问题，不涉及网络层，采用传统IP协议。鉴于共享访问介质问题，MAC层协议是许多无线网络关注重点。无线频谱管理复杂性，使物理层协议成为重点。MANET路由问题，关注网络层。</li><li>无线网络和有线网络特点不同，决定二者传输机制和协议设计不同。有线网络当发送方检测到丢包发生时，一般认为网络拥塞，降低发送速率。而无线网络出现丢包，发送方可尽力重发。</li><li>许多无线网络需对传统网络协议进行改进。</li><li>无线网络目标是提供更便捷的通信服务，应用层协议并非重点，解决了无线网络连接和可靠性，各种应用都可直接使用无线网络。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 无线网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课堂笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络测试与分析--网络系统性能和网络流量测试(1)</title>
      <link href="/2020/02/26/%E7%BD%91%E7%BB%9C%E6%B5%8B%E8%AF%95%E4%B8%8E%E5%88%86%E6%9E%90--%E7%BD%91%E7%BB%9C%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E5%92%8C%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E6%B5%8B%E8%AF%95(1)/"/>
      <url>/2020/02/26/%E7%BD%91%E7%BB%9C%E6%B5%8B%E8%AF%95%E4%B8%8E%E5%88%86%E6%9E%90--%E7%BD%91%E7%BB%9C%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E5%92%8C%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E6%B5%8B%E8%AF%95(1)/</url>
      
        <content type="html"><![CDATA[<h1 id="测试的三个方面"><a href="#测试的三个方面" class="headerlink" title="测试的三个方面"></a>测试的三个方面</h1><a id="more"></a><ol><li>可用性</li><li>网络性能的检测</li><li>系统实际运行情况的检测和分析</li></ol><h1 id="网络的可用性检测"><a href="#网络的可用性检测" class="headerlink" title="网络的可用性检测"></a>网络的可用性检测</h1><ol><li><p>网络接口和线路状态的检测。</p></li><li><p>网络节点的连通性检测。</p></li></ol><h1 id="网络通信故障诊断"><a href="#网络通信故障诊断" class="headerlink" title="网络通信故障诊断"></a>网络通信故障诊断</h1><h2 id="网络通信故障诊断（Ping）"><a href="#网络通信故障诊断（Ping）" class="headerlink" title="网络通信故障诊断（Ping）"></a>网络通信故障诊断（Ping）</h2><p>执行<strong>Ping</strong>成功，<strong>只能保证</strong>当前主机与目的主机间<strong>存在一条</strong>连通的物理路径。</p><p>若执行<strong>Ping</strong>不成功，则故障可能是网线不通、网络适配器配置不正确或IP地址不可用等。</p><h2 id="网络接口故障诊断（IPConfig）"><a href="#网络接口故障诊断（IPConfig）" class="headerlink" title="网络接口故障诊断（IPConfig）"></a>网络接口故障诊断（IPConfig）</h2><p>作用：<strong>检查网络接口配置</strong></p><p>/all：更多、更全</p><h2 id="网络整体状态统计（Netstat）"><a href="#网络整体状态统计（Netstat）" class="headerlink" title="网络整体状态统计（Netstat）"></a>网络整体状态统计（Netstat）</h2><p>有助于用户了解<strong>网络的整体使用情况</strong>。</p><p>显示当前<strong>正在活动的网络连接</strong>的详细信息</p><h2 id="网络路由故障诊断（Tracert、Pathping）"><a href="#网络路由故障诊断（Tracert、Pathping）" class="headerlink" title="网络路由故障诊断（Tracert、Pathping）"></a>网络路由故障诊断（Tracert、Pathping）</h2><p>Tracert:跟踪<strong>IP</strong>数据包访问目标所采取的路径。</p><p>Pathping：监视数据包在传输中经过的网络路径。</p><h2 id="使用Sniffer诊断网络"><a href="#使用Sniffer诊断网络" class="headerlink" title="使用Sniffer诊断网络"></a>使用Sniffer诊断网络</h2><p>将网络适配卡置为混杂模式状态</p><h1 id="作业："><a href="#作业：" class="headerlink" title="作业："></a>作业：</h1><p><strong>1.</strong> 下列<strong>可显示当前正在活动的网络连接</strong>的命令为（D）</p><p>A.<strong>Ping</strong></p><p>B.<strong>Tracert</strong></p><p>C.<strong>Pathping</strong></p><p>D.<strong>Netstat</strong></p><p><strong>2.</strong> <strong>下列可作为路由检查工具，用来确定可能导致网络问题的路由器的命令为（</strong> C<strong>）</strong></p><p>A.<strong>Ping</strong></p><p>B.<strong>Tracert</strong></p><p>C.<strong>Pathping</strong></p><p>D.<strong>Netstat</strong></p><p>pathping命令在一段时间内将数据包发送到到达最终目标的路径上的每个路由器，然后基于数据包的计算机结果从每个跃点返回。由于命令显示数据包在任何给定路由器或链接上丢失的程度，因此可以很容易地确定可能导致网络问题的路由器或链接</p><p><strong>3.</strong> <strong>如果交换机上的SPEED指示灯显示为绿色闪烁，则表示（ B ）</strong></p><p>  <strong>A.</strong> <strong>端口运行</strong>10Mb/s  </p><p>B. <strong>端口运行</strong>100Mb/s </p><p> C. <strong>端口的运行速度为</strong>1Gb/s</p><p><strong>SPEED</strong>指示灯（端口速度）：</p><p><strong>灭：</strong>端口运行10Mb/s</p><p><strong>绿色：</strong>端口运行100Mb/s</p><p><strong>绿色</strong>闪烁：端口的运行速度为1Gb/s</p><p><strong>4.</strong> <strong>交换机上的四种端口模式指示灯为</strong>                               </p><p>   <strong>端口模式指示灯有四种模式：</strong></p><p>   STAT、 UTIL、 DUPLEX、 SPEED                        </p><p><strong>5.</strong> <strong>网络故障可能由很多原因引起，如果用Ping命令来排除网络问题有哪些方法及采用这些方法的目的是什么？</strong></p><p>（1）<strong>Ping127.0.0.1</strong>，127.0.0.1是回环地址，目的就是检测本机的回路是否正常，如果不正常说明本地的TCP/IP协议没有设置好。<br>（2）<strong>Ping本机IP地址</strong>，如果没有应答，则表示本地配置或安装存在问题。局域网用户可断开网络电缆，然后重新发送该命令。如果网线断开后本命令正确，则表示另一台计算机可能配置了相同的IP地址。<br>（3）<strong>Ping本网其他主机IP地址</strong>，这个命令经过网卡及网络电缆到达其他主机，如果收到0个应答，表示子网掩码不正确、网卡配置错误、或电缆系统有问题。<br>（4）<strong>Ping网关IP</strong>，如果得到应答，表示局域网中的网关路由器正在运行，说明和局域网可正常通信。<br>（5）<strong>Ping远程IP地址</strong>，检查本网或本机与外网的连接是否正常。<br>（6）<strong>ping <a href="http://www.xxxx.com" target="_blank" rel="noopener">www.xxxx.com</a></strong>，即ping域名，如果出现故障，则表示本机DNS的IP地址配置不正确，或DNS服务器有故障。</p>]]></content>
      
      
      <categories>
          
          <category> 网络测试与分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课堂笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>层次分析法</title>
      <link href="/2020/02/25/%E5%B1%82%E6%AC%A1%E5%88%86%E6%9E%90%E6%B3%95/"/>
      <url>/2020/02/25/%E5%B1%82%E6%AC%A1%E5%88%86%E6%9E%90%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><a id="more"></a><p>​         层次分析法（The Analytic Hierarchy Process即AHP)是由美国运筹学家、 匹兹堡大学教授T . L. Saaty于20世纪70年代创立的一种系统分析与决策的综合 评价方法，是在充分研究了人类思维过程的基础上提出来的，它较合理地解 决了定性问题定量化的处理过程。 </p><p>​        AHP的主要特点是通过建立递阶层次结构，把人类的判断转化到若干因 素两两之间重要度的比较上，从而把难于量化的定性判断转化为可操作的重 要度的比较上面。在许多情况下，决策者可以直接使用AHP进行决策，极大 地提高了决策的有效性、可靠性和可行性，但其本质是一种思维方式，它把 复杂问题分解成多个组成因素，又将这些因素按支配关系分别形成递阶层次 结构，通过两两比较的方法确定决策方案相对重要度的总排序。整个过程体 现了人类决策思维的基本特征，即分解、判断、综合，克服了其他方法回避 决策者主观判断的缺点。</p><h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><h2 id="第一步递阶层次结构"><a href="#第一步递阶层次结构" class="headerlink" title="第一步递阶层次结构"></a>第一步递阶层次结构</h2><p>分析系统中各因素之间的关系，建立系统的递阶层次结构。</p><p><img src="https://raw.githubusercontent.com/pxlsdz/MarkDown-images/master/2020-2-25/1.png" alt=""></p><h2 id="第二步构造判断矩阵"><a href="#第二步构造判断矩阵" class="headerlink" title="第二步构造判断矩阵"></a>第二步构造判断矩阵</h2><p>{1，2，3，…，9}:代表重要程度，逐渐递增</p><p><img src="https://raw.githubusercontent.com/pxlsdz/MarkDown-images/master/2020-2-25/2.png" alt=""></p><p>得到一个方阵，我们记为A，对应的元素为$a_{ij}$.</p><p>（1）$a_{ij}$表示的意义是，与指标j相比，i的重要程度。<br>（2）当i=j时，两个指标相同，因此同等重要记为1，这就解释了主对角线元素为1。<br>（3）$a_{ij}$&gt;0且满足$a_{ij}*a_{ji}=1$（我们称满足这一条件的矩阵为正互反矩阵）</p><h2 id="第三步一致性检验"><a href="#第三步一致性检验" class="headerlink" title="第三步一致性检验"></a>第三步一致性检验</h2><p><img src="https://raw.githubusercontent.com/pxlsdz/MarkDown-images/master/2020-2-25/3.png" alt=""></p><p>判断矩阵<font color=red>各行（各列）之间成倍数关系</font></p><p>$a_{ij}$&gt;0且满足$a_{ij}*a_{ji}=1$（我们称满足这一条件的矩阵为正互反矩阵）</p><p>在层次分析法中，我们构造的判断矩阵均是正互反矩阵</p><p>若正互反矩阵满足$a_{ij}*a_{jk}=a_{ik}$，则我们称其为一致矩阵</p><p><strong>注意：在使用判断矩阵求权重之前，必须对其进行一致性检验。</strong><br>$$<br>\left[\begin{array}{cccc}<br>{a_{11}} &amp; {a_{12}} &amp; {\cdots} &amp; {a_{1 n}} \<br>{a_{21}} &amp; {a_{22}} &amp; {\cdots} &amp; {a_{2 n}} \<br>{\vdots} &amp; {\vdots} &amp; {\ddots} &amp; {\vdots} \<br>{a_{n 1}} &amp; {a_{n 2}} &amp; {\cdots} &amp; {a_{n n}}<br>\end{array}\right]为一致矩阵的充要条件：\left{\begin{array}{l}<br>{a_{ij}&gt;0} \<br>{a_{11}=a_{22}=\cdots=a_{n n}=1} \<br>{\left[a_{i 1}, a_{i 2}, \cdots, a_{i n}\right]=k_{i}\left[a_{11}, a_{12}, \cdots, a_{1 n}\right]}<br>\end{array}\right.<br>$$</p><p>$$</p><p>$$</p><h3 id="一致性检验的步骤"><a href="#一致性检验的步骤" class="headerlink" title="一致性检验的步骤"></a>一致性检验的步骤</h3><h4 id="第一步：计算一致性指标CI"><a href="#第一步：计算一致性指标CI" class="headerlink" title="第一步：计算一致性指标CI"></a>第一步：计算一致性指标CI</h4><p>$$<br>CI=\frac{入_{max}-n}{n-1}<br>$$</p><h4 id="第二步：查找对应的平均随机一致性指标RI"><a href="#第二步：查找对应的平均随机一致性指标RI" class="headerlink" title="第二步：查找对应的平均随机一致性指标RI"></a>第二步：查找对应的平均随机一致性指标RI</h4><p><img src="https://raw.githubusercontent.com/pxlsdz/MarkDown-images/master/2020-2-25/4.png" alt=""></p><h4 id="第三步：计算一致性比例CR"><a href="#第三步：计算一致性比例CR" class="headerlink" title="第三步：计算一致性比例CR"></a>第三步：计算一致性比例CR</h4><p>$$<br>CR=\frac{CI}{RI}<br>$$</p><p>如果CR &lt; 0.1,  则可认为判断矩阵的一致性可以接受；否则需要对 判断矩阵进行修正。</p><h2 id="第四步判断矩阵计算权重"><a href="#第四步判断矩阵计算权重" class="headerlink" title="第四步判断矩阵计算权重"></a>第四步判断矩阵计算权重</h2><h3 id="归一化"><a href="#归一化" class="headerlink" title="归一化"></a>归一化</h3><p>权重一定要进行归一化处理</p><p>eg：</p><p><img src="https://raw.githubusercontent.com/pxlsdz/MarkDown-images/master/2020-2-25/5.png" alt=""></p><h3 id="方法1：算术平均法求权重"><a href="#方法1：算术平均法求权重" class="headerlink" title="方法1：算术平均法求权重"></a>方法1：算术平均法求权重</h3><ol><li><p>第一步：将判断矩阵按照列归一化 （<strong>每一个元素除以其所在列的和</strong>）</p></li><li><p>第二步：将归一化的各列相加(<strong>按行求和</strong>)</p></li><li><p>第三步：将相加后得到的向量中每个元素除以n即可得到权重向量</p></li></ol><p>   假设判断矩阵为</p><p>$$<br>A=\left[\begin{array}{cccc}<br>{a_{11}} &amp; {a_{12}} &amp; {\cdots} &amp; {a_{1 n}} \<br>{a_{21}} &amp; {a_{22}} &amp; {\cdots} &amp; {a_{2 n}} \<br>{\vdots} &amp; {\vdots} &amp; {\ddots} &amp; {\vdots} \<br>{a_{n 1}} &amp; {a_{n 2}} &amp; {\cdots} &amp; {a_{n n}}<br>\end{array}\right]<br>$$</p><p>那么算术平均法求得的权重向量<br>$$<br>\omega_{i}=\frac{1}{n} \sum_{j=1}^{n} \frac{a_{i j}}{\sum_{k=1}^{n} a_{k j}}（i=1，2，…n）<br>$$</p><h3 id="方法2：几何平均法求权重"><a href="#方法2：几何平均法求权重" class="headerlink" title="方法2：几何平均法求权重"></a>方法2：几何平均法求权重</h3><p>几何平均法求权重也有三步： </p><ol><li><p>第一步：将A的元素按照行相乘得到一个新的列向量</p></li><li><p>第二步：将新的向量的每个分量开n次方 </p></li><li><p>第三步：对该列向量进行归一化即可得到权重向量</p></li><li><p>假设判断矩阵为</p></li></ol><p>$$<br>A=\left[\begin{array}{cccc}{a_{11}} &amp; {a_{12}} &amp; {\cdots} &amp; {a_{1 n}} \{a_{21}} &amp; {a_{22}} &amp; {\cdots} &amp; {a_{2 n}} \{\vdots} &amp; {\vdots} &amp; {\ddots} &amp; {\vdots} \{a_{n 1}} &amp; {a_{n 2}} &amp; {\cdots} &amp; {a_{n n}}\end{array}\right]<br>$$</p><p>那么几何平均法求得的权重向量<br>$$<br>\omega_{i}=\frac{\left(\prod_{j=1}^{n} a_{i j}\right)^{\frac{1}{n}}}{\sum_{k=1}^{n}\left(\prod_{j=1}^{n} a_{k j}\right)^{\frac{1}{n}}}, \quad(i=1,2, \cdots, n)<br>$$</p><h3 id="方法3：特征值法"><a href="#方法3：特征值法" class="headerlink" title="方法3：特征值法"></a>方法3：特征值法</h3><h3 id="求权重"><a href="#求权重" class="headerlink" title="求权重"></a>求权重</h3><p>假如我们的判断矩阵一致性可以接受，那么我们可以仿照一致矩阵权重的求法。</p><ol><li><p>第一步：求出矩阵A的最大特征值以及其对应的特征向量</p></li><li><p>第二步：对求出的特征向量进行归一化即可得到我们的权重</p></li></ol><h3 id="实际建模"><a href="#实际建模" class="headerlink" title="实际建模"></a>实际建模</h3><p>以往的论文利用层次分析法解决实际问题时，都是采用其中某一种方法求权重，而不同的计算方法可能会导致结果有所偏差。为了保证结果的稳健性，本文采用了三种方法分别求出了权重，再根据得到的权重矩阵计算各方案的得分，并进行排序和综合分析，这样避免了采用单一方法所产生的偏差，得出的结论将更全面、更有效。</p><p><strong>三种权值求平均权值</strong></p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% 注意：在论文写作中，应该先对判断矩阵进行一致性检验，然后再计算权重，因为只有判断矩阵通过了一致性检验，其权重才是有意义的。</span></span><br><span class="line"><span class="comment">%% 在下面的代码中，我们先计算了权重，然后再进行了一致性检验，这是为了顺应计算过程，事实上在逻辑上是说不过去的。</span></span><br><span class="line"><span class="comment">%% 因此大家自己写论文中如果用到了层次分析法，一定要先对判断矩阵进行一致性检验。</span></span><br><span class="line"><span class="comment">%% 而且要说明的是，只有非一致矩阵的判断矩阵才需要进行一致性检验。</span></span><br><span class="line"><span class="comment">%% 如果你的判断矩阵本身就是一个一致矩阵，那么就没有必要进行一致性检验。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">% 在每一行的语句后面加上分号(一定要是英文的哦;中文的长这个样子；)表示不显示运行结果</span></span><br><span class="line"><span class="comment">% 多行注释:选中要注释的若干语句,快捷键Ctrl+R</span></span><br><span class="line"><span class="comment">% 取消注释:选中要取消注释的语句,快捷键Ctrl+T</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">disp</span>(<span class="string">'请输入判断矩阵A'</span>)  <span class="comment">%matlab中disp()就是屏幕输出函数，类似于c语言中的printf（）函数</span></span><br><span class="line"><span class="comment">% 注意，disp函数比较特殊，这里可要分号，可不要分号哦</span></span><br><span class="line"></span><br><span class="line">A=input(<span class="string">'A='</span>);</span><br><span class="line"><span class="comment">% 这里输入的就是我们的判断矩阵，其为n阶方阵（行数和列数相同）</span></span><br><span class="line"><span class="comment">% [1 3 1/3 1/3 1 1/3;1/3 1 1/4 1/5 1 1/5;3 4 1 1 2 3;3 5 1 1 2 1;1 1 1/2 1/2 1 1;3 5 1/3 1 1 1]</span></span><br><span class="line"><span class="comment">% [1 1 4 1/3 3;1 1 4 1/3 3;1/4 1/4 1 1/3 1/2;3 3 3 1 3;1/3 1/3 2 1/3 1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 在开始下面正式的步骤之前，我们有必要检验下A是否因为粗心而输入有误</span></span><br><span class="line">ERROR = <span class="number">0</span>;  <span class="comment">% 默认输入是没有错误的</span></span><br><span class="line"><span class="comment">%(1)检查矩阵A的维数是否不大于1或不是方阵</span></span><br><span class="line">[r,c]=<span class="built_in">size</span>(A);</span><br><span class="line"><span class="comment">%size(A)函数是用来求矩阵的大小的,返回一个行向量，第一个元素是矩阵的行数，第二个元素是矩阵的列数</span></span><br><span class="line"><span class="comment">%[r,c]=size(A)  %将矩阵A的行数返回到第一个输出变量r，将矩阵的列数返回到第二个输出变量c</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> r ~= c  || r &lt;= <span class="number">1</span></span><br><span class="line">    <span class="comment">% 注意哦，不等号是 ~=  (~是键盘Tab上面那个键，要和Shift键同时按才会出来)，别和C语言里面的!=搞混了</span></span><br><span class="line">    <span class="comment">% ||表示逻辑运算符‘或’（在键盘Enter上面，也要和Shift键一起按） 逻辑运算符且是 &amp;&amp; （&amp;读and，连接符号，是and的缩写。 ）</span></span><br><span class="line">    ERROR = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">% Matlab的判断语句，if所在的行不需要冒号，语句的最后一定要以end结尾 ；中间的语句要注意缩进。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%(2)检验是否为正互反矩阵  a_ij &gt; 0 且 a_ij * a_ji = 1</span></span><br><span class="line"><span class="keyword">if</span> ERROR == <span class="number">0</span></span><br><span class="line">    [n,n] = <span class="built_in">size</span>(A);</span><br><span class="line">    <span class="comment">% 因为我们的判断矩阵A是一个非零方阵，所以这里的r和c相同，我们可以就用同一个字母n表示</span></span><br><span class="line">    <span class="comment">% 判断是否有元素小于0</span></span><br><span class="line">    <span class="comment">%    for i = 1:n</span></span><br><span class="line">    <span class="comment">%        for j = 1:n</span></span><br><span class="line">    <span class="comment">%            if A(i,j)&lt;=0</span></span><br><span class="line">    <span class="comment">%                ERROR = 2;</span></span><br><span class="line">    <span class="comment">%            end</span></span><br><span class="line">    <span class="comment">%        end</span></span><br><span class="line">    <span class="comment">%    end</span></span><br><span class="line">    <span class="keyword">if</span> sum(sum(A &lt;= <span class="number">0</span>)) &gt; <span class="number">0</span></span><br><span class="line">        ERROR = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%顺便检验n是否超过了15，因为RI向量为15维</span></span><br><span class="line"><span class="keyword">if</span> ERROR == <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> n &gt; <span class="number">15</span></span><br><span class="line">        ERROR = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ERROR == <span class="number">0</span></span><br><span class="line">    <span class="comment">% 判断  a_ij * a_ji = 1 是否成立</span></span><br><span class="line">    <span class="keyword">if</span> sum(sum(A' .* A ~=  <span class="built_in">ones</span>(n))) &gt; <span class="number">0</span></span><br><span class="line">        ERROR = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">% A' 表示求出 A 的转置矩阵，即将a_ij和a_ji互换位置</span></span><br><span class="line">    <span class="comment">% ones(n)函数生成一个n*n的全为1的方阵, zeros(n)函数生成一个n*n的全为0的方阵</span></span><br><span class="line">    <span class="comment">% ones(m,n)函数生成一个m*n的全为1的矩阵</span></span><br><span class="line">    <span class="comment">% MATLAB在矩阵的运算中，“/”号和“*”号代表矩阵之间的乘法与除法，对应元素之间的乘除法需要使用“./”和“.*”</span></span><br><span class="line">    <span class="comment">% 如果a_ij * a_ji = 1 满足， 那么A和A'对应元素相乘应该为1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ERROR == <span class="number">0</span></span><br><span class="line">    <span class="comment">% % % % % % % % % % % % %方法1： 算术平均法求权重% % % % % % % % % % % % %</span></span><br><span class="line">    <span class="comment">% 第一步：将判断矩阵按照列归一化（每一个元素除以其所在列的和）</span></span><br><span class="line">    <span class="comment">% 第二步：将归一化的各列相加</span></span><br><span class="line">    <span class="comment">% 第三步：将相加后的向量除以n即可得到权重向量</span></span><br><span class="line">    </span><br><span class="line">    Sum_A = sum(A);</span><br><span class="line">    <span class="comment">% matlab中的sum函数的用法</span></span><br><span class="line">    <span class="comment">% a=sum(x);%按列求和</span></span><br><span class="line">    <span class="comment">% a=sum(x,2);%按行求和</span></span><br><span class="line">    <span class="comment">% a=sum(x(:));%对整个矩阵求和</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% % 基础：matlab中如何提取矩阵中指定位置的元素？</span></span><br><span class="line">    <span class="comment">% % （1）取指定行和列的一个元素（输出的是一个值）</span></span><br><span class="line">    <span class="comment">% %     A(2,1)  A(3,2)</span></span><br><span class="line">    <span class="comment">% % （2）取指定的某一行的全部元素（输出的是一个行向量）</span></span><br><span class="line">    <span class="comment">% %     A(2,:)  A(5,:)</span></span><br><span class="line">    <span class="comment">% % （3）取指定的某一列的全部元素（输出的是一个列向量）</span></span><br><span class="line">    <span class="comment">% %     A(:,1)  A(:,3)</span></span><br><span class="line">    <span class="comment">% % （4）取指定的某些行的全部元素（输出的是一个矩阵）</span></span><br><span class="line">    <span class="comment">% %    A([2,5],:)      只取第二行和第五行（一共2行）</span></span><br><span class="line">    <span class="comment">% %    A(2:5,:)        取第二行到第五行（一共4行）</span></span><br><span class="line">    <span class="comment">% % （5）取全部元素(按列拼接的，最终输出的是一个列向量)</span></span><br><span class="line">    <span class="comment">% %    A(:)</span></span><br><span class="line">    </span><br><span class="line">    SUM_A = <span class="built_in">repmat</span>(Sum_A,n,<span class="number">1</span>);</span><br><span class="line">    <span class="comment">% B = repmat(A,m,n):将矩阵A复制m×n块，即把A作为B的元素，B由m×n个A平铺而成。</span></span><br><span class="line">    <span class="comment">% 另外一种替代的方法如下：</span></span><br><span class="line">    <span class="comment">% SUM_A = [];</span></span><br><span class="line">    <span class="comment">% for i = 1:n  %循环哦，不需要加冒号，这里表示循环n次</span></span><br><span class="line">    <span class="comment">%     SUM_A = [SUM_A;Sum_A];</span></span><br><span class="line">    <span class="comment">% end</span></span><br><span class="line">    </span><br><span class="line">    Stand_A = A ./ SUM_A;</span><br><span class="line">    <span class="comment">% MATLAB在矩阵的运算中，“*”号和“/”号代表矩阵之间的乘法与除法，对应元素之间的乘除法需要使用“./”和“.*”</span></span><br><span class="line">    <span class="comment">% 这里我们直接将两个矩阵对应的元素相除即可</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">disp</span>(<span class="string">'算术平均法求权重的结果为：'</span>);</span><br><span class="line">    <span class="built_in">disp</span>(sum(Stand_A,<span class="number">2</span>) / n)</span><br><span class="line">    <span class="comment">% 首先对标准化后的矩阵按照行求和，得到一个列向量，然后再将这个列向量的每个元素同时除以n即可（注意这里也可以用./哦）</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">% % % % % % % % % % % % %方法2： 几何平均法求权重% % % % % % % % % % % % %</span></span><br><span class="line">    <span class="comment">% 第一步：将A的元素按照行相乘得到一个新的列向量</span></span><br><span class="line">    Prduct_A = prod(A,<span class="number">2</span>);</span><br><span class="line">    <span class="comment">% prod函数和sum函数类似，一个用于乘，一个用于加</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% 第二步：将新的向量的每个分量开n次方</span></span><br><span class="line">    Prduct_n_A = Prduct_A .^ (<span class="number">1</span>/n);</span><br><span class="line">    <span class="comment">% 这里对元素操作，因此要加.号哦。  ^符号表示乘方哦  这里是开n次方，所以我们等价求1/n次方</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% 第三步：对该列向量进行归一化即可得到权重向量</span></span><br><span class="line">    <span class="comment">% 将这个列向量中的每一个元素除以这一个向量的和即可</span></span><br><span class="line">    <span class="built_in">disp</span>(<span class="string">'几何平均法求权重的结果为：'</span>);</span><br><span class="line">    <span class="built_in">disp</span>(Prduct_n_A ./ sum(Prduct_n_A))</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">% % % % % % % % % % % % %方法3： 特征值法求权重% % % % % % % % % % % % %</span></span><br><span class="line">    <span class="comment">% 计算矩阵A的特征值和特征向量的函数是eig(A),其中最常用的两个用法：</span></span><br><span class="line">    <span class="comment">% （1）E=eig(A)：求矩阵A的全部特征值，构成向量E。</span></span><br><span class="line">    <span class="comment">% （2）[V,D]=eig(A)：求矩阵A的全部特征值，构成对角阵D，并求A的特征向量构成V的列向量。（V的每一列都是D中与之相同列的特征值的特征向量）</span></span><br><span class="line">    [V,D] = eig(A);    <span class="comment">%V是特征向量, D是由特征值构成的对角矩阵（除了对角线元素外，其余位置元素全为0）</span></span><br><span class="line">    Max_eig = <span class="built_in">max</span>(<span class="built_in">max</span>(D)); <span class="comment">%也可以写成max(D(:))哦~</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% 那么怎么找到最大特征值所在的位置了？ 需要用到find函数，它可以用来返回向量或者矩阵中不为0的元素的位置索引。</span></span><br><span class="line">    <span class="comment">% 下面例子来自博客：https://www.cnblogs.com/anzhiwu815/p/5907033.html</span></span><br><span class="line">    <span class="comment">% 关于find函数的更加深入的用法可参考原文</span></span><br><span class="line">    <span class="comment">% &gt;&gt; X = [1 0 4 -3 0 0 0 8 6];</span></span><br><span class="line">    <span class="comment">% &gt;&gt; ind = find(X)</span></span><br><span class="line">    <span class="comment">% ind =</span></span><br><span class="line">    <span class="comment">%    1     3     4     8     9</span></span><br><span class="line">    <span class="comment">% 其有多种用法，比如返回前2个不为0的元素的位置：</span></span><br><span class="line">    <span class="comment">% &gt;&gt; ind = find(X,2)</span></span><br><span class="line">    <span class="comment">% &gt;&gt; ind =</span></span><br><span class="line">    <span class="comment">%     1     3</span></span><br><span class="line">    <span class="comment">%若X是一个矩阵，索引该如何返回呢？</span></span><br><span class="line">    <span class="comment">%  &gt;&gt; X = [1 -3 0;0 0 8;4 0 6]</span></span><br><span class="line">    <span class="comment">%  X =</span></span><br><span class="line">    <span class="comment">%   1    -3     0</span></span><br><span class="line">    <span class="comment">%   0     0     8</span></span><br><span class="line">    <span class="comment">%   4     0     6</span></span><br><span class="line">    <span class="comment">%  &gt;&gt; ind = find(X)</span></span><br><span class="line">    <span class="comment">% ind =</span></span><br><span class="line">    <span class="comment">%      1</span></span><br><span class="line">    <span class="comment">%      3</span></span><br><span class="line">    <span class="comment">%      4</span></span><br><span class="line">    <span class="comment">%      8</span></span><br><span class="line">    <span class="comment">%      9</span></span><br><span class="line">    <span class="comment">% 这是因为在Matlab在存储矩阵时，是一列一列存储的，我们可以做一下验证：</span></span><br><span class="line">    <span class="comment">%  &gt;&gt; X(4)</span></span><br><span class="line">    <span class="comment">%  ans =</span></span><br><span class="line">    <span class="comment">%     -3</span></span><br><span class="line">    <span class="comment">% 假如你需要按照行列的信息输出该怎么办呢？</span></span><br><span class="line">    <span class="comment">% [r,c] = find(X)</span></span><br><span class="line">    <span class="comment">% r =</span></span><br><span class="line">    <span class="comment">%      1</span></span><br><span class="line">    <span class="comment">%      3</span></span><br><span class="line">    <span class="comment">%      1</span></span><br><span class="line">    <span class="comment">%      2</span></span><br><span class="line">    <span class="comment">%      3</span></span><br><span class="line">    <span class="comment">% c =</span></span><br><span class="line">    <span class="comment">%      1</span></span><br><span class="line">    <span class="comment">%      1</span></span><br><span class="line">    <span class="comment">%      2</span></span><br><span class="line">    <span class="comment">%      3</span></span><br><span class="line">    <span class="comment">%      3</span></span><br><span class="line">    <span class="comment">% [r,c] = find(X,1) %只找第一个非0元素</span></span><br><span class="line">    <span class="comment">% r =</span></span><br><span class="line">    <span class="comment">%      1</span></span><br><span class="line">    <span class="comment">% c =</span></span><br><span class="line">    <span class="comment">%      1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% 那么问题来了，我们要得到最大特征值的位置，就需要将包含所有特征值的这个对角矩阵D中，不等于最大特征值的位置全变为0</span></span><br><span class="line">    <span class="comment">% 这时候可以用到矩阵与常数的大小判断运算，共有三种运算符：大于&gt; ;小于&lt; ;等于 ==  （一个等号表示赋值；两个等号表示判断）</span></span><br><span class="line">    <span class="comment">% 例如：A &gt; 2 会生成一个和A相同大小的矩阵，矩阵元素要么为0，要么为1（A中每个元素和2比较，如果大于2则为1，否则为0）</span></span><br><span class="line">    [r,c]=<span class="built_in">find</span>(D == Max_eig , <span class="number">1</span>);</span><br><span class="line">    <span class="comment">% 找到D中第一个与最大特征值相等的元素的位置，记录它的行和列。</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">disp</span>(<span class="string">'特征值法求权重的结果为：'</span>);</span><br><span class="line">    <span class="built_in">disp</span>( V(:,c) ./ sum(V(:,c)) )</span><br><span class="line">    <span class="comment">% 我们先根据上面找到的最大特征值的列数c找到对应的特征向量，然后再进行标准化。</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% % % % % % % % % % % % %下面是计算一致性比例CR的环节% % % % % % % % % % % % %</span></span><br><span class="line">    <span class="comment">% 当CR&lt;0.10时，我们认为判断矩阵的一致性可以接受；否则应对其进行修正。</span></span><br><span class="line">    CI = (Max_eig - n) / (n<span class="number">-1</span>);</span><br><span class="line">    RI=[<span class="number">0</span> <span class="number">0.00001</span> <span class="number">0.52</span> <span class="number">0.89</span> <span class="number">1.12</span> <span class="number">1.26</span> <span class="number">1.36</span> <span class="number">1.41</span> <span class="number">1.46</span> <span class="number">1.49</span> <span class="number">1.52</span> <span class="number">1.54</span> <span class="number">1.56</span> <span class="number">1.58</span> <span class="number">1.59</span>];  <span class="comment">%注意哦，这里的RI最多支持 n = 15</span></span><br><span class="line">    <span class="comment">% 这里n=2时，一定是一致矩阵，所以CI = 0，我们为了避免分母为0，将这里的第二个元素改为了很接近0的正数</span></span><br><span class="line">    CR=CI/RI(n);</span><br><span class="line">    <span class="built_in">disp</span>(<span class="string">'一致性指标CI='</span>);<span class="built_in">disp</span>(CI);</span><br><span class="line">    <span class="built_in">disp</span>(<span class="string">'一致性比例CR='</span>);<span class="built_in">disp</span>(CR);</span><br><span class="line">    <span class="keyword">if</span> CR&lt;<span class="number">0.10</span></span><br><span class="line">        <span class="built_in">disp</span>(<span class="string">'因为CR&lt;0.10，所以该判断矩阵A的一致性可以接受!'</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">disp</span>(<span class="string">'注意：CR &gt;= 0.10，因此该判断矩阵A需要进行修改!'</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">elseif</span> ERROR == <span class="number">1</span></span><br><span class="line">    <span class="built_in">disp</span>(<span class="string">'请检查矩阵A的维数是否不大于1或不是方阵'</span>)</span><br><span class="line"><span class="keyword">elseif</span> ERROR == <span class="number">2</span></span><br><span class="line">    <span class="built_in">disp</span>(<span class="string">'请检查矩阵A中有元素小于等于0'</span>)</span><br><span class="line"><span class="keyword">elseif</span> ERROR == <span class="number">3</span></span><br><span class="line">    <span class="built_in">disp</span>(<span class="string">'A的维数n超过了15，请减少准则层的数量'</span>)</span><br><span class="line"><span class="keyword">elseif</span> ERROR == <span class="number">4</span></span><br><span class="line">    <span class="built_in">disp</span>(<span class="string">'请检查矩阵A中存在i、j不满足A_ij * A_ji = 1'</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h1 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h1><p>评价下表中20条河流的水质情况。 注：含氧量越高越好；PH值越接近7越好；细菌总数越少越好；植物性营养物量介于10‐20之间最佳，超 过20或低于10均不好。</p><p>topsis作业，求出四个指标的权重。</p><p>代码结果</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">请输入判断矩阵A</span><br><span class="line">A=[<span class="number">1</span> <span class="number">2</span> <span class="number">1</span> <span class="number">4</span>;<span class="number">1</span>/<span class="number">2</span> <span class="number">1</span> <span class="number">1</span> <span class="number">5</span>;<span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">3</span>;<span class="number">1</span>/<span class="number">4</span> <span class="number">1</span>/<span class="number">5</span> <span class="number">1</span>/<span class="number">3</span> <span class="number">1</span>]</span><br><span class="line">算术平均法求权重的结果为：</span><br><span class="line">    <span class="number">0.3619</span></span><br><span class="line">    <span class="number">0.2761</span></span><br><span class="line">    <span class="number">0.2831</span></span><br><span class="line">    <span class="number">0.0789</span></span><br><span class="line"></span><br><span class="line">几何平均法求权重的结果为：</span><br><span class="line">    <span class="number">0.3645</span></span><br><span class="line">    <span class="number">0.2725</span></span><br><span class="line">    <span class="number">0.2852</span></span><br><span class="line">    <span class="number">0.0779</span></span><br><span class="line"></span><br><span class="line">特征值法求权重的结果为：</span><br><span class="line">    <span class="number">0.3670</span></span><br><span class="line">    <span class="number">0.2743</span></span><br><span class="line">    <span class="number">0.2813</span></span><br><span class="line">    <span class="number">0.0774</span></span><br><span class="line"></span><br><span class="line">一致性指标CI=</span><br><span class="line">    <span class="number">0.0351</span></span><br><span class="line"></span><br><span class="line">一致性比例CR=</span><br><span class="line">    <span class="number">0.0394</span></span><br><span class="line"></span><br><span class="line">因为CR&lt;<span class="number">0.10</span>，所以该判断矩阵A的一致性可以接受!</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MATLAB </tag>
            
            <tag> 评价模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络测试与分析--概述</title>
      <link href="/2020/02/24/%E7%BD%91%E7%BB%9C%E6%B5%8B%E8%AF%95%E4%B8%8E%E5%88%86%E6%9E%90--%E6%A6%82%E8%BF%B0/"/>
      <url>/2020/02/24/%E7%BD%91%E7%BB%9C%E6%B5%8B%E8%AF%95%E4%B8%8E%E5%88%86%E6%9E%90--%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 网络测试与分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课堂笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TOPSIS算法</title>
      <link href="/2020/02/24/TOPSIS%E7%AE%97%E6%B3%95/"/>
      <url>/2020/02/24/TOPSIS%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><a id="more"></a><p>​      C.L.Hwang和K.Yoon于1981年首次提出TOPSIS (Technique for  Order Preference by Similarity to an Ideal Solution)，可翻译为逼近理 想解排序法，国内常简称为优劣解距离法。 </p><p>​      TOPSIS 法是一种常用的综合评价方法，能充分利用原始数据的 信息，其结果能精确地反映各评价方案之间的差距。 </p><p>​       基本过程为先将原始数据矩阵统一指标类型（一般正向化处理） 得到正向化的矩阵，再对正向化的矩阵进行标准化处理以消除各指 标量纲的影响，并找到有限方案中的最优方案和最劣方案，然后分 别计算各评价对象与最优方案和最劣方案间的距离，获得各评价对 象与最优方案的相对接近程度，以此作为评价优劣的依据。该方法对数据分布及样本含量没有严格限制，数据计算简单易行。</p><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>评价下表中20条河流的水质情况。 注：含氧量越高越好；PH值越接近7越好；细菌总数越少越好；植物性营养物量介于10‐20之间最佳，超 过20或低于10均不好。</p><p><img src="https://raw.githubusercontent.com/pxlsdz/MarkDown-images/master/2020-2-24/1.png" alt=""></p><h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><h1 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h1><h2 id="第一步：将原始矩阵正向化"><a href="#第一步：将原始矩阵正向化" class="headerlink" title="第一步：将原始矩阵正向化"></a>第一步：将原始矩阵正向化</h2><p>最常见的四种指标：</p><table><thead><tr><th align="center">指标名称</th><th>指标特点</th><th>例子</th></tr></thead><tbody><tr><td align="center">极大型（效益型）指标</td><td>越大（多）越好</td><td>成绩、GDP增速、企业利润</td></tr><tr><td align="center">极小型（成本型）指标</td><td>越小（少）越好</td><td>费用、坏品率、污染程度</td></tr><tr><td align="center">中间型指标</td><td>越接近某个值越好</td><td>水质量评估时的PH值</td></tr><tr><td align="center">区间型指标</td><td>落在某个区间最好</td><td>体温、水中植物性营养物量</td></tr></tbody></table><p><strong>所谓的将原始矩阵正向化，就是要将所有的指标类型统一转化为 极大型指标。（转换的函数形式可以不唯一 ）</strong></p><h3 id="极小型指标-gt-极大型指标"><a href="#极小型指标-gt-极大型指标" class="headerlink" title="极小型指标-&gt;极大型指标"></a>极小型指标-&gt;极大型指标</h3><p><font color=red>极小型指标转换为极大型指标的公式：</font><br>$$<br>max-x<br>$$<br>如果所有的元素均为正数，那么也可以使用 1/x</p><h3 id="中间型指标-gt-极大型指标"><a href="#中间型指标-gt-极大型指标" class="headerlink" title="中间型指标-&gt;极大型指标"></a>中间型指标-&gt;极大型指标</h3><p>{$x_{i}$}是一组中间型指标序列，且最佳的数值为$x_{best}$，那么正向化的公式如下：<br>$$<br>M=\max \left{\left|x_{i}-x_{\text {best}}\right|\right}, \quad \tilde{x}<em>{i}=1-\frac{\left|x</em>{i}-x_{\text {best}}\right|}{M}<br>$$<br>举个例子：</p><p><img src="https://raw.githubusercontent.com/pxlsdz/MarkDown-images/master/2020-2-24/2.png" alt=""></p><h3 id="区间型指标-gt-极大型指标"><a href="#区间型指标-gt-极大型指标" class="headerlink" title="区间型指标-&gt;极大型指标"></a>区间型指标-&gt;极大型指标</h3><p>{$x_{i}$}是一组中间型指标序列，且最佳的区间为[a，b]，那么正向化的公式如下：<br>$$<br>M=\max \left{a-\min \left{x_{i}\right}, \max \left{x_{i}\right}-b\right}, \quad \tilde{x}_{i}=\left{\begin{array}{ll}<br>{1-\frac{a-x}{M}} &amp; {, x&lt;a} \<br>{1} &amp; {, a \leq x \leq b} \<br>{1-\frac{x-b}{M}} &amp; {, x&gt;b}<br>\end{array}\right.<br>$$<br><img src="https://raw.githubusercontent.com/pxlsdz/MarkDown-images/master/2020-2-24/3.png" alt=""></p><h2 id="第二步：正向化矩阵标准化"><a href="#第二步：正向化矩阵标准化" class="headerlink" title="第二步：正向化矩阵标准化"></a>第二步：正向化矩阵标准化</h2><p>为了消去不同指标量纲的影响， 需要对已经正向化的矩阵进行标准化处理。</p><p>假设有n个要评价的对象，m个评价指标（已经正向化了）构成的正向化矩阵如下：<br>$$<br>A=\begin{bmatrix}a_{11}&amp; a_{12}&amp; \cdots  &amp; a_{1n}\a_{21}&amp; a_{22}&amp; \cdots  &amp; a_{2n}\\vdots &amp; \vdots &amp; \ddots &amp; \vdots \a_{m1}&amp; a_{m2}&amp; \cdots  &amp; a_{mn}\end{bmatrix}<br>$$<br>那么，对其标准化的矩阵记为Z，Z中的每一个元素：<br>$$<br>z_{ij}=a_{ij}/ \sqrt{\sum_{i=1}^{n}a_{ij}^{2} }<br>$$</p><p>$$<br>每一个元素/\sqrt{V其所在列的元素的平方和}<br>$$</p><p>注意：标准化的方法有很多种，其主要目的就是去除量纲的影响，未来我们还可能见到更多 种的标准化方法，例如：(x‐x的均值)/x的标准差；具体选用哪一种标准化的方法在多数情况下 并没有很大的限制，这里我们采用的是前人的论文中用的比较多的一种标准化方法。</p><h2 id="第三步：计算得分并归一化"><a href="#第三步：计算得分并归一化" class="headerlink" title="第三步：计算得分并归一化"></a>第三步：计算得分并归一化</h2><h3 id="计算评分的公式"><a href="#计算评分的公式" class="headerlink" title="计算评分的公式"></a>计算评分的公式</h3><p>$$<br>\frac{x-min}{max-min}<br>$$</p><p>解释原因</p><p>（1）比较的对象一般要远大于两个。（例如比较一个班级的成绩）<br>（2）比较的指标也往往不只是一个方面的，例如成绩、工时数、课 外竞赛得分等。<br>（3）有很多指标不存在理论上的最大值和最小值，例如衡量经济增 长水平的指标：GDP增速</p><h3 id="更深本质"><a href="#更深本质" class="headerlink" title="更深本质"></a>更深本质</h3><p>$$<br>\frac{x-min}{max-min}=\frac{x-min}{(max-x)+(x-min)}\<br>=\frac{x与最小值的距离}{x与最大值的距离+x与最小值的距离}<br>$$</p><p><img src="https://raw.githubusercontent.com/pxlsdz/MarkDown-images/master/2020-2-24/4.png" alt=""></p><p>注意：要区别开归一化和标准化。归一化的计算步骤也可以 消去量纲的影响，但更多时候，我们进行归一化的目的是为 了让我们的结果更容易解释，或者说让我们对结果有一个更 加清晰直观的印象。例如将得分归一化后可限制在0‐1这个区 间，对于区间内的每一个得分，我们很容易的得到其所处的比例位置。</p><p>可以使用层次分析法给这m个评价指标确定权重：<br>$$<br>\sum_{j=1}^{m}w_{j}=1<br>$$<br>层次分析法的主观性太强了，更推荐大家使用熵权法来进行客观赋值</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="topsis-m"><a href="#topsis-m" class="headerlink" title="topsis.m"></a>topsis.m</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%%  第一步：把数据复制到工作区，并将这个矩阵命名为X</span></span><br><span class="line"><span class="comment">% （1）在工作区右键，点击新建（Ctrl+N)，输入变量名称为X</span></span><br><span class="line"><span class="comment">% （2）在Excel中复制数据，再回到Excel中右键，点击粘贴Excel数据（Ctrl+Shift+V）</span></span><br><span class="line"><span class="comment">% （3）关掉这个窗口，点击X变量，右键另存为，保存为mat文件（下次就不用复制粘贴了，只需使用load命令即可加载数据）</span></span><br><span class="line"><span class="comment">% （4）注意，代码和数据要放在同一个目录下哦，且Matlab的当前文件夹也要是这个目录。</span></span><br><span class="line">clear;clc</span><br><span class="line">load data_water_quality.mat</span><br><span class="line"><span class="comment">%% 注意：如果提示: 错误使用 load，无法读取文件 'data_water_quality.mat'。没有此类文件或目录。</span></span><br><span class="line"><span class="comment">% 那么原因是因为你的Matlab的当前文件夹中不存在这个文件</span></span><br><span class="line"><span class="comment">% 可以使用cd函数修改Matlab的当前文件夹</span></span><br><span class="line"><span class="comment">% 比如说，我的代码和数据放在了: D:第2讲.TOPSIS法（优劣解距离法）\代码和例题数据</span></span><br><span class="line"><span class="comment">% 那么我就可以输入命令：</span></span><br><span class="line"><span class="comment">% cd 'D:第2讲.TOPSIS法（优劣解距离法）\代码和例题数据'</span></span><br><span class="line"><span class="comment">% 也可以看我更新的视频：“更新9_Topsis代码为什么运行失败_得分结果怎么可视化以及权重的确定如何更加准确”，里面有介绍</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%%  第二步：判断是否需要正向化</span></span><br><span class="line">[n,m] = <span class="built_in">size</span>(X);</span><br><span class="line"><span class="built_in">disp</span>([<span class="string">'共有'</span> num2str(n) <span class="string">'个评价对象, '</span> num2str(m) <span class="string">'个评价指标'</span>]) </span><br><span class="line">Judge = input([<span class="string">'这'</span> num2str(m) <span class="string">'个指标是否需要经过正向化处理，需要请输入1 ，不需要输入0：  '</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> Judge == <span class="number">1</span></span><br><span class="line">    Position = input(<span class="string">'请输入需要正向化处理的指标所在的列，例如第2、3、6三列需要处理，那么你需要输入[2,3,6]： '</span>); <span class="comment">%[2,3,4]</span></span><br><span class="line">    <span class="built_in">disp</span>(<span class="string">'请输入需要处理的这些列的指标类型（1：极小型， 2：中间型， 3：区间型） '</span>)</span><br><span class="line">    Type = input(<span class="string">'例如：第2列是极小型，第3列是区间型，第6列是中间型，就输入[1,3,2]：  '</span>); <span class="comment">%[2,1,3]</span></span><br><span class="line">    <span class="comment">% 注意，Position和Type是两个同维度的行向量</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span> : <span class="built_in">size</span>(Position,<span class="number">2</span>)  <span class="comment">%这里需要对这些列分别处理，因此我们需要知道一共要处理的次数，即循环的次数</span></span><br><span class="line">        X(:,Position(<span class="built_in">i</span>)) = Positivization(X(:,Position(<span class="built_in">i</span>)),Type(<span class="built_in">i</span>),Position(<span class="built_in">i</span>));</span><br><span class="line">    <span class="comment">% Positivization是我们自己定义的函数，其作用是进行正向化，其一共接收三个参数</span></span><br><span class="line">    <span class="comment">% 第一个参数是要正向化处理的那一列向量 X(:,Position(i))   回顾上一讲的知识，X(:,n)表示取第n列的全部元素</span></span><br><span class="line">    <span class="comment">% 第二个参数是对应的这一列的指标类型（1：极小型， 2：中间型， 3：区间型）</span></span><br><span class="line">    <span class="comment">% 第三个参数是告诉函数我们正在处理的是原始矩阵中的哪一列</span></span><br><span class="line">    <span class="comment">% 该函数有一个返回值，它返回正向化之后的指标，我们可以将其直接赋值给我们原始要处理的那一列向量</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="built_in">disp</span>(<span class="string">'正向化后的矩阵 X =  '</span>)</span><br><span class="line">    <span class="built_in">disp</span>(X)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">%% 作业：在这里增加是否需要算加权</span></span><br><span class="line"><span class="comment">% 补充一个基础知识：m*n维的矩阵A 点乘 n维行向量B，等于这个A的每一行都点乘B</span></span><br><span class="line"><span class="comment">% （注意：2017以及之后版本的Matlab才支持，老版本Matlab会报错）</span></span><br><span class="line"><span class="comment">% % 假如原始数据为：</span></span><br><span class="line"><span class="comment">%   A=[1, 2, 3;</span></span><br><span class="line"><span class="comment">%        2, 4, 6] </span></span><br><span class="line"><span class="comment">% % 权重矩阵为：</span></span><br><span class="line"><span class="comment">%   B=[ 0.2, 0.5 ,0.3 ] </span></span><br><span class="line"><span class="comment">% % 加权后为：</span></span><br><span class="line"><span class="comment">%   C=A .* B</span></span><br><span class="line"><span class="comment">%     0.2000    1.0000    0.9000</span></span><br><span class="line"><span class="comment">%     0.4000    2.0000    1.8000</span></span><br><span class="line"><span class="comment">% 类似的，还有矩阵和向量的点除， 大家可以自己试试计算A ./ B</span></span><br><span class="line"><span class="comment">% 注意，矩阵和向量没有 .- 和 .+ 哦 ，大家可以试试，如果计算A.+B 和 A.-B会报什么错误。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 这里补充一个小插曲</span></span><br><span class="line"><span class="comment">% % 在上一讲层次分析法的代码中，我们可以优化以下的语句：</span></span><br><span class="line"><span class="comment">% % Sum_A = sum(A);</span></span><br><span class="line"><span class="comment">% % SUM_A = repmat(Sum_A,n,1);</span></span><br><span class="line"><span class="comment">% % Stand_A = A ./ SUM_A;</span></span><br><span class="line"><span class="comment">% % 事实上，我们把第三行换成：Stand_A = A ./ Sum_A; 也是可以的哦 </span></span><br><span class="line"><span class="comment">% % (再次强调，新版本的Matlab才能运行哦)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 让用户判断是否需要增加权重</span></span><br><span class="line"><span class="built_in">disp</span>(<span class="string">"请输入是否需要增加权重向量，需要输入1，不需要输入0"</span>)</span><br><span class="line">Judge = input(<span class="string">'请输入是否需要增加权重： '</span>);</span><br><span class="line"><span class="keyword">if</span> Judge == <span class="number">1</span></span><br><span class="line">    <span class="built_in">disp</span>([<span class="string">'如果你有3个指标，你就需要输入3个权重，例如它们分别为0.25,0.25,0.5, 则你需要输入[0.25,0.25,0.5]'</span>]);</span><br><span class="line">    weigh = input([<span class="string">'你需要输入'</span> num2str(m) <span class="string">'个权数。'</span> <span class="string">'请以行向量的形式输入这'</span> num2str(m) <span class="string">'个权重: '</span>]);</span><br><span class="line">    OK = <span class="number">0</span>;  <span class="comment">% 用来判断用户的输入格式是否正确</span></span><br><span class="line">    <span class="keyword">while</span> OK == <span class="number">0</span> </span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">abs</span>(sum(weigh) - <span class="number">1</span>)&lt;<span class="number">0.000001</span> &amp;&amp; <span class="built_in">size</span>(weigh,<span class="number">1</span>) == <span class="number">1</span> &amp;&amp; <span class="built_in">size</span>(weigh,<span class="number">2</span>) == m   <span class="comment">% 这里要注意浮点数的运算是不精准的。</span></span><br><span class="line">             OK =<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            weigh = input(<span class="string">'你输入的有误，请重新输入权重行向量: '</span>);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    weigh = <span class="built_in">ones</span>(<span class="number">1</span>,m) ./ m ; <span class="comment">%如果不需要加权重就默认权重都相同，即都为1/m</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 第三步：对正向化后的矩阵进行标准化</span></span><br><span class="line">Z = X ./ <span class="built_in">repmat</span>(sum(X.*X) .^ <span class="number">0.5</span>, n, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">disp</span>(<span class="string">'标准化矩阵 Z = '</span>)</span><br><span class="line"><span class="built_in">disp</span>(Z)</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 第四步：计算与最大值的距离和最小值的距离，并算出得分</span></span><br><span class="line">D_P = sum([(Z - <span class="built_in">repmat</span>(<span class="built_in">max</span>(Z),n,<span class="number">1</span>)) .^ <span class="number">2</span> ] .* <span class="built_in">repmat</span>(weigh,n,<span class="number">1</span>) ,<span class="number">2</span>) .^ <span class="number">0.5</span>;   <span class="comment">% D+ 与最大值的距离向量</span></span><br><span class="line">D_N = sum([(Z - <span class="built_in">repmat</span>(<span class="built_in">min</span>(Z),n,<span class="number">1</span>)) .^ <span class="number">2</span> ] .* <span class="built_in">repmat</span>(weigh,n,<span class="number">1</span>) ,<span class="number">2</span>) .^ <span class="number">0.5</span>;   <span class="comment">% D- 与最小值的距离向量</span></span><br><span class="line">S = D_N ./ (D_P+D_N);    <span class="comment">% 未归一化的得分</span></span><br><span class="line"><span class="built_in">disp</span>(<span class="string">'最后的得分为：'</span>)</span><br><span class="line">stand_S = S / sum(S)</span><br><span class="line">[sorted_S,index] = <span class="built_in">sort</span>(stand_S ,<span class="string">'descend'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">% A = magic(5)  % 幻方矩阵</span></span><br><span class="line"><span class="comment">% M = magic(n)返回由1到n^2的整数构成并且总行数和总列数相等的n×n矩阵。阶次n必须为大于或等于3的标量。</span></span><br><span class="line"><span class="comment">% sort(A)若A是向量不管是列还是行向量，默认都是对A进行升序排列。sort(A)是默认的升序，而sort(A,'descend')是降序排序。</span></span><br><span class="line"><span class="comment">% sort(A)若A是矩阵，默认对A的各列进行升序排列</span></span><br><span class="line"><span class="comment">% sort(A,dim)</span></span><br><span class="line"><span class="comment">% dim=1时等效sort(A)</span></span><br><span class="line"><span class="comment">% dim=2时表示对A中的各行元素升序排列</span></span><br><span class="line"><span class="comment">% A = [2,1,3,8]</span></span><br><span class="line"><span class="comment">% Matlab中给一维向量排序是使用sort函数：sort（A），排序是按升序进行的，其中A为待排序的向量；</span></span><br><span class="line"><span class="comment">% 若欲保留排列前的索引，则可用 [sA,index] = sort(A,'descend') ，排序后，sA是排序好的向量，index是向量sA中对A的索引。</span></span><br><span class="line"><span class="comment">% sA  =  8     3     2     1</span></span><br><span class="line"><span class="comment">% index =  4     3     1     2</span></span><br></pre></td></tr></table></figure><h2 id="Inter2Max-m"><a href="#Inter2Max-m" class="headerlink" title="Inter2Max.m"></a>Inter2Max.m</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[posit_x]</span> = <span class="title">Inter2Max</span><span class="params">(x,a,b)</span></span></span><br><span class="line">    r_x = <span class="built_in">size</span>(x,<span class="number">1</span>);  <span class="comment">% row of x </span></span><br><span class="line">    M = <span class="built_in">max</span>([a-<span class="built_in">min</span>(x),<span class="built_in">max</span>(x)-b]);</span><br><span class="line">    posit_x = <span class="built_in">zeros</span>(r_x,<span class="number">1</span>);   <span class="comment">%zeros函数用法: zeros(3)  zeros(3,1)  ones(3)</span></span><br><span class="line">    <span class="comment">% 初始化posit_x全为0  初始化的目的是节省处理时间</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>: r_x</span><br><span class="line">        <span class="keyword">if</span> x(<span class="built_in">i</span>) &lt; a</span><br><span class="line">           posit_x(<span class="built_in">i</span>) = <span class="number">1</span>-(a-x(<span class="built_in">i</span>))/M;</span><br><span class="line">        <span class="keyword">elseif</span> x(<span class="built_in">i</span>) &gt; b</span><br><span class="line">           posit_x(<span class="built_in">i</span>) = <span class="number">1</span>-(x(<span class="built_in">i</span>)-b)/M;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">           posit_x(<span class="built_in">i</span>) = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="Mid2Max-m"><a href="#Mid2Max-m" class="headerlink" title="Mid2Max.m"></a>Mid2Max.m</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[posit_x]</span> = <span class="title">Mid2Max</span><span class="params">(x,best)</span></span></span><br><span class="line">    M = <span class="built_in">max</span>(<span class="built_in">abs</span>(x-best));</span><br><span class="line">    posit_x = <span class="number">1</span> - <span class="built_in">abs</span>(x-best) / M;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="Min2Max-m"><a href="#Min2Max-m" class="headerlink" title="Min2Max.m"></a>Min2Max.m</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[posit_x]</span> = <span class="title">Min2Max</span><span class="params">(x)</span></span></span><br><span class="line">    posit_x = <span class="built_in">max</span>(x) - x;</span><br><span class="line">     <span class="comment">%posit_x = 1 ./ x;    %如果x全部都大于0，也可以这样正向化</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="Positivization-m"><a href="#Positivization-m" class="headerlink" title="Positivization.m"></a>Positivization.m</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% function [输出变量] = 函数名称(输入变量）  </span></span><br><span class="line"><span class="comment">% 函数的中间部分都是函数体</span></span><br><span class="line"><span class="comment">% 函数的最后要用end结尾</span></span><br><span class="line"><span class="comment">% 输出变量和输入变量可以有多个，用逗号隔开</span></span><br><span class="line"><span class="comment">% function [a,b,c]=test(d,e,f)</span></span><br><span class="line"><span class="comment">%     a=d+e;</span></span><br><span class="line"><span class="comment">%     b=e+f;</span></span><br><span class="line"><span class="comment">%     c=f+d;</span></span><br><span class="line"><span class="comment">% end</span></span><br><span class="line"><span class="comment">% 自定义的函数要单独放在一个m文件中，不可以直接放在主函数里面（和其他大多数语言不同）</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[posit_x]</span> = <span class="title">Positivization</span><span class="params">(x,type,i)</span></span></span><br><span class="line"><span class="comment">% 输入变量有三个：</span></span><br><span class="line"><span class="comment">% x：需要正向化处理的指标对应的原始列向量</span></span><br><span class="line"><span class="comment">% type： 指标的类型（1：极小型， 2：中间型， 3：区间型）</span></span><br><span class="line"><span class="comment">% i: 正在处理的是原始矩阵中的哪一列</span></span><br><span class="line"><span class="comment">% 输出变量posit_x表示：正向化后的列向量</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span> == <span class="number">1</span>  <span class="comment">%极小型</span></span><br><span class="line">        <span class="built_in">disp</span>([<span class="string">'第'</span> num2str(<span class="built_in">i</span>) <span class="string">'列是极小型，正在正向化'</span>] )</span><br><span class="line">        posit_x = Min2Max(x);  <span class="comment">%调用Min2Max函数来正向化</span></span><br><span class="line">        <span class="built_in">disp</span>([<span class="string">'第'</span> num2str(<span class="built_in">i</span>) <span class="string">'列极小型正向化处理完成'</span>] )</span><br><span class="line">        <span class="built_in">disp</span>(<span class="string">'~~~~~~~~~~~~~~~~~~~~分界线~~~~~~~~~~~~~~~~~~~~'</span>)</span><br><span class="line">    <span class="keyword">elseif</span> <span class="built_in">type</span> == <span class="number">2</span>  <span class="comment">%中间型</span></span><br><span class="line">        <span class="built_in">disp</span>([<span class="string">'第'</span> num2str(<span class="built_in">i</span>) <span class="string">'列是中间型'</span>] )</span><br><span class="line">        best = input(<span class="string">'请输入最佳的那一个值： '</span>);</span><br><span class="line">        posit_x = Mid2Max(x,best);</span><br><span class="line">        <span class="built_in">disp</span>([<span class="string">'第'</span> num2str(<span class="built_in">i</span>) <span class="string">'列中间型正向化处理完成'</span>] )</span><br><span class="line">        <span class="built_in">disp</span>(<span class="string">'~~~~~~~~~~~~~~~~~~~~分界线~~~~~~~~~~~~~~~~~~~~'</span>)</span><br><span class="line">    <span class="keyword">elseif</span> <span class="built_in">type</span> == <span class="number">3</span>  <span class="comment">%区间型</span></span><br><span class="line">        <span class="built_in">disp</span>([<span class="string">'第'</span> num2str(<span class="built_in">i</span>) <span class="string">'列是区间型'</span>] )</span><br><span class="line">        a = input(<span class="string">'请输入区间的下界： '</span>);</span><br><span class="line">        b = input(<span class="string">'请输入区间的上界： '</span>); </span><br><span class="line">        posit_x = Inter2Max(x,a,b);</span><br><span class="line">        <span class="built_in">disp</span>([<span class="string">'第'</span> num2str(<span class="built_in">i</span>) <span class="string">'列区间型正向化处理完成'</span>] )</span><br><span class="line">        <span class="built_in">disp</span>(<span class="string">'~~~~~~~~~~~~~~~~~~~~分界线~~~~~~~~~~~~~~~~~~~~'</span>)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">disp</span>(<span class="string">'没有这种类型的指标，请检查Type向量中是否有除了1、2、3之外的其他值'</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line">正向化后的矩阵 X =  </span><br><span class="line">    <span class="number">4.6900</span>    <span class="number">0.7172</span>    <span class="number">3.0000</span>    <span class="number">1.0000</span></span><br><span class="line">    <span class="number">2.0300</span>    <span class="number">0.4069</span>   <span class="number">35.0000</span>    <span class="number">0.6940</span></span><br><span class="line">    <span class="number">9.1100</span>    <span class="number">0.5241</span>    <span class="number">8.0000</span>    <span class="number">0.9058</span></span><br><span class="line">    <span class="number">8.6100</span>    <span class="number">0.9655</span>    <span class="number">8.0000</span>    <span class="number">0.4443</span></span><br><span class="line">    <span class="number">7.1300</span>    <span class="number">0.6552</span>    <span class="number">4.0000</span>    <span class="number">0.6914</span></span><br><span class="line">    <span class="number">2.3900</span>    <span class="number">0.8414</span>   <span class="number">16.0000</span>    <span class="number">0.6007</span></span><br><span class="line">    <span class="number">7.6900</span>    <span class="number">0.8552</span>   <span class="number">16.0000</span>    <span class="number">0.6551</span></span><br><span class="line">    <span class="number">9.3000</span>    <span class="number">0.8690</span>   <span class="number">27.0000</span>         <span class="number">0</span></span><br><span class="line">    <span class="number">5.4500</span>    <span class="number">0.5724</span>   <span class="number">49.0000</span>    <span class="number">1.0000</span></span><br><span class="line">    <span class="number">6.1900</span>    <span class="number">0.8138</span>   <span class="number">37.0000</span>    <span class="number">0.7848</span></span><br><span class="line">    <span class="number">7.9300</span>    <span class="number">0.6345</span>   <span class="number">45.0000</span>    <span class="number">0.6992</span></span><br><span class="line">    <span class="number">4.4000</span>    <span class="number">0.8069</span>   <span class="number">37.0000</span>    <span class="number">0.5419</span></span><br><span class="line">    <span class="number">7.4600</span>    <span class="number">0.1448</span>   <span class="number">31.0000</span>    <span class="number">1.0000</span></span><br><span class="line">    <span class="number">2.0100</span>         <span class="number">0</span>    <span class="number">7.0000</span>    <span class="number">0.4546</span></span><br><span class="line">    <span class="number">2.0400</span>    <span class="number">0.5862</span>   <span class="number">31.0000</span>    <span class="number">1.0000</span></span><br><span class="line">    <span class="number">7.7300</span>    <span class="number">0.4069</span>    <span class="number">2.0000</span>    <span class="number">1.0000</span></span><br><span class="line">    <span class="number">6.3500</span>    <span class="number">0.6000</span>   <span class="number">29.0000</span>    <span class="number">0.1824</span></span><br><span class="line">    <span class="number">8.2900</span>    <span class="number">0.0276</span>   <span class="number">15.0000</span>    <span class="number">1.0000</span></span><br><span class="line">    <span class="number">3.5400</span>    <span class="number">0.8138</span>         <span class="number">0</span>    <span class="number">0.4088</span></span><br><span class="line">    <span class="number">7.4400</span>    <span class="number">0.4897</span>   <span class="number">46.0000</span>    <span class="number">0.2731</span></span><br><span class="line"></span><br><span class="line">请输入是否需要增加权重向量，需要输入<span class="number">1</span>，不需要输入<span class="number">0</span></span><br><span class="line">请输入是否需要增加权重： <span class="number">1</span></span><br><span class="line">如果你有<span class="number">3</span>个指标，你就需要输入<span class="number">3</span>个权重，例如它们分别为<span class="number">0.25</span>,<span class="number">0.25</span>,<span class="number">0.5</span>, 则你需要输入[<span class="number">0.25</span>,<span class="number">0.25</span>,<span class="number">0.5</span>]</span><br><span class="line">你需要输入<span class="number">4</span>个权数。请以行向量的形式输入这<span class="number">4</span>个权重: [<span class="number">0.25</span>,<span class="number">0.25</span>,<span class="number">0.25</span>,<span class="number">0.25</span>]</span><br><span class="line">标准化矩阵 Z = </span><br><span class="line">    <span class="number">0.1622</span>    <span class="number">0.2483</span>    <span class="number">0.0245</span>    <span class="number">0.3065</span></span><br><span class="line">    <span class="number">0.0702</span>    <span class="number">0.1408</span>    <span class="number">0.2863</span>    <span class="number">0.2127</span></span><br><span class="line">    <span class="number">0.3150</span>    <span class="number">0.1814</span>    <span class="number">0.0655</span>    <span class="number">0.2776</span></span><br><span class="line">    <span class="number">0.2977</span>    <span class="number">0.3342</span>    <span class="number">0.0655</span>    <span class="number">0.1361</span></span><br><span class="line">    <span class="number">0.2466</span>    <span class="number">0.2268</span>    <span class="number">0.0327</span>    <span class="number">0.2119</span></span><br><span class="line">    <span class="number">0.0826</span>    <span class="number">0.2912</span>    <span class="number">0.1309</span>    <span class="number">0.1841</span></span><br><span class="line">    <span class="number">0.2659</span>    <span class="number">0.2960</span>    <span class="number">0.1309</span>    <span class="number">0.2008</span></span><br><span class="line">    <span class="number">0.3216</span>    <span class="number">0.3008</span>    <span class="number">0.2209</span>         <span class="number">0</span></span><br><span class="line">    <span class="number">0.1885</span>    <span class="number">0.1981</span>    <span class="number">0.4009</span>    <span class="number">0.3065</span></span><br><span class="line">    <span class="number">0.2141</span>    <span class="number">0.2817</span>    <span class="number">0.3027</span>    <span class="number">0.2405</span></span><br><span class="line">    <span class="number">0.2742</span>    <span class="number">0.2196</span>    <span class="number">0.3682</span>    <span class="number">0.2143</span></span><br><span class="line">    <span class="number">0.1522</span>    <span class="number">0.2793</span>    <span class="number">0.3027</span>    <span class="number">0.1661</span></span><br><span class="line">    <span class="number">0.2580</span>    <span class="number">0.0501</span>    <span class="number">0.2536</span>    <span class="number">0.3065</span></span><br><span class="line">    <span class="number">0.0695</span>         <span class="number">0</span>    <span class="number">0.0573</span>    <span class="number">0.1393</span></span><br><span class="line">    <span class="number">0.0705</span>    <span class="number">0.2029</span>    <span class="number">0.2536</span>    <span class="number">0.3065</span></span><br><span class="line">    <span class="number">0.2673</span>    <span class="number">0.1408</span>    <span class="number">0.0164</span>    <span class="number">0.3065</span></span><br><span class="line">    <span class="number">0.2196</span>    <span class="number">0.2077</span>    <span class="number">0.2373</span>    <span class="number">0.0559</span></span><br><span class="line">    <span class="number">0.2867</span>    <span class="number">0.0095</span>    <span class="number">0.1227</span>    <span class="number">0.3065</span></span><br><span class="line">    <span class="number">0.1224</span>    <span class="number">0.2817</span>         <span class="number">0</span>    <span class="number">0.1253</span></span><br><span class="line">    <span class="number">0.2573</span>    <span class="number">0.1695</span>    <span class="number">0.3763</span>    <span class="number">0.0837</span></span><br><span class="line"></span><br><span class="line">最后的得分为：</span><br><span class="line"></span><br><span class="line">stand_S =</span><br><span class="line"></span><br><span class="line">    <span class="number">0.0451</span></span><br><span class="line">    <span class="number">0.0478</span></span><br><span class="line">    <span class="number">0.0485</span></span><br><span class="line">    <span class="number">0.0488</span></span><br><span class="line">    <span class="number">0.0431</span></span><br><span class="line">    <span class="number">0.0448</span></span><br><span class="line">    <span class="number">0.0539</span></span><br><span class="line">    <span class="number">0.0510</span></span><br><span class="line">    <span class="number">0.0681</span></span><br><span class="line">    <span class="number">0.0684</span></span><br><span class="line">    <span class="number">0.0702</span></span><br><span class="line">    <span class="number">0.0591</span></span><br><span class="line">    <span class="number">0.0527</span></span><br><span class="line">    <span class="number">0.0192</span></span><br><span class="line">    <span class="number">0.0533</span></span><br><span class="line">    <span class="number">0.0434</span></span><br><span class="line">    <span class="number">0.0466</span></span><br><span class="line">    <span class="number">0.0438</span></span><br><span class="line">    <span class="number">0.0358</span></span><br><span class="line">    <span class="number">0.0565</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sorted_S =</span><br><span class="line"></span><br><span class="line">    <span class="number">0.0702</span></span><br><span class="line">    <span class="number">0.0684</span></span><br><span class="line">    <span class="number">0.0681</span></span><br><span class="line">    <span class="number">0.0591</span></span><br><span class="line">    <span class="number">0.0565</span></span><br><span class="line">    <span class="number">0.0539</span></span><br><span class="line">    <span class="number">0.0533</span></span><br><span class="line">    <span class="number">0.0527</span></span><br><span class="line">    <span class="number">0.0510</span></span><br><span class="line">    <span class="number">0.0488</span></span><br><span class="line">    <span class="number">0.0485</span></span><br><span class="line">    <span class="number">0.0478</span></span><br><span class="line">    <span class="number">0.0466</span></span><br><span class="line">    <span class="number">0.0451</span></span><br><span class="line">    <span class="number">0.0448</span></span><br><span class="line">    <span class="number">0.0438</span></span><br><span class="line">    <span class="number">0.0434</span></span><br><span class="line">    <span class="number">0.0431</span></span><br><span class="line">    <span class="number">0.0358</span></span><br><span class="line">    <span class="number">0.0192</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">index =</span><br><span class="line"></span><br><span class="line">    <span class="number">11</span></span><br><span class="line">    <span class="number">10</span></span><br><span class="line">     <span class="number">9</span></span><br><span class="line">    <span class="number">12</span></span><br><span class="line">    <span class="number">20</span></span><br><span class="line">     <span class="number">7</span></span><br><span class="line">    <span class="number">15</span></span><br><span class="line">    <span class="number">13</span></span><br><span class="line">     <span class="number">8</span></span><br><span class="line">     <span class="number">4</span></span><br><span class="line">     <span class="number">3</span></span><br><span class="line">     <span class="number">2</span></span><br><span class="line">    <span class="number">17</span></span><br><span class="line">     <span class="number">1</span></span><br><span class="line">     <span class="number">6</span></span><br><span class="line">    <span class="number">18</span></span><br><span class="line">    <span class="number">16</span></span><br><span class="line">     <span class="number">5</span></span><br><span class="line">    <span class="number">19</span></span><br><span class="line">    <span class="number">14</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MATLAB </tag>
            
            <tag> 评价模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机专业英语--概述</title>
      <link href="/2020/02/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%8B%B1%E8%AF%AD--%E6%A6%82%E8%BF%B0/"/>
      <url>/2020/02/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%8B%B1%E8%AF%AD--%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<ol><li><p>专业英语<br>English for Special Purpose（ESP）</p><a id="more"></a></li><li><p>科技葵语<br>English for Science and Technology（EST）</p></li><li><p>计机专业英语</p></li></ol><ul><li><p>Professional English</p></li><li><p>Academic English</p></li><li><p>Expert English </p></li><li><p>Special English</p></li><li><p>Specialized English</p><p>上面后加 for Computer</p><p>Computer Science in English<br>Computer English</p></li></ul><ol start="4"><li><p>Purpose shapes both content and technique.</p><p>目的决定了你的方法和内容</p></li><li><p>prompt 提示信息</p></li><li><p>SQR3</p><p>Survey+Question+Read+Repeat+Review</p><p>调查+问题+阅读+重复+评论</p></li><li><p>Resume<br>回复/简历</p></li><li><p>curriculum vitae-CV</p><p>简历（更详细）</p></li><li><p>drastically </p><p>极大的</p><p>eg:Your skills will be drastically improved in order to work in an English setting!</p><p>​     为了在英语环境中工作，您的技能将得到极大提高！</p></li><li><p>take attendance</p><p>点名</p></li><li><p>comply with these regulations</p><p>遵守这些规定</p></li><li><p>大专生·junior college student<br>本科生·undergraduate<br>大一生·freshman<br>大二生·sophomore<br>大三生·junior<br>大四生·senior<br>研究生·post graduate（graduate student）</p></li></ol><ol start="13"><li>B.A.=Bachelor of Arts  文学学士<br>B.S.=Bachelor of Science  理学学士<br>B.E.=Bachelor of Engineering  工学学士</li></ol><ol start="14"><li><p>M.A.=M.S.=M.E.=Master’s degree(2-3 years) 硕士学位（2-3年）<br>M.B.A.=Master of Business Administration 工商管理硕士<br>Ph.D.=Doctor of Philosophy(doctorate) 博士学位=哲学博士（博士）</p></li><li><p>On the phone:<br>Hello, this is Xi jinping. May I speak to Mr. Obama?</p><p>您好，我是习近平。我可以跟奥巴马先生说话吗？</p><p>Sure, wait a moment please.</p><p>当然，请稍等。</p></li></ol><ol start="16"><li><p>Employee 雇员<br>Employer 雇主<br>Self-employed 自雇人士<br>Free-lancer 自由职业者<br>Contract worker 合同工<br>Consultant 顾问<br>Unemployed 待业<br>Retired 退休的</p></li><li><p>Division of labor</p><p>分工</p></li><li><p>Give presentations</p><p>发表演讲</p></li><li><p>podium</p><p>讲台</p></li></ol><p>20.自我介绍</p><p>​      My name is Song DuanZheng.I am a local person who is 21 years old. I am from LinYi and I am of the opinion that my hometown is a beautiful city.In spare time,I am keep on reading books, surfing on the Internet, listening to music like, classic, or light music, because they can make me feel relaxed.My current goal is to pass my efforts to a satisfactory graduate student.</p>]]></content>
      
      
      <categories>
          
          <category> 英语 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拟合算法</title>
      <link href="/2020/02/21/%E6%8B%9F%E5%90%88/"/>
      <url>/2020/02/21/%E6%8B%9F%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><a id="more"></a><p>​       与插值问题不同，在拟合问题中不需要曲线一定经过给定的点。拟合问题的目标是寻求一个函数（曲线），使得该曲线在某种准则下与所有的数据点最为接近，即曲线拟合的最好（最小化损失函数）。</p><h1 id="插值和拟合的区别"><a href="#插值和拟合的区别" class="headerlink" title="插值和拟合的区别"></a>插值和拟合的区别</h1><p>​      插值：样本数n&lt;30</p><p>​      拟合：样本数n&gt;=30(大样本)</p><p>插值算法中，得到的多项式f(x)要经过所有样本点。但是如果样本点太多，那<br>么这个多项式次数过高，会造成龙格现象。<br>尽管我们可以选择分段的方法避免这种现象，但是更多时候我们更倾向于得到<br>一个确定的曲线，尽管这条曲线不能经过每一个样本点，但只要保证误差足够小即<br>可，这就是拟合的思想。 (拟合的结果是得到一个确定的曲线)  </p><h1 id="评价拟合效果"><a href="#评价拟合效果" class="headerlink" title="评价拟合效果"></a>评价拟合效果</h1><p><img src="https://img2018.cnblogs.com/i-beta/1880713/202002/1880713-20200221213942289-26608675.png" alt=""></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">y_hat= k*x+b; <span class="comment">% y 的拟合值 </span></span><br><span class="line">SSR = sum((y_hat-<span class="built_in">mean</span>(y)).^<span class="number">2</span>)  <span class="comment">% 回归平方和 </span></span><br><span class="line">SSE = sum((y_hat-y).^<span class="number">2</span>)     <span class="comment">% 误差平方和 </span></span><br><span class="line">SST = sum((y-<span class="built_in">mean</span>(y)).^<span class="number">2</span>) <span class="comment">% 总体平方和 </span></span><br><span class="line">SST-SSE-SSR R_2 = SSR / SST</span><br><span class="line"><span class="comment">%注： mean() 是求均值的函数</span></span><br></pre></td></tr></table></figure><h1 id="强大的曲线拟合工具箱"><a href="#强大的曲线拟合工具箱" class="headerlink" title="强大的曲线拟合工具箱"></a>强大的曲线拟合工具箱</h1><h2 id="模拟数据代码"><a href="#模拟数据代码" class="headerlink" title="模拟数据代码"></a>模拟数据代码</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% （1）randi : 产生均匀分布的随机整数（i = int）  </span></span><br><span class="line"><span class="comment">%产生一个1至10之间的随机整数矩阵，大小为2x5；</span></span><br><span class="line">s1 = randi(<span class="number">10</span>,<span class="number">2</span>,<span class="number">5</span>)</span><br><span class="line"><span class="comment">%产生一个-5至5之间的随机整数矩阵，大小为1x10；</span></span><br><span class="line">s2 = randi([<span class="number">-5</span>,<span class="number">5</span>],<span class="number">1</span>,<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">%  （2） rand: 产生0至1之间均匀分布的随机数</span></span><br><span class="line"><span class="comment">%，产生一个0至1之间的随机矩阵大小为1x5；</span></span><br><span class="line">s3 = <span class="built_in">rand</span>(<span class="number">1</span>,<span class="number">5</span>)</span><br><span class="line"><span class="comment">%产生一个a至b之间的随机矩阵，大小为1x5；  % a + (b-a) * rand(1,5); 如：a,b = 2,5</span></span><br><span class="line">s4= <span class="number">2</span> + (<span class="number">5</span><span class="number">-2</span>) * <span class="built_in">rand</span>(<span class="number">1</span>,<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">% （3）normrnd:产生正态分布的随机数</span></span><br><span class="line"><span class="comment">%产生一个均值为0，标准差（方差开根号）为2的正态分布的随机矩阵，大小为3x4；</span></span><br><span class="line">s5 = normrnd(<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">% （4）roundn—任意位置四舍五入</span></span><br><span class="line"><span class="comment">% 0个位 1十位  2百位 -1小数点后一位  </span></span><br><span class="line">a = <span class="number">3.1415</span></span><br><span class="line">roundn(a,<span class="number">-2</span>)    <span class="comment">% ans   =  3.1400</span></span><br><span class="line">roundn(a,<span class="number">2</span>)      <span class="comment">% ans   =  0</span></span><br><span class="line">a =<span class="number">31415</span></span><br><span class="line">roundn(a,<span class="number">2</span>)   <span class="comment">% ans  = 31400</span></span><br><span class="line">roundn(<span class="number">5.5</span>,<span class="number">0</span>)  <span class="comment">%6</span></span><br><span class="line">roundn(<span class="number">5.5</span>,<span class="number">1</span>) <span class="comment">%10</span></span><br></pre></td></tr></table></figure><h2 id="模拟数据进行演示"><a href="#模拟数据进行演示" class="headerlink" title="模拟数据进行演示"></a>模拟数据进行演示</h2><p>$$<br>y_{i}=3e^{0.5x_{i}}-5+e_{i}<br>$$</p><p>xi是[0，10]上的均匀分布，$e^{i}$是标准正态分布的扰动项</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">clear;clc </span><br><span class="line">x = <span class="built_in">rand</span>(<span class="number">30</span>,<span class="number">1</span>) * <span class="number">10</span>;  <span class="comment">% x是0-10之间均匀分布的随机向量（30个样本）</span></span><br><span class="line">y = <span class="number">3</span> * <span class="built_in">exp</span>(<span class="number">0.5</span>*x) <span class="number">-5</span> + normrnd(<span class="number">0</span>,<span class="number">1</span>,<span class="number">30</span>,<span class="number">1</span>);</span><br><span class="line">cftool</span><br></pre></td></tr></table></figure><h1 id="优秀论文中的cftool运用"><a href="#优秀论文中的cftool运用" class="headerlink" title="优秀论文中的cftool运用"></a>优秀论文中的cftool运用</h1><p><img src="https://img2018.cnblogs.com/i-beta/1880713/202002/1880713-20200222205702214-2066682947.png" alt=""></p><p><img src="https://img2018.cnblogs.com/i-beta/1880713/202002/1880713-20200222205937627-99122113.png" alt=""></p><h1 id="cftool的‘骚’操作"><a href="#cftool的‘骚’操作" class="headerlink" title="cftool的‘骚’操作"></a>cftool的‘骚’操作</h1><p><img src="https://img2018.cnblogs.com/i-beta/1880713/202002/1880713-20200222210041030-1619619400.png" alt="# "></p><h1 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>根据data2中的中国人口数据，确定你认为最合适 的拟合函数，并说明原因。</p><h2 id="模型的建立"><a href="#模型的建立" class="headerlink" title="模型的建立"></a>模型的建立</h2><h3 id="拟合算法简介"><a href="#拟合算法简介" class="headerlink" title="拟合算法简介"></a>拟合算法简介</h3><p>拟合指的是已知一系列的点，通过调整某些函数的待定系数使该函数与已知点集的差别最小。如果待定函数是线性，就叫线性拟合，否则称为作非线性拟合。若表达式也可以是分段函数，这种情况下称作样条拟合。</p><h3 id="确定拟合函数"><a href="#确定拟合函数" class="headerlink" title="确定拟合函数"></a>确定拟合函数</h3><p>第一步：作出人口数量的散点图，结果如下图所示：</p><p><img src="https://img2018.cnblogs.com/i-beta/1880713/202002/1880713-20200222220120102-1161061232.png" alt=""></p><p>由图可知，人口数量曲线有明显的直线特征，故其函数表达式大致为y=kx+b。</p><h3 id="运用最小二乘法"><a href="#运用最小二乘法" class="headerlink" title="运用最小二乘法"></a>运用最小二乘法</h3><p><img src="https://img2018.cnblogs.com/i-beta/1880713/202002/1880713-20200222221708863-748528977.png" alt=""></p><h2 id="模型的求解"><a href="#模型的求解" class="headerlink" title="模型的求解"></a>模型的求解</h2><h3 id="MATLAB-求解最小二乘"><a href="#MATLAB-求解最小二乘" class="headerlink" title="MATLAB 求解最小二乘"></a>MATLAB 求解最小二乘</h3><p>利用MATLAB软件我们求得$k=702.4485,b=-1.2782×106$，拟合的结果如下图所示：</p><p><img src="https://img2018.cnblogs.com/i-beta/1880713/202002/1880713-20200222224538953-1564351990.png" alt=""></p><h3 id="利用cftool工具箱"><a href="#利用cftool工具箱" class="headerlink" title="利用cftool工具箱"></a>利用cftool工具箱</h3><p>​      cftool是一款强大的由线拟合工具，且使用起来方便快捷，为了保正拟合结果的准确性，我们利用cftool工具箱选取了一些常见的拟合函数，并进行对比分析，结果如下表所示：</p><p><img src="https://img2018.cnblogs.com/i-beta/1880713/202002/1880713-20200222223619840-531838033.png" alt=""></p><p>​       SSE越接近于0，说明误差越小即拟合的效果越好；对于线性模型，R2越接近于1，说明误差平方接近于0，拟的效果越好。但同时我们要考虑到<strong>函数的形式越简单越好</strong>，综合以上拟合结果，我们最终认为一次polynomial函数的拟合最为合适。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% 导入数据</span></span><br><span class="line">[~, ~, raw] = xlsread(<span class="string">'G:\数学建模学习材料\参考资料\清风数学建模\第1-14讲和番外篇的课件和代码(1月16日修订版本)\第1-14讲和番外篇课件和代码\第4讲.拟合\代码和例题数据\data2.xlsx'</span>,<span class="string">'Sheet1'</span>,<span class="string">'A2:B11'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 创建输出变量</span></span><br><span class="line">data = <span class="built_in">reshape</span>([raw&#123;:&#125;],<span class="built_in">size</span>(raw));</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 创建表</span></span><br><span class="line">data2 = <span class="built_in">table</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 将导入的数组分配给列变量名称</span></span><br><span class="line">x = data(:,<span class="number">1</span>);</span><br><span class="line">y = data(:,<span class="number">2</span>);</span><br><span class="line">cftool</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 画图与建模</span></span><br><span class="line"><span class="built_in">plot</span>(x,y,<span class="string">'o'</span>)</span><br><span class="line">xlabel(<span class="string">'年份'</span>)</span><br><span class="line">ylabel(<span class="string">'人口(万)'</span>)</span><br><span class="line">n = <span class="built_in">size</span>(x,<span class="number">1</span>);</span><br><span class="line">k = (n*sum(x.*y)-sum(x)*sum(y))/(n*sum(x.*x)-sum(x)*sum(x))</span><br><span class="line">b = (sum(x.*x)*sum(y)-sum(x)*sum(x.*y))/(n*sum(x.*x)-sum(x)*sum(x))</span><br><span class="line"><span class="built_in">hold</span> on <span class="comment">% 继续在之前的图形上来画图形</span></span><br><span class="line">grid on <span class="comment">% 显示网格线</span></span><br><span class="line">f=@(x) k*x+b;</span><br><span class="line">fplot(f,[<span class="built_in">min</span>(x)<span class="number">-1</span>,<span class="built_in">max</span>(x)+<span class="number">1</span>])</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">'样本数据'</span>,<span class="string">'拟合函数'</span>,<span class="string">'location'</span>,<span class="string">'SouthEast'</span>)</span><br><span class="line"></span><br><span class="line">y_hat = k*x+b; <span class="comment">% y的拟合值</span></span><br><span class="line">SSR = sum((y_hat-<span class="built_in">mean</span>(y)).^<span class="number">2</span>)  <span class="comment">% 回归平方和</span></span><br><span class="line">SSE = sum((y_hat-y).^<span class="number">2</span>) <span class="comment">% 误差平方和</span></span><br><span class="line">SST = sum((y-<span class="built_in">mean</span>(y)).^<span class="number">2</span>) <span class="comment">% 总体平方和</span></span><br><span class="line">SST-SSE-SSR   <span class="comment">% 5.6843e-14  =   5.6843*10^-14   matlab浮点数计算的一个误差</span></span><br><span class="line">R_2 = SSR / SST</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[fitresult, gof] = createFit(x, y)</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 清除临时变量</span></span><br><span class="line">clearvars data raw;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MATLAB </tag>
            
            <tag> 拟合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>插值算法</title>
      <link href="/2020/02/10/%E6%8F%92%E5%80%BC%E7%AE%97%E6%B3%95/"/>
      <url>/2020/02/10/%E6%8F%92%E5%80%BC%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>学习视频：<a href="https://www.bilibili.com/video/av20238704?from=search&seid=10609096604247370603" target="_blank" rel="noopener">【强烈推荐】清风：数学建模算法、编程和写作培训的视频课程以及Matlab</a></p><p>老师讲得很详细，很受用！！！</p><a id="more"></a><h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><p>数模比赛中，常常需要根据已知的函数点进行数据、模型的处理和分析，<strong>而有时候现有的数据是极少的，不足以支撑分析的进行，这时就需要使用一些数学的方法，“模拟产生”一些新的但又比较靠谱的值来满足需求</strong>，这就是插值的作用，另一个不常见的作用就是<strong>短期预测</strong>。</p><h1 id="一维插值问题"><a href="#一维插值问题" class="headerlink" title="一维插值问题"></a>一维插值问题</h1><p><img src="https://img2018.cnblogs.com/i-beta/1880713/202002/1880713-20200210203359690-1948654916.png" alt=""></p><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a><strong>定义</strong></h1><p><img src="https://img2018.cnblogs.com/i-beta/1880713/202002/1880713-20200210204849676-1145365091.png" alt=""></p><h1 id="方法分类"><a href="#方法分类" class="headerlink" title="方法分类"></a>方法分类</h1><p><img src="https://img2018.cnblogs.com/i-beta/1880713/202002/1880713-20200210204959260-1116979010.png" alt=""></p><p>本文重点介绍数学建模常用的两种方法：三次样条插值和分段三次埃尔米特插值</p><h1 id="插值多项式"><a href="#插值多项式" class="headerlink" title="插值多项式"></a>插值多项式</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><img src="https://img2018.cnblogs.com/i-beta/1880713/202002/1880713-20200210205639072-1480704591.png" alt=""></p><h2 id="拉格朗日插值法"><a href="#拉格朗日插值法" class="headerlink" title="拉格朗日插值法"></a>拉格朗日插值法</h2><p>方法主要有拉格朗日插值法，具体不介绍，它会出现龙波现象（在两端处波动极大,产生明显的震荡）。</p><p>但觉得可以出一个ACM题。</p><p><img src="https://img2018.cnblogs.com/i-beta/1880713/202002/1880713-20200210210308048-408439027.png" alt=""></p><p><img src="https://img2018.cnblogs.com/i-beta/1880713/202002/1880713-20200210210341110-26550961.png" alt=""></p><p><img src="https://img2018.cnblogs.com/i-beta/1880713/202002/1880713-20200210210416714-1696647176.png" alt=""></p><h1 id="分段线性插值"><a href="#分段线性插值" class="headerlink" title="分段线性插值"></a>分段线性插值</h1><ul><li>插值多项式次数高精度未必显著提高</li><li>插值多项式次数越高摄入误差可能显著增大</li></ul><p>如何提高插值精度呢<br>采用分段低次插值是一种办法</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><img src="https://img2018.cnblogs.com/i-beta/1880713/202002/1880713-20200210210601374-1955397938.png" alt=""></p><h2 id="牛顿插值法"><a href="#牛顿插值法" class="headerlink" title="牛顿插值法"></a>牛顿插值法</h2><p><img src="https://img2018.cnblogs.com/i-beta/1880713/202002/1880713-20200210210706073-1430257854.png" alt=""></p><h2 id="评价"><a href="#评价" class="headerlink" title="评价"></a>评价</h2><p> 与拉格朗日插值法相比，牛顿插 值法的计算过程具有继承性。 （牛顿插值法每次插值只和前n项 的值有关，这样每次只要在原来 的函数上添加新的项，就能够产 生新的函数） 但是牛顿插值也存在龙格现象的 问题。</p><h1 id="致命缺点"><a href="#致命缺点" class="headerlink" title="致命缺点"></a>致命缺点</h1><p>上面讲的两种插值仅仅要求插值多项式在插值节点处与被插函数有相等的函数值，<font color=red><strong>而这种插值多项式却不能全面反映被插值函数的性态</strong></font>。<br>然而在许多实际问题中，不仅要求插值函数与被插值函数在所有节点处有相同的函数值，<font color=red><strong>它也需要在一个或全部节点上插值多项式与被插函数有相同的低阶甚至高阶的导数值</strong></font>。<br>对于这些情况，拉格朗日插值和牛顿插值都不能满足</p><h1 id="埃尔米特-Hermite-插值"><a href="#埃尔米特-Hermite-插值" class="headerlink" title="埃尔米特(Hermite)插值"></a>埃尔米特(Hermite)插值</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><p><img src="https://img2018.cnblogs.com/i-beta/1880713/202002/1880713-20200210210950631-474635672.png" alt=""></p><p><font color=red><strong>保持播值曲线在节点处有切线（光滑），使插值函数和被插函数的密和程度更好。</strong></font></p><p>​       不但要求在节点上的函数值相等，而且还要求对应的导数值也相等,甚至要求 高阶导数也相等，满足这种要求的插值多项式就是埃尔米特插值多项式。</p><h2 id="缺点与改进"><a href="#缺点与改进" class="headerlink" title="缺点与改进"></a>缺点与改进</h2><p>​        直接使用Hermite插值得到的多项式次数较高，也存在着龙格现象， 因此在实际应用中，往往使用分段三次Hermite插值多项式(PCHIP)。</p><p>​        Matlab有内置的函数（实现过程已经帮我们封装好了，会调用就行了）： p = pchip(x,y,new_x)  </p><p>​       x是已知的样本点的横坐标;y是已知的样本点的纵坐标;new_x是要插入处对应的横坐标</p><h1 id="三次样条插值"><a href="#三次样条插值" class="headerlink" title="三次样条插值"></a>三次样条插值</h1><p><img src="https://img2018.cnblogs.com/i-beta/1880713/202002/1880713-20200210211319029-555521716.png" alt=""></p><p>Matlab有内置的函数： p = spline(x,y,new_x) </p><p> x是已知的样本点的横坐标;y是已知的样本点的纵坐标;new_x是要插入处对应的横坐标</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 分段三次埃尔米特插值</span></span><br><span class="line">x = -<span class="built_in">pi</span>:<span class="built_in">pi</span>; y = <span class="built_in">sin</span>(x); </span><br><span class="line">new_x = -<span class="built_in">pi</span>:<span class="number">0.1</span>:<span class="built_in">pi</span>;</span><br><span class="line">p = pchip(x,y,new_x);</span><br><span class="line"><span class="built_in">figure</span>(<span class="number">1</span>); <span class="comment">% 在同一个脚本文件里面，要想画多个图，需要给每个图编号，否则只会显示最后一个图哦~</span></span><br><span class="line"><span class="built_in">plot</span>(x, y, <span class="string">'o'</span>, new_x, p, <span class="string">'r-'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">% plot函数用法:</span></span><br><span class="line"><span class="comment">% plot(x1,y1,x2,y2) </span></span><br><span class="line"><span class="comment">% 线方式： - 实线 :点线 -. 虚点线 - - 波折线 </span></span><br><span class="line"><span class="comment">% 点方式： . 圆点  +加号  * 星号  x x形  o 小圆</span></span><br><span class="line"><span class="comment">% 颜色： y黄； r红； g绿； b蓝； w白； k黑； m紫； c青</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">% 三次样条插值和分段三次埃尔米特插值的对比</span></span><br><span class="line">x = -<span class="built_in">pi</span>:<span class="built_in">pi</span>; </span><br><span class="line">y = <span class="built_in">sin</span>(x); </span><br><span class="line">new_x = -<span class="built_in">pi</span>:<span class="number">0.1</span>:<span class="built_in">pi</span>;</span><br><span class="line">p1 = pchip(x,y,new_x);   <span class="comment">%分段三次埃尔米特插值</span></span><br><span class="line">p2 = spline(x,y,new_x);  <span class="comment">%三次样条插值</span></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">plot</span>(x,y,<span class="string">'o'</span>,new_x,p1,<span class="string">'r-'</span>,new_x,p2,<span class="string">'b-'</span>)</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">'样本点'</span>,<span class="string">'三次埃尔米特插值'</span>,<span class="string">'三次样条插值'</span>,<span class="string">'Location'</span>,<span class="string">'SouthEast'</span>)   <span class="comment">%标注显示在东南方向</span></span><br><span class="line"><span class="comment">% 说明：</span></span><br><span class="line"><span class="comment">% LEGEND(string1,string2,string3, …)</span></span><br><span class="line"><span class="comment">% 分别将字符串1、字符串2、字符串3……标注到图中，每个字符串对应的图标为画图时的图标。</span></span><br><span class="line"><span class="comment">% ‘Location’用来指定标注显示的位置</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">% n维数据的插值</span></span><br><span class="line"><span class="comment">% p = interpn(x1,x2,...,xn, y, new_x1,newx_2,...,new_xn, method) </span></span><br><span class="line"><span class="comment">% x1,x2,...,xn是已知的样本点的横坐标 y是已知的样本点的纵坐标坐标 </span></span><br><span class="line"><span class="comment">% new_x1,newx_2,...,new_xn是要插入点的横坐标 method是要插值的方法 </span></span><br><span class="line"><span class="comment">%‘linear’：线性插值（默认算法）； </span></span><br><span class="line"><span class="comment">%‘cubic’：三次插值； </span></span><br><span class="line"><span class="comment">%‘spline’： 三次样条插值法； ( 最为精准 ) </span></span><br><span class="line"><span class="comment">%‘nearest：最邻近插值算法。 </span></span><br><span class="line">x = -<span class="built_in">pi</span>:<span class="built_in">pi</span>; y = <span class="built_in">sin</span>(x); </span><br><span class="line">new_x = -<span class="built_in">pi</span>:<span class="number">0.1</span>:<span class="built_in">pi</span>;</span><br><span class="line">p = interpn (x, y, new_x, <span class="string">'spline'</span>);</span><br><span class="line"><span class="comment">% 等价于 p = spline(x, y, new_x);</span></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">plot</span>(x, y, <span class="string">'o'</span>, new_x, p, <span class="string">'r-'</span>)</span><br></pre></td></tr></table></figure><h1 id="小技巧：短期预测"><a href="#小技巧：短期预测" class="headerlink" title="小技巧：短期预测"></a>小技巧：短期预测</h1><p>根据过去10年的中国人口数据，预测接下来三年的人口数据</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">% 人口预测（注意：一般我们很少使用插值算法来预测数据，随着课程的深入，后面的章节会有更适合预测的算法供大家选择，例如灰色预测、拟合预测等）</span></span><br><span class="line">population=[<span class="number">133126</span>,<span class="number">133770</span>,<span class="number">134413</span>,<span class="number">135069</span>,<span class="number">135738</span>,<span class="number">136427</span>,<span class="number">137122</span>,<span class="number">137866</span>,<span class="number">138639</span>, <span class="number">139538</span>];</span><br><span class="line">year = <span class="number">2009</span>:<span class="number">2018</span>;</span><br><span class="line">p1 = pchip(year, population, <span class="number">2019</span>:<span class="number">2021</span>)  <span class="comment">%分段三次埃尔米特插值预测</span></span><br><span class="line">p2 = spline(year, population, <span class="number">2019</span>:<span class="number">2021</span>) <span class="comment">%三次样条插值预测</span></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">plot</span>(year, population,<span class="string">'o'</span>,<span class="number">2019</span>:<span class="number">2021</span>,p1,<span class="string">'r*-'</span>,<span class="number">2019</span>:<span class="number">2021</span>,p2,<span class="string">'bx-'</span>)</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">'样本点'</span>,<span class="string">'三次埃尔米特插值预测'</span>,<span class="string">'三次样条插值预测'</span>,<span class="string">'Location'</span>,<span class="string">'SouthEast'</span>)</span><br></pre></td></tr></table></figure><p><img src="https://img2018.cnblogs.com/i-beta/1880713/202002/1880713-20200210211856098-1662716305.png" alt=""></p><h1 id="建模实例"><a href="#建模实例" class="headerlink" title="建模实例"></a>建模实例</h1><p>MathorCup第六届A题淡水养殖池塘水华发生及池水净化处理</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%插值预测中间周的水体评价指标</span></span><br><span class="line">load Z.mat</span><br><span class="line">x=Z(<span class="number">1</span>,:); <span class="comment">%Z的第一行是星期Z: 1     3     5     7     9    11    13    15</span></span><br><span class="line">[n,m]=<span class="built_in">size</span>(Z);<span class="comment">%n为Z的行数，m为Z的列数</span></span><br><span class="line"><span class="comment">% 注意Matlab的数组中不能保存字符串，如果要生成字符串数组，就需要使用元胞数组，其用大括号&#123;&#125;定义和引用</span></span><br><span class="line">ylab=&#123;<span class="string">'周数'</span>,<span class="string">'轮虫'</span>,<span class="string">'溶氧'</span>,<span class="string">'COD'</span>,<span class="string">'水温'</span>,<span class="string">'PH值'</span>,<span class="string">'盐度'</span>,<span class="string">'透明度'</span>,<span class="string">'总碱度'</span>,<span class="string">'氯离子'</span>,<span class="string">'透明度'</span>,<span class="string">'生物量'</span>&#125;;  <span class="comment">% 等会要画的图形的标签</span></span><br><span class="line"><span class="built_in">disp</span>([<span class="string">'共有'</span> num2str(n<span class="number">-1</span>) <span class="string">'个指标要进行插值。'</span>])</span><br><span class="line"><span class="built_in">disp</span>(<span class="string">'正在对一号池三次埃尔米特插值，请等待'</span>)<span class="comment">%一号池共有十一组要插值的数据，算上星期所在的第一行，共十二行</span></span><br><span class="line">P=<span class="built_in">zeros</span>(<span class="number">11</span>,<span class="number">15</span>);<span class="comment">%对要储存数据的矩阵P赋予初值</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">2</span>:n<span class="comment">%从第二行开始都是要进行插值的指标</span></span><br><span class="line">    y=Z(<span class="built_in">i</span>,:);<span class="comment">%将每一行依次赋值给y</span></span><br><span class="line">    new_x=<span class="number">1</span>:<span class="number">15</span>;<span class="comment">%要进行插值的x</span></span><br><span class="line">    p1=pchip(x,y,new_x);<span class="comment">%调用三次埃尔米特插值函数</span></span><br><span class="line">    subplot(<span class="number">4</span>,<span class="number">3</span>,<span class="built_in">i</span><span class="number">-1</span>);<span class="comment">%将所有图依次变现在4*3的一幅大图上</span></span><br><span class="line">    <span class="built_in">plot</span>(x,y,<span class="string">'ro'</span>,new_x,p1,<span class="string">'-'</span>);<span class="comment">%画出每次循环处理后的图像</span></span><br><span class="line">    axis([<span class="number">0</span> <span class="number">15</span>,-<span class="built_in">inf</span>,<span class="built_in">inf</span>])  <span class="comment">%设置坐标轴的范围，这里设置横坐标轴0-15，纵坐标不变化</span></span><br><span class="line">    <span class="comment">%  xlabel('星期')%x轴标题</span></span><br><span class="line">    ylabel(ylab&#123;<span class="built_in">i</span>&#125;)<span class="comment">%y轴标题  这里是直接引用元胞数组中的字符串哦</span></span><br><span class="line">    P(<span class="built_in">i</span><span class="number">-1</span>,:)=p1;<span class="comment">%将每次插值之后的结果保存在P矩阵中       </span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">legend</span>(<span class="string">'原始数据'</span>,<span class="string">'三次埃尔米特插值数据'</span>,<span class="string">'Location'</span>,<span class="string">'SouthEast'</span>)<span class="comment">%加上标注，注意要手动在图中拖动标注到图片右下角哦</span></span><br><span class="line">P = [<span class="number">1</span>:<span class="number">15</span>; P]  <span class="comment">%把P的第一行加上周数</span></span><br></pre></td></tr></table></figure><p><img src="https://img2018.cnblogs.com/i-beta/1880713/202002/1880713-20200210213549522-1031823618.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MATLAB </tag>
            
            <tag> 插值 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>主成分分析</title>
      <link href="/2020/02/08/%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90/"/>
      <url>/2020/02/08/%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>学习视频：<a href="https://www.bilibili.com/video/av20238704?from=search&seid=10609096604247370603" target="_blank" rel="noopener">【强烈推荐】清风：数学建模算法、编程和写作培训的视频课程以及Matlab</a></p><p>老师讲得很详细，很受用！！！</p><a id="more"></a><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>  主成分分析(PrincipalComponentAnalysis,PCA)， 主成分分析是一种降维算法，它能将多个指标转换为少数几 个主成分，这些主成分是原始变量的线性组合，且彼此之间<strong>互不相关</strong>，其能反映出原始数据的大部分信息。一般来说， 当研究的问题涉及到多变量且变量之间存在很强的相关性时， 我们可考虑使用主成分分析的方法来对数据进行简化。</p><p><font color=red>主成分分析是把原来多个变量划为少数几个综合指标的一种统计分析方法。 </font></p><h1 id="降维"><a href="#降维" class="headerlink" title="降维"></a>降维</h1><p>降维是将高维度的数据（指标太多）保留下最重要的一些特征，去除噪声和不重要的特征，从而实现提升数据处理速度 的目的。 在实际的生产和应用中，降维在一定的信息损失范围内， 可以为我们节省大量的时间和成本。降维也成为应用非常广泛 的数据预处理方法。<br>降维具有如下一些优点：</p><ol><li>使得数据集更易使用； </li><li>降低算法的计算开销； </li><li>去除噪声； </li><li>使得结果容易理解。</li></ol><h1 id="数学思想"><a href="#数学思想" class="headerlink" title="数学思想"></a>数学思想</h1><p><img src="https://img2018.cnblogs.com/i-beta/1880713/202002/1880713-20200206214239775-1550520758.png" alt=""></p><p>每一行是一个样本，每一列是一个指标。</p><p><img src="https://img2018.cnblogs.com/i-beta/1880713/202002/1880713-20200206214637896-954877919.png" alt=""></p><p>PCA详细的证明过程可看视频：<a href="https://www.bilibili.com/video/av32709936" target="_blank" rel="noopener">https://www.bilibili.com/video/av32709936</a> （证明过程需要一定的多元统计基础和较强的线性代数基础）</p><h1 id="计算步骤"><a href="#计算步骤" class="headerlink" title="计算步骤"></a>计算步骤</h1><p><img src="https://img2018.cnblogs.com/i-beta/1880713/202002/1880713-20200206214952550-1193343662.png" alt=""></p><p>标准化目的是消除量纲，归一化目的是便于解释</p><p><img src="https://img2018.cnblogs.com/i-beta/1880713/202002/1880713-20200206215211851-2091278500.png" alt=""></p><p><img src="https://img2018.cnblogs.com/i-beta/1880713/202002/1880713-20200206215312315-946963875.png" alt=""></p><p><img src="https://img2018.cnblogs.com/i-beta/1880713/202002/1880713-20200206215422633-1595499626.png" alt=""></p><h1 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h1><h2 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h2><p><img src="https://img2018.cnblogs.com/i-beta/1880713/202002/1880713-20200207220353263-522051594.png" alt=""></p><h2 id="计算关键变量"><a href="#计算关键变量" class="headerlink" title="计算关键变量"></a>计算关键变量</h2><p>经过计算，相关系数矩阵的特征值、相应的特征向量以及贡献率列于下表： </p><p><img src="https://img2018.cnblogs.com/i-beta/1880713/202002/1880713-20200207220621167-832033612.png" alt=""></p><p>从表中可以看到前三个主成分的累计贡献率达85.9％&gt;80.0%，因此可以考虑 只取前面三个主成分，它们能够很好地概括原始变量。</p><p>corrcoef函数计算相关系数矩阵。</p><p>matlab球的特征值默认归一化。</p><p>贡献率的计算是根据特征值/特征值总和计算而来。</p><h2 id="写出主成分并简要分析"><a href="#写出主成分并简要分析" class="headerlink" title="写出主成分并简要分析"></a>写出主成分并简要分析</h2><p><img src="https://img2018.cnblogs.com/i-beta/1880713/202002/1880713-20200207221334131-2004494665.png" alt=""></p><p>$X_{i}$均是标准化后的指标，$x_{i}$：身高、坐高、胸围、手臂长、肋围和腰围</p><p>第一主成分$F_{1}$对所有（标准化）原始变量都有近似相等的正载荷，故称第一主成分为（身材）大小成分。<br>第二主成分$F_{2}$及在$X_{3}, X_{5}, X_{6}$。上有中等程度的正载荷，而在$X_{1}, X_{2}, X_{4}$上有中等程度的负载荷，称第二主成分为形状成分（或胖瘦成分）。<br>第三主成分$F_{3}$在$X_{2}$上有大的正载荷，在$X_{4}$上有大的负载荷，而在其余变量上的载荷都较小，可称第三主成分为臂长成分。<br>注：由于第三主成分的贡献率不高（7.65%）且实际意义也不太重要，因此我们也可以考虑只取前两个主成分进行分析。</p><h2 id="主成分分析的说明"><a href="#主成分分析的说明" class="headerlink" title="主成分分析的说明"></a>主成分分析的说明</h2><p>​       在主成分分析中，我们首先应保证所提取的前几个主成分的累计贡 献率达到一个较高的水平，其次对这些被提取的主成分必须都能够给出 符合实际背景和意义的解释。 </p><p><font color=red>主成分的解释其含义一般多少带有点模糊性，不像原始变量的含义 那么清楚、确切，这是变量降维过程中不得不付出的代价。</font></p><p>因此，提取 的主成分个数m通常应明显小于原始变量个数p（除非p本身较小），否 则维数降低的“利”可能抵不过主成分含义不如原始变量清楚的“弊”。 如果原始变量之间具有较高的相关性，则前面少数几个主成分的累 计贡献率通常就能达到一个较高水平，也就是说，此时的累计贡献率通 常较易得到满足。</p><p><font color=red> 主成分分析的困难之处主要在于要能够给出主成分的较好解释，所 提取的主成分中如有一个主成分解释不了，整个主成分分析也就失败了。</font></p><p> 主成分分析是变量降维的一种重要、常用的方法，简单的说，该方法要应用得成功，一是靠原始变量的合理选取，二是靠“运气”。</p><p>​                                                                                                                        ——参考教材：《应用多元统计分析》王学民</p><h2 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h2><p><img src="https://img2018.cnblogs.com/i-beta/1880713/202002/1880713-20200207222711335-722850948.png" alt=""></p><h2 id="计算关键变量-1"><a href="#计算关键变量-1" class="headerlink" title="计算关键变量"></a>计算关键变量</h2><p><img src="https://img2018.cnblogs.com/i-beta/1880713/202002/1880713-20200207222618265-65615481.png" alt=""></p><p>由上表可知，前两个主成分的累计贡献率已高达93.7%，第一主成分 F1在所有变量上有几乎相等的正载荷，可称为在径赛项目上的强弱成分。 第二主成分F2在各个指标上的载荷基本上逐个递减，反映了速度与耐力成绩的对比。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">clear;clc</span><br><span class="line"> load data1.mat   <span class="comment">% 主成分聚类</span></span><br><span class="line"><span class="comment">%  load data2.mat   % 主成分回归</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 注意，这里可以对数据先进行描述性统计</span></span><br><span class="line"><span class="comment">% 描述性统计的内容见第5讲.相关系数</span></span><br><span class="line">[n,p] = <span class="built_in">size</span>(x);  <span class="comment">% n是样本个数，p是指标个数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 第一步：对数据x标准化为X</span></span><br><span class="line">X=zscore(x);   <span class="comment">% matlab内置的标准化函数（x-mean(x)）/std(x)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 第二步：计算样本协方差矩阵</span></span><br><span class="line">R = cov(X);</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 注意：以上两步可合并为下面一步：直接计算样本相关系数矩阵</span></span><br><span class="line">R = corrcoef(x);</span><br><span class="line"><span class="built_in">disp</span>(<span class="string">'样本相关系数矩阵为：'</span>)</span><br><span class="line"><span class="built_in">disp</span>(R)</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 第三步：计算R的特征值和特征向量</span></span><br><span class="line"><span class="comment">% 注意：R是半正定矩阵，所以其特征值不为负数</span></span><br><span class="line"><span class="comment">% R同时是对称矩阵，Matlab计算对称矩阵时，会将特征值按照从小到大排列哦</span></span><br><span class="line"><span class="comment">% eig函数的详解见第一讲层次分析法的视频</span></span><br><span class="line">[V,D] = eig(R);  <span class="comment">% V 特征向量矩阵  D 特征值构成的对角矩阵</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 第四步：计算主成分贡献率和累计贡献率</span></span><br><span class="line">lambda = <span class="built_in">diag</span>(D);  <span class="comment">% diag函数用于得到一个矩阵的主对角线元素值(返回的是列向量)</span></span><br><span class="line">lambda = lambda(<span class="keyword">end</span>:<span class="number">-1</span>:<span class="number">1</span>);  <span class="comment">% 因为lambda向量是从小大到排序的，我们将其调个头</span></span><br><span class="line">contribution_rate = lambda / sum(lambda);  <span class="comment">% 计算贡献率</span></span><br><span class="line">cum_contribution_rate = cumsum(lambda)/ sum(lambda);   <span class="comment">% 计算累计贡献率  cumsum是求累加值的函数</span></span><br><span class="line"><span class="built_in">disp</span>(<span class="string">'特征值为：'</span>)</span><br><span class="line"><span class="built_in">disp</span>(lambda')  <span class="comment">% 转置为行向量，方便展示</span></span><br><span class="line"><span class="built_in">disp</span>(<span class="string">'贡献率为：'</span>)</span><br><span class="line"><span class="built_in">disp</span>(contribution_rate')</span><br><span class="line"><span class="built_in">disp</span>(<span class="string">'累计贡献率为：'</span>)</span><br><span class="line"><span class="built_in">disp</span>(cum_contribution_rate')</span><br><span class="line"><span class="built_in">disp</span>(<span class="string">'与特征值对应的特征向量矩阵为：'</span>)</span><br><span class="line"><span class="comment">% 注意：这里的特征向量要和特征值一一对应，之前特征值相当于颠倒过来了，因此特征向量的各列需要颠倒过来</span></span><br><span class="line"><span class="comment">%  rot90函数可以使一个矩阵逆时针旋转90度，然后再转置，就可以实现将矩阵的列颠倒的效果</span></span><br><span class="line">V=<span class="built_in">rot90</span>(V)';</span><br><span class="line"><span class="built_in">disp</span>(V)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 计算我们所需要的主成分的值</span></span><br><span class="line">m =input(<span class="string">'请输入需要保存的主成分的个数:  '</span>);</span><br><span class="line">F = <span class="built_in">zeros</span>(n,m);  <span class="comment">%初始化保存主成分的矩阵（每一列是一个主成分）</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:m</span><br><span class="line">    ai = V(:,<span class="built_in">i</span>)';   <span class="comment">% 将第i个特征向量取出，并转置为行向量</span></span><br><span class="line">    Ai = <span class="built_in">repmat</span>(ai,n,<span class="number">1</span>);   <span class="comment">% 将这个行向量重复n次，构成一个n*p的矩阵</span></span><br><span class="line">    F(:, <span class="built_in">i</span>) = sum(Ai .* X, <span class="number">2</span>);  <span class="comment">% 注意，对标准化的数据求了权重后要计算每一行的和</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% (1)主成分聚类 ： 将主成分指标所在的F矩阵复制到Excel表格，然后再用Spss进行聚类</span></span><br><span class="line"><span class="comment">% 在Excel第一行输入指标名称（F1,F2, ..., Fm）</span></span><br><span class="line"><span class="comment">% 双击Matlab工作区的F,进入变量编辑中，然后复制里面的数据到Excel表格</span></span><br><span class="line"><span class="comment">% 导出数据之后，我们后续的分析就可以在Spss中进行。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%%（2）主成分回归：将x使用主成分得到主成分指标，并将y标准化，接着导出到Excel，然后再使用Stata回归</span></span><br><span class="line"><span class="comment">% Y = zscore(y);  % 一定要将y进行标准化哦~</span></span><br><span class="line"><span class="comment">% 在Excel第一行输入指标名称（Y,F1, F2, ..., Fm）</span></span><br><span class="line"><span class="comment">% 分别双击Matlab工作区的Y和F,进入变量编辑中，然后复制里面的数据到Excel表格</span></span><br><span class="line"><span class="comment">% 导出数据之后，我们后续的分析就可以在Stata中进行。</span></span><br></pre></td></tr></table></figure><h3 id="对结果的解释"><a href="#对结果的解释" class="headerlink" title="对结果的解释"></a>对结果的解释</h3><p><img src="https://img2018.cnblogs.com/i-beta/1880713/202002/1880713-20200209162615718-63087979.png" alt=""></p><p>​       从上表可以看出，前两个和前三个主成分的累计贡献率分别达到80.6%和 87.8%，第一主成分F1在所有变量(除在x2上的载荷稍偏小外)上都有近似相等的 正载荷，反映了综合消费性支出的水平，因此第一主成分可称为综合消费性支出成分。第二主成分F2在变量x2上有很高的正载荷，在变量x4上有中等的正载 荷，而在其余变量上有负载荷或很小的正载荷。可以认为这个主成分度量了受 地区气候影响的消费性支出(主要是衣着，其次是医疗保健)在所有消费性支出 中占的比重(也可理解为一种消费倾向)，第二主成分可称为消费倾向成分。第 三主成分很难给出明显的解释，因此我们只取前面两个主成分。</p><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h2 id="主成分分析的滥用：主成分得分"><a href="#主成分分析的滥用：主成分得分" class="headerlink" title="主成分分析的滥用：主成分得分"></a>主成分分析的滥用：主成分得分</h2><p><img src="https://img2018.cnblogs.com/i-beta/1880713/202002/1880713-20200209162907162-1614401722.png" alt=""></p><p>除了王老师说的几点原因之外，</p><p>补充： </p><p>（1）主成分是降维算法，你既然已经有数据了，为什么不把这些数据的信息 全部用上呢？主成分分析是会损失原始数据的信息的。 </p><p>（2）指标可能有各种类型（极大、极小、区间等），主成分只有标准化的过 程，并没有正向化的过程。</p><h2 id="主成分分析用于聚类"><a href="#主成分分析用于聚类" class="headerlink" title="主成分分析用于聚类"></a>主成分分析用于聚类</h2><p>计算出第一主成分和第二主成分的值，将其视为两个新的指标 （可以在图上直观的展示各样本的分布情况）。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% 计算我们所需要的主成分的值</span></span><br><span class="line">m =input(<span class="string">'请输入需要保存的主成分的个数:  '</span>);</span><br><span class="line">F = <span class="built_in">zeros</span>(n,m);  <span class="comment">%初始化保存主成分的矩阵（每一列是一个主成分）</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:m</span><br><span class="line">    ai = V(:,<span class="built_in">i</span>)';   <span class="comment">% 将第i个特征向量取出，并转置为行向量</span></span><br><span class="line">    Ai = <span class="built_in">repmat</span>(ai,n,<span class="number">1</span>);   <span class="comment">% 将这个行向量重复n次，构成一个n*p的矩阵</span></span><br><span class="line">    F(:, <span class="built_in">i</span>) = sum(Ai .* X, <span class="number">2</span>);  <span class="comment">% 注意，对标准化的数据求了权重后要计算每一行的和</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% (1)主成分聚类 ： 将主成分指标所在的F矩阵复制到Excel表格，然后再用Spss进行聚类</span></span><br><span class="line"><span class="comment">% 在Excel第一行输入指标名称（F1,F2, ..., Fm）</span></span><br><span class="line"><span class="comment">% 双击Matlab工作区的F,进入变量编辑中，然后复制里面的数据到Excel表格</span></span><br><span class="line"><span class="comment">% 导出数据之后，我们后续的分析就可以在Spss中进行。</span></span><br></pre></td></tr></table></figure><p>将主成分指标所在的F矩阵复制到Excel表格，然后再用Spss进行聚类</p><ul><li><p>在Excel第一行输入指标名称（F1,F2, …, Fm）</p></li><li><p>双击Matlab工作区的F,进入变量编辑中，然后复制里面的数据到Excel表格</p></li><li><p>导出数据之后，我们后续的分析就可以在Spss中进行。</p></li></ul><h4 id="结果比较"><a href="#结果比较" class="headerlink" title="结果比较"></a>结果比较</h4><p><img src="https://img2018.cnblogs.com/i-beta/1880713/202002/1880713-20200209165216427-236777757.png" alt=""></p><p>聚类效果图</p><p><img src="https://img2018.cnblogs.com/i-beta/1880713/202002/1880713-20200209165401730-1688648428.png" alt=""></p><p>​     主成分聚类最大的意义就是能帮我们可视化最后的聚类效果，毕竟， 使用主成分是会降低部分信息的。言外之意，只有在指标个数特别多，且指标之间存在很强的相关性时才用主成分聚类。否则会损失很多信息。</p><h2 id="主成分回归"><a href="#主成分回归" class="headerlink" title="主成分回归"></a>主成分回归</h2><p>主成分回归可用来解决多重共线性的问题。</p><p>等我弄完多重共线性问题再补。</p>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MATLAB </tag>
            
            <tag> 降维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>聚类模型</title>
      <link href="/2020/02/08/%E8%81%9A%E7%B1%BB%E6%A8%A1%E5%9E%8B/"/>
      <url>/2020/02/08/%E8%81%9A%E7%B1%BB%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><a id="more"></a><p>聚类就是将样本划分为由类似的对象组成的多个类的过程。聚类后，我们可以更加准确的在每个类中<strong>单独</strong>使用统计模型进行估计、分析或预测；也可以探究<strong>不同类</strong>之间的相关性和主要差异。  </p><p><strong>聚类和分类的区别:分类是已知类别的，聚类未知。</strong></p><h1 id="具体算法"><a href="#具体算法" class="headerlink" title="具体算法"></a>具体算法</h1><h2 id="K-means聚类算法"><a href="#K-means聚类算法" class="headerlink" title="K-means聚类算法"></a>K-means聚类算法</h2><h3 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h3><ol><li><p>指定需要划分的簇[cù]的个数K值（<strong>类的个数</strong>）;</p></li><li><p>随机地选择K个数据对象作为初始的聚类中心<br>（不一定要是我们的样本点）;</p></li><li><p>计算其余的各个数据对象到这K个初始聚类中心的距离，把数据对象划归到距离它最近的那个中心所处在的簇类中;</p></li><li><p>调整新类并且重新计算出新类的中心;</p></li><li><p>五循环步骤3和4，看中心是否收敛（<strong>中心不变</strong>），如果收敛或达到迭代次数则停止循环;</p></li><li><p>结束。</p></li></ol><p>   K‐均值聚类可视化的网站： <a href="https://www.naftaliharris.com/blog/v" target="_blank" rel="noopener">https://www.naftaliharris.com/blog/v</a>  （强烈推荐试一下）</p><h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p><strong>论文可以画，清晰明了！</strong></p><p><img src="https://img2018.cnblogs.com/i-beta/1880713/202002/1880713-20200203205436849-1316240509.png" alt=""></p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：<br>（1）算法简单、快速。<br>（2）对处理大数据集，该算法是相对高效率的。<br>缺点：<br>（1）要求用户必须事先给出要生成的簇的数目K。<br><font color=red><strong>（2）严重依赖与初始簇中心的选择，对初值敏感。</strong></font><br><font color=red>*<em>（3）对于孤立点数据敏感。  *</em></font></p><p>*<em>K‐means++算法可解决2、 3两个缺点。  *</em></p><h2 id="K-means-算法"><a href="#K-means-算法" class="headerlink" title="K-means++算法"></a>K-means++算法</h2><h3 id="与K‐means-算法的区别"><a href="#与K‐means-算法的区别" class="headerlink" title="与K‐means++算法的区别"></a>与K‐means++算法的区别</h3><p>k-means++算法选择初始聚类中心的基本原则是： <strong>初始的聚类中心之间的相互距离要尽可能的远。</strong></p><p>算法描述如下：（<strong>只对K-means算法“初始化K个聚类中心” 这一步进行了优化</strong>）</p><ul><li>步骤一： 随机选取一个样本作为第一个聚类中心；</li><li>步骤二： 计算每个样本与当前已有聚类中心的最短距离（即与最近一个聚类中心的距离），这个值越大，表示被选取作为聚类中心的概率较大；最后，用轮盘法（依据概率大小来进行抽选）选出下一个聚类中心；</li><li>步骤三： 重复步骤二，直到选出K个聚类中心。选出初始点后，就继续使用标准的K-means算法了。  </li></ul><h3 id="Spss软件操作"><a href="#Spss软件操作" class="headerlink" title="Spss软件操作"></a>Spss软件操作</h3><p><img src="https://img2018.cnblogs.com/i-beta/1880713/202002/1880713-20200209170417275-267751449.png" alt=""></p><h3 id="K-means算法的一些讨论"><a href="#K-means算法的一些讨论" class="headerlink" title="K-means算法的一些讨论"></a>K-means算法的一些讨论</h3><ol><li><p>聚类的个数K值怎么定？<br>答：分几类主要取决于个人的经验与感觉，通常的做法是多尝试几个K值，看分成几类的结果更好解释(<strong>高消费与低消费，或者高消费、中消费与低消费</strong>），更符合分析目的等。</p></li><li><p>数据的量纲不一致怎么办？<br>答：如果数据的量纲不一样，那么算距离时就没有意义。例如：如果X1单位是米， X2单位是吨，用距离公式计算就会出现“米的平方”加上“吨的平方”再开平方，最后算出的东西没有数学意义，这就有问题了。</p><p>具体做法：先减去均值再除以标准差<br>$$<br>z_{i}=\frac{x_{i}-\overline x}{\delta _{x}}<br>$$</p></li></ol><p><img src="https://img2018.cnblogs.com/i-beta/1880713/202002/1880713-20200209170547739-911717523.png" alt=""></p><h2 id="系统（层次）聚类-可以查看k值"><a href="#系统（层次）聚类-可以查看k值" class="headerlink" title="系统（层次）聚类   (可以查看k值)"></a>系统（层次）聚类   (可以查看k值)</h2><p>​        系统聚类的合并算法通过计算两类数据点间的距离，对最为接近的两类数据点进行组合，并反复迭代这一过程，直到将所有数据点合成一类，并生成聚类谱系图。</p><p><img src="https://img2018.cnblogs.com/i-beta/1880713/202002/1880713-20200209190429663-34120259.png" alt=""></p><h3 id="算法流程-1"><a href="#算法流程-1" class="headerlink" title="算法流程"></a>算法流程</h3><p>系统（层次）聚类的算法流程： </p><ul><li>一、将每个对象看作一类，计算两两之间的最小距离； </li><li>二、将距离最小的两个类合并成一个新类； </li><li>三、重新计算新类与所有类之间的距离； </li><li>四、重复二三两步，直到所有类最后合并成一类；</li><li>五、结束。</li></ul><p>详细讲解参考：于晶贤‐辽宁石油化工大学‐聚类分析之系统聚类法.pdf</p><h3 id="常用距离（样品i与样品j）"><a href="#常用距离（样品i与样品j）" class="headerlink" title="常用距离（样品i与样品j）"></a>常用距离（样品i与样品j）</h3><p><img src="https://img2018.cnblogs.com/i-beta/1880713/202002/1880713-20200209192404296-931850462.png" alt=""></p><ul><li>绝对值距离：网状结构的距离</li><li>欧氏距离：一般就用欧式距离</li><li>Minkowski距离：</li><li>Chebyshev距离：</li><li>马氏距离：多元正太分布 </li></ul><h3 id="常用“距离”-（指标i与指标j）"><a href="#常用“距离”-（指标i与指标j）" class="headerlink" title="常用“距离” （指标i与指标j）"></a>常用“距离” （指标i与指标j）</h3><p><img src="https://img2018.cnblogs.com/i-beta/1880713/202002/1880713-20200210112852451-935713942.png" alt=""></p><h3 id="类与类之间的常用距离"><a href="#类与类之间的常用距离" class="headerlink" title="类与类之间的常用距离"></a>类与类之间的常用距离</h3><p>1.由一个样品组成的类是最基本的类；如果每一类都由<br>个样品组成，那么样品间的距离就是类间距离。<br>2.如果某一类包含不止一个样品，那么就要确定类间距<br>离，类间距离是基于样品间距离定义的，大致有如下几种</p><p><img src="https://img2018.cnblogs.com/i-beta/1880713/202002/1880713-20200210113204394-1831022087.png" alt=""></p><p><img src="https://img2018.cnblogs.com/i-beta/1880713/202002/1880713-20200210113430960-1273589814.png" alt=""></p><p><img src="C:%5CUsers%5C17861%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200210113511356.png" alt=""></p><h3 id="算法流程图"><a href="#算法流程图" class="headerlink" title="算法流程图"></a>算法流程图</h3><p><img src="C:%5CUsers%5C17861%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200210113711863.png" alt=""></p><h3 id="聚类分析需要注意的问题"><a href="#聚类分析需要注意的问题" class="headerlink" title="聚类分析需要注意的问题"></a>聚类分析需要注意的问题</h3><p>1.对于一个实际问题要根据分类的目的来选取指标，指标<br>选取的不同分类结果一般也不同。<br>2.样品间距离定义方式的不同，聚类结果一般也不同。<br>3.聚类方法的不同，聚类结果一般也不同（尤其是样品特别多的时候）。最好能通过各种方法找出其中的共性。<br>4.要注意指标的量纲，量纲差别太大会导致聚类结果不合<br>理。<br>5.聚类分析的结果可能不令人满意，因为我们所做的是一个数学的处理，对于结果我们要找到一个<font color=red>合理的解释</font>。  </p><h3 id="Spss软件操作-1"><a href="#Spss软件操作-1" class="headerlink" title="Spss软件操作"></a>Spss软件操作</h3><p><img src="https://img2018.cnblogs.com/i-beta/1880713/202002/1880713-20200210114601516-72749493.png" alt=""></p><h3 id="谱系图"><a href="#谱系图" class="headerlink" title="谱系图"></a>谱系图</h3><p><img src="https://img2018.cnblogs.com/i-beta/1880713/202002/1880713-20200210115127054-1986576250.png" alt=""></p><p>画竖线可以看清分为多少类。</p><h3 id="用图形估计聚类的数量"><a href="#用图形估计聚类的数量" class="headerlink" title="用图形估计聚类的数量"></a>用图形估计聚类的数量</h3><p><img src="https://img2018.cnblogs.com/i-beta/1880713/202002/1880713-20200210115421789-1284003418.png" alt=""></p><p><img src="https://img2018.cnblogs.com/i-beta/1880713/202002/1880713-20200210115916366-1372084416.png" alt=""></p><p>根据图来进行解释：<br>(1)根据聚合系数折线图可知，当类别数为5时，折线的下降趋势趋缓，故可将类别数设定为5.<br>(2)从图中可以看出， K值从1到5时，畸变程度变化最大。超过5以后，畸变程度变化显著降低。因此肘部就是 K=5，故可将类别数设定为5.（当然，K=3也可以解释）  </p><h3 id="确定K后保存聚类结果并画图"><a href="#确定K后保存聚类结果并画图" class="headerlink" title="确定K后保存聚类结果并画图"></a>确定K后保存聚类结果并画图</h3><p><img src="https://img2018.cnblogs.com/i-beta/1880713/202002/1880713-20200210120125176-1563715498.png" alt=""></p><p><img src="https://img2018.cnblogs.com/i-beta/1880713/202002/1880713-20200210120327459-1809391374.png" alt=""></p><p>注意： 只要当指标个数为2或者3的时候才能画图，上面两个图纯粹是为了演示作图过程，实际上本例中指标个数有8个，是不可能做出这样的图的  </p><h2 id="DBSCAN算法"><a href="#DBSCAN算法" class="headerlink" title="DBSCAN算法"></a>DBSCAN算法</h2><p>​            DBSCAN(Density-based spatial clustering of applications with noise)是Martin Ester, Hans-PeterKriegel等人于1996年提出的一种<strong>基于密度</strong>的聚类方法，聚类前不需要预先指定聚类的个数，生成的簇的个数不定（和数据有关）。该算法利用基于密度的聚类的概念，即要求聚类空间中的一定区域内所包含对象（点或其他空间对象）的数目不小于某一给定阈值。该方法能在具有噪声的空间数据库中发现任意形状的簇，可将密度足够大的相邻区域连接，能有效处理异常数据。  </p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>DBSCAN算法将数据点分为三类：<br>• 核心点：在半径Eps内含有不少于MinPts数目的点<br>• 边界点：在半径Eps内点的数量小于MinPts，但是落在核心点的邻域内<br>• 噪音点：既不是核心点也不是边界点的点  </p><p><img src="https://img2018.cnblogs.com/i-beta/1880713/202002/1880713-20200210121404108-1727397712.png" alt=""></p><p>​        在这幅图里，MinPts = 4，点 A 和其他红色点是核心点，因为它们的 ε-邻域（图中红色圆圈）里包含最少 4 个点（包括自己），由于它们之间相互相可达，它们形成了一个聚类。点 B 和点 C 不是核心点，但它们可由 A 经其他核心点可达，所以也和A属于同一个聚类。点 N 是局点，它既不是核心点，又不由其他点可达。  </p><h3 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h3><p><a href="https://www.naftaliharris.com/blog/visualizing‐dbscan‐clustering/" target="_blank" rel="noopener">DBSCAN算法可视化  </a></p><h3 id="Matlab代码"><a href="#Matlab代码" class="headerlink" title="Matlab代码"></a>Matlab代码</h3><p>Matlab官网推荐下载的代码：<br><a href="https://ww2.mathworks.cn/matlabcentral/fileexchange/52905‐dbscan‐clustering‐algorithm" target="_blank" rel="noopener">https://ww2.mathworks.cn/matlabcentral/fileexchange/52905‐dbscan‐clustering‐algorithm</a>  </p><h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p><ol><li>基于密度定义，能处理任意形状和大小的簇；</li><li>可在聚类的同时发现异常点；</li><li>与K-means比较起来，不需要输入要划分的聚类个数。</li></ol><p>缺点：</p><ol><li><p>对输入参数ε和Minpts敏感，确定参数困难；</p></li><li><p>由于DBSCAN算法中，变量ε和Minpts是全局唯一的,当聚类的密度不均匀时，聚类距离相差很大时，聚类质量差；</p></li><li><p>当数据量大时，计算密度单元的计算复杂度大。</p></li></ol><p>我的建议：</p><ol><li>只有两个指标，且你做出散点图后发现数据表现得很“DBSCAN”，这时候你再用DNSCAN进行聚类。其他情况下，全部使用系统聚类吧。</li><li>K‐means也可以用，不过用了的话你论文上可写的东西比较少。  </li></ol><h2 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h2><p>完成一篇论文作业，“各国森林、草原资源聚类.doc”，提示：指标共三个，量纲不同哦，论文中要交代清楚K的选择，当然你也可以画出你的聚类结果的三维图。  </p><ol><li><p>把作业表格复制到excel，用spss软件直接打开即可。</p></li><li><p>归一化变量</p><p><img src="https://img2018.cnblogs.com/i-beta/1880713/202002/1880713-20200210153312391-1367375799.png" alt=""></p><p><img src="https://img2018.cnblogs.com/i-beta/1880713/202002/1880713-20200210153432263-2026649140.png" alt=""></p></li><li><p>使用系统聚类和肘部法则确定聚类个数</p><p><img src="https://img2018.cnblogs.com/i-beta/1880713/202002/1880713-20200210153849658-790959166.png" alt=""></p><p><img src="https://img2018.cnblogs.com/i-beta/1880713/202002/1880713-20200210153555034-2130091459.png" alt=""></p><p>在spss复制一下聚类系数</p><p><img src="https://img2018.cnblogs.com/i-beta/1880713/202002/1880713-20200210153957395-449784315.png" alt=""></p><p>复制到ECXCEL表里面去。</p><p><img src="https://img2018.cnblogs.com/i-beta/1880713/202002/1880713-20200210154432903-1173598575.png" alt=""></p><p>通过对图像的观察分析，可以得出当聚类中心个数为4时，其聚合系数变化较大，所以选取聚类中心个数K=4。</p></li><li><p>真正的开始系统聚类(kmeans也行)</p><p><img src="https://img2018.cnblogs.com/i-beta/1880713/202002/1880713-20200210154952889-1302762691.png" alt=""></p><p>5.做散点图</p></li></ol><p><img src="https://img2018.cnblogs.com/i-beta/1880713/202002/1880713-20200210120125176-1563715498.png" alt=""></p><p><img src="https://img2018.cnblogs.com/i-beta/1880713/202002/1880713-20200210160229016-288145526.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MATLAB </tag>
            
            <tag> spss </tag>
            
            <tag> K-means </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python蓝桥杯技巧</title>
      <link href="/2020/02/08/python%E8%93%9D%E6%A1%A5%E6%9D%AF%E6%8A%80%E5%B7%A7/"/>
      <url>/2020/02/08/python%E8%93%9D%E6%A1%A5%E6%9D%AF%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="排序（自定义类）"><a href="#排序（自定义类）" class="headerlink" title="排序（自定义类）"></a>排序（自定义类）</h1><a id="more"></a><h2 id="1-cmp函数"><a href="#1-cmp函数" class="headerlink" title="1.cmp函数"></a>1.cmp函数</h2><p>第一种方法我们还是以重写cmp或lambda表达式的形式，和Python2很类似</p><p><font color=red>注意，此方法用sorted是不能成功排序的</font></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,ch,l,idd)</span>:</span></span><br><span class="line">        self.ch=ch</span><br><span class="line">        self.l=l</span><br><span class="line">        self.idd=idd</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> str(ch)+<span class="string">" "</span>+str(l)</span><br><span class="line">   </span><br><span class="line"><span class="comment">##    def __lt__(self,other):</span></span><br><span class="line"><span class="comment">##        return self.ch*self.l&lt; other.ch*other.l</span></span><br><span class="line"><span class="comment">##</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cmp</span><span class="params">(x,y)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> x.ch*x.l &gt; y.ch*y.l:<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> x.ch*x.l == y.ch*y.l: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">a=[]</span><br><span class="line">n=int(input())</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,n):</span><br><span class="line">    s=input()</span><br><span class="line">    ch=ord(s[<span class="number">0</span>])-ord(<span class="string">'a'</span>)+<span class="number">1</span></span><br><span class="line">    l=len(s)</span><br><span class="line">    t=Node(ch,l,<span class="number">0</span>)</span><br><span class="line">    a.append(t)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#a.sort(key=functools.cmp_to_key(cmp))</span></span><br><span class="line">a.sort(key=<span class="keyword">lambda</span> node:node.ch*node.l)</span><br><span class="line"></span><br><span class="line">i=<span class="number">0</span></span><br><span class="line">ans=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> it <span class="keyword">in</span> a: </span><br><span class="line">    i+=<span class="number">1</span></span><br><span class="line">    <span class="comment">#print(str(it.ch)+" "+str(it.l))</span></span><br><span class="line">    ans+=it.ch*it.l*i</span><br><span class="line">print(ans)</span><br></pre></td></tr></table></figure><h2 id="2-重写类方法"><a href="#2-重写类方法" class="headerlink" title="2.重写类方法"></a>2.重写类方法</h2><p>Python2中可以直接重写<strong>cmp</strong>方法来实现比较，但是Python3中已经取消了.</p><p>Python3中需要细分每一个比较运算符.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__lt__: &lt;</span><br><span class="line">__gt__: &gt;</span><br><span class="line">__ge__: &gt;=</span><br><span class="line">__eq__: ==</span><br><span class="line">__le__: &lt;=</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,ch,l,idd)</span>:</span></span><br><span class="line">        self.ch=ch</span><br><span class="line">        self.l=l</span><br><span class="line">        self.idd=idd</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__lt__</span><span class="params">(self,other)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.ch*self.l&lt;= other.ch*other.l</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">p</span><span class="params">()</span>:</span></span><br><span class="line">        print(str(self.ch)+<span class="string">" "</span>+str(self.l)+<span class="string">" "</span>+str(self.idd))</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">a=[]</span><br><span class="line">n=int(input())</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,n):</span><br><span class="line">    s=input()</span><br><span class="line">    ch=ord(s[<span class="number">0</span>])-ord(<span class="string">'a'</span>)+<span class="number">1</span></span><br><span class="line">    l=len(s)</span><br><span class="line">    t=Node(ch,l,<span class="number">0</span>)</span><br><span class="line">    a.append(t)</span><br><span class="line"><span class="comment">#print( c + " 的ASCII 码为", ord(c))</span></span><br><span class="line"><span class="comment">#print( a , " 对应的字符为", chr(a))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#print(a)</span></span><br><span class="line">a.sort()</span><br><span class="line">i=<span class="number">0</span></span><br><span class="line">ans=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> it <span class="keyword">in</span> a: </span><br><span class="line">    i+=<span class="number">1</span></span><br><span class="line">    <span class="comment">#print(str(it.ch)+" "+str(it.l))</span></span><br><span class="line">    ans+=it.ch*it.l*i</span><br><span class="line">print(ans)</span><br></pre></td></tr></table></figure><h1 id="ord-与chr"><a href="#ord-与chr" class="headerlink" title="ord()与chr()"></a>ord()与chr()</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#print( c + " 的ASCII 码为", ord(c)) </span></span><br><span class="line"></span><br><span class="line"><span class="comment">#print( a , " 对应的字符为", chr(a))</span></span><br></pre></td></tr></table></figure><h1 id="map（字典：defaultdict）"><a href="#map（字典：defaultdict）" class="headerlink" title="map（字典：defaultdict）"></a>map（字典：defaultdict）</h1><p>​       使用普通的字典时，用法一般是dict={},添加元素的只需要dict[element] =value即，调用的时候也是如此，dict[element] = xxx,但前提是element字典里，如果不在字典里就会报错。</p><p>​       defaultdict的作用是在于，当字典里的key不存在但被查找时，返回的不是keyError而是一个默认值，返回的是工厂函数的默认值，比如list对应[ ]，str对应的是空字符串，set对应set( )，int对应0，如下举例：</p><p>值，比如list对应[ ]，str对应的是空字符串，set对应set( )，int对应0，如下举例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line">dict1 = defaultdict(int)</span><br><span class="line">dict2 = defaultdict(set)</span><br><span class="line">dict3 = defaultdict(str)</span><br><span class="line">dict4 = defaultdict(list)</span><br><span class="line">dict1[<span class="number">2</span>] =<span class="string">'two'</span></span><br><span class="line"></span><br><span class="line">print(dict1[<span class="number">1</span>])</span><br><span class="line">print(dict2[<span class="number">1</span>])</span><br><span class="line">print(dict3[<span class="number">1</span>])</span><br><span class="line">print(dict4[<span class="number">1</span>])</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="keyword">set</span>()</span><br><span class="line"></span><br><span class="line">[<span class="meta"></span>]</span><br></pre></td></tr></table></figure><h1 id="dfs-字典"><a href="#dfs-字典" class="headerlink" title="dfs+字典"></a>dfs+字典</h1><p>t题目：<a href="http://oj.hzjingma.com/contest/problem?id=20&amp;pid=8&amp;_pjax=%23p0" target="_blank" rel="noopener">http://oj.hzjingma.com/contest/problem?id=20&amp;pid=8&amp;_pjax=%23p0</a></p><h2 id="I-试题I：对称迷宫-25’"><a href="#I-试题I：对称迷宫-25’" class="headerlink" title="I. 试题I：对称迷宫 25’"></a>I. 试题I：对称迷宫 25’</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>用EXCEL求解迷宫真香~</p><p>wlxsq有一个N<em>N</em>N<em>∗</em>N*的网格迷宫，每一个网格都有一个字母编号。</p><p>他要从左上角(1,1)(1,1)出发，走到右下角(n,n)(<em>n</em>,<em>n</em>)，由于wlxsq很懒，所以他每次只会往右或者往下走一格。</p><p>由于最后到终点的路径方案太多太多了，所以wlxsq想让你计算出所有<strong>不同的</strong>对称的路径个数。</p><p>例如:N = 3<em>N</em>=3</p><p>ABA</p><p>BBB</p><p>ABA</p><p>对称路径6条：有ABABA(2条)、ABBBA(4条)</p><p>不同的对称路径有: 有ABABA、ABBBA</p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>第一行输入一个数N<em>N</em>，表示迷宫的大小。</p><p>接下来输入N<em>N</em>N<em>∗</em>N*的字母迷宫</p><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>输出对称路径的数量</p><h3 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h3><h4 id="输入复制"><a href="#输入复制" class="headerlink" title="输入复制"></a>输入复制</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">ABA</span><br><span class="line">BBB</span><br><span class="line">ABA</span><br></pre></td></tr></table></figure><h4 id="输出复制"><a href="#输出复制" class="headerlink" title="输出复制"></a>输出复制</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><p>【评测用例规模与约定】</p><p>对于40%40%的数据，2&lt;=N&lt;=112&lt;=<em>N</em>&lt;=11</p><p>对于100%100%的数据，2&lt;=N&lt;=182&lt;=<em>N</em>&lt;=18</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>折半搜索而已，但要注意到达对角线的时候需要记录的是这个对角线上的点坐标和路径，不然无法拼凑成一条路。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line">dx=[<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>]</span><br><span class="line">dy=[<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">dic=defaultdict(int)</span><br><span class="line">n=int(input())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs1</span><span class="params">(x,y,step,path)</span>:</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> x+y==n<span class="number">-1</span>:</span><br><span class="line">        dic[path]=<span class="number">1</span></span><br><span class="line">        vis[x][path]=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">2</span>):</span><br><span class="line">        <span class="keyword">if</span> x+dx[i]&lt;n <span class="keyword">and</span> x+dx[i]&gt;=<span class="number">0</span> <span class="keyword">and</span> y+dy[i]&lt;n <span class="keyword">and</span> y+dy[i]&gt;=<span class="number">0</span> :</span><br><span class="line">            dfs1(x+dx[i],y+dy[i],step+<span class="number">1</span>,path+mp[x+dx[i]][y+dy[i]])</span><br><span class="line">        </span><br><span class="line">   </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">ans=int(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs2</span><span class="params">(x,y,step,path)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> ans</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> x+y==n<span class="number">-1</span>:</span><br><span class="line">        <span class="keyword">if</span> dic[path]==<span class="number">1</span> <span class="keyword">and</span> vis[x][path]==<span class="number">1</span> :</span><br><span class="line">            ans+=<span class="number">1</span></span><br><span class="line">            dic[path]=<span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,<span class="number">4</span>):</span><br><span class="line">      <span class="keyword">if</span> x+dx[i]&lt;n <span class="keyword">and</span> x+dx[i]&gt;=<span class="number">0</span> <span class="keyword">and</span> y+dy[i]&lt;n <span class="keyword">and</span> y+dy[i]&gt;=<span class="number">0</span> :</span><br><span class="line">            dfs2(x+dx[i],y+dy[i],step+<span class="number">1</span>,path+mp[x+dx[i]][y+dy[i]])</span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mp=[str(<span class="string">""</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">vis=[defaultdict(int) <span class="keyword">for</span> j <span class="keyword">in</span> range(n)]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,n):</span><br><span class="line">    mp[i]=input()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dfs1(<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="string">""</span>+mp[<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">dfs2(n<span class="number">-1</span>,n<span class="number">-1</span>,<span class="number">1</span>,<span class="string">""</span>+mp[n<span class="number">-1</span>][n<span class="number">-1</span>])</span><br><span class="line">print(ans)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line">dx=[<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>]</span><br><span class="line">dy=[<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">dic=defaultdict(int)</span><br><span class="line">path=<span class="string">""</span></span><br><span class="line"></span><br><span class="line">n=int(input())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs1</span><span class="params">(x,y,step)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> path</span><br><span class="line">    path+=mp[x][y]</span><br><span class="line">    <span class="keyword">if</span> step==n:</span><br><span class="line">        dic[path]=<span class="number">1</span></span><br><span class="line">        vis[x][path]=<span class="number">1</span></span><br><span class="line">        path=path[:len(path)<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">2</span>):</span><br><span class="line">        <span class="keyword">if</span> x+dx[i]&lt;n <span class="keyword">and</span> x+dx[i]&gt;=<span class="number">0</span> <span class="keyword">and</span> y+dy[i]&lt;n <span class="keyword">and</span> y+dy[i]&gt;=<span class="number">0</span> :</span><br><span class="line">            dfs1(x+dx[i],y+dy[i],step+<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">    path=path[:len(path)<span class="number">-1</span>]</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">ans=int(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs2</span><span class="params">(x,y,step)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> path,ans</span><br><span class="line">    path+=mp[x][y]</span><br><span class="line">    <span class="keyword">if</span> step==n:</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> dic[path]==<span class="number">1</span> <span class="keyword">and</span> vis[x][path]==<span class="number">1</span>:</span><br><span class="line">           ans+=<span class="number">1</span></span><br><span class="line">           dic[path]=<span class="number">0</span></span><br><span class="line">        path=path[:len(path)<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,<span class="number">4</span>):</span><br><span class="line">      <span class="keyword">if</span> x+dx[i]&lt;n <span class="keyword">and</span> x+dx[i]&gt;=<span class="number">0</span> <span class="keyword">and</span> y+dy[i]&lt;n <span class="keyword">and</span> y+dy[i]&gt;=<span class="number">0</span> :</span><br><span class="line">            dfs2(x+dx[i],y+dy[i],step+<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">    path=path[:len(path)<span class="number">-1</span>]</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mp=[str(<span class="string">""</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">vis=[defaultdict(int) <span class="keyword">for</span> j <span class="keyword">in</span> range(n)]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,n):</span><br><span class="line">    mp[i]=input()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dfs1(<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">dfs2(n<span class="number">-1</span>,n<span class="number">-1</span>,<span class="number">1</span>)</span><br><span class="line">print(ans)</span><br></pre></td></tr></table></figure><h1 id="eval-函数"><a href="#eval-函数" class="headerlink" title="eval() 函数"></a>eval() 函数</h1><h2 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h2><p>eval() 函数用来执行一个字符串表达式，并返回表达式的值。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>以下是 eval() 方法的语法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eval(expression[, globals[, locals]])</span><br></pre></td></tr></table></figure><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ul><li>expression – 表达式。</li><li>globals – 变量作用域，全局命名空间，如果被提供，则必须是一个字典对象。</li><li>locals – 变量作用域，局部命名空间，如果被提供，可以是任何映射对象。</li></ul><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>返回表达式计算结果。</p><hr><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>以下展示了使用 eval() 方法的实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;x = <span class="number">7</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>eval( <span class="string">'3 * x'</span> )</span><br><span class="line"><span class="number">21</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>eval(<span class="string">'pow(2,2)'</span>)</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>eval(<span class="string">'2 + 2'</span>)</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>n=<span class="number">81</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>eval(<span class="string">"n + 4"</span>)</span><br><span class="line"><span class="number">85</span></span><br></pre></td></tr></table></figure><h1 id="解一元一次方程"><a href="#解一元一次方程" class="headerlink" title="解一元一次方程"></a>解一元一次方程</h1><p>题目：<a href="http://oj.hzjingma.com/contest/problem?id=20&amp;pid=7" target="_blank" rel="noopener">http://oj.hzjingma.com/contest/problem?id=20&amp;pid=7</a></p><h2 id="H-H：计算器-22’"><a href="#H-H：计算器-22’" class="headerlink" title="H. H：计算器 22’"></a>H. H：计算器 22’</h2><h3 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h3><p>我们知道，windows自带calc功能。</p><p>wlxsq决定制作一个Calc，该Calc具备求解一元一次方程的功能。</p><p>为了简化工作，拒绝花里胡哨。这个方程中，只有一个等号”=”，零个或多个加号”+”、减号”-“，一种小写字母表示未知数。当然，减号也可是负号</p><p>方程中并没有括号，也没有除号，方程中的字母表示未知数。</p><h3 id="输入-1"><a href="#输入-1" class="headerlink" title="输入"></a>输入</h3><p>仅一行，表示一个合法的方程，包含“+”、“-”、“=”、数字及小写字母。</p><h3 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h3><p>仅一行，表示答案，形式为“未知元=答案”。对答案保留3位小数，保证答案的绝对值不超过10000。</p><h3 id="样例-1"><a href="#样例-1" class="headerlink" title="样例"></a>样例</h3><h4 id="输入复制-1"><a href="#输入复制-1" class="headerlink" title="输入复制"></a>输入复制</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2a&#x3D;1</span><br></pre></td></tr></table></figure><h4 id="输出复制-1"><a href="#输出复制-1" class="headerlink" title="输出复制"></a>输出复制</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a&#x3D;0.500</span><br></pre></td></tr></table></figure><h4 id="输入复制-2"><a href="#输入复制-2" class="headerlink" title="输入复制"></a>输入复制</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-5+2x&#x3D;-10</span><br></pre></td></tr></table></figure><h4 id="输出复制-2"><a href="#输出复制-2" class="headerlink" title="输出复制"></a>输出复制</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x&#x3D;-2.500</span><br></pre></td></tr></table></figure><h3 id="提示-1"><a href="#提示-1" class="headerlink" title="提示"></a>提示</h3><p>【评测用例规模与约定】</p><p> 对于20%的数据，输入数据没有”+,-“符号</p><p>  对于100%数据，长度不超过255，数字不超过10000，保证只出现一种小写字母。</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solve</span><span class="params">(eq,var=<span class="string">'x'</span>)</span>:</span></span><br><span class="line">    eq1 = eq.replace(<span class="string">"="</span>,<span class="string">"-("</span>)  +  <span class="string">")"</span></span><br><span class="line">    eq1 = eq1.replace(<span class="string">"x"</span>,<span class="string">"*x"</span>)</span><br><span class="line">    eq1 = eq1.replace(<span class="string">"+*x"</span>,<span class="string">"+x"</span>)</span><br><span class="line">    eq1 = eq1.replace(<span class="string">"-*x"</span>,<span class="string">"-x"</span>)</span><br><span class="line">    eq1 = eq1.replace(<span class="string">"(*x"</span>,<span class="string">"(x"</span>)</span><br><span class="line">    <span class="keyword">if</span> eq1[<span class="number">0</span>] == <span class="string">'*'</span>:</span><br><span class="line">        eq1 = eq1[<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    c = eval(eq1,&#123;var:<span class="number">1j</span>&#125;)</span><br><span class="line">    <span class="comment">#将x = 1j代入算式，结果是-9708+3j</span></span><br><span class="line">    <span class="keyword">if</span> c.real!=<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> -c.real/c.imag</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">test = input()</span><br><span class="line">ch = <span class="string">'x'</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(test)):</span><br><span class="line">    <span class="keyword">if</span> ord(<span class="string">'a'</span>) &lt;= ord(test[i]) &lt;= ord(<span class="string">'z'</span>):</span><br><span class="line">        ch = test[i]</span><br><span class="line">        test = test.replace(test[i],<span class="string">'x'</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">print(<span class="string">"%s=%.3lf"</span>%(ch,solve(test)))</span><br></pre></td></tr></table></figure><h1 id="快排的思想求第k大的数"><a href="#快排的思想求第k大的数" class="headerlink" title="快排的思想求第k大的数"></a>快排的思想求第k大的数</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#给定一个无序列表，求出第K大的元素，要求复杂度O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_k</span><span class="params">(test_list,k)</span>:</span></span><br><span class="line">    flag=test_list[<span class="number">0</span>]</span><br><span class="line">    test_list.pop(<span class="number">0</span>)</span><br><span class="line">    l_list=[i <span class="keyword">for</span> i <span class="keyword">in</span> test_list <span class="keyword">if</span> i &lt; flag]</span><br><span class="line">    r_list=[i <span class="keyword">for</span> i <span class="keyword">in</span> test_list <span class="keyword">if</span> i &gt;= flag]</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#结果递归的基线条件</span></span><br><span class="line">    <span class="keyword">if</span> len(r_list)==k<span class="number">-1</span>:</span><br><span class="line">        <span class="keyword">return</span> flag</span><br><span class="line">    <span class="keyword">elif</span> len(r_list)&gt;k<span class="number">-1</span>:</span><br><span class="line">        <span class="keyword">return</span> find_k(r_list,k)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment">#因为test_list.pop(0)让test_list少了一个元素，所以下面需要+1</span></span><br><span class="line">        gap=len(test_list)-len(l_list)+<span class="number">1</span></span><br><span class="line">        k=k-gap</span><br><span class="line">        <span class="keyword">return</span> find_k(l_list,k)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    test_list = [<span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>,<span class="number">10</span>,<span class="number">20</span>,<span class="number">100</span>]</span><br><span class="line">    res=find_k(test_list,<span class="number">1</span>)</span><br><span class="line">    print(res)</span><br></pre></td></tr></table></figure><h1 id="enumerate-函数"><a href="#enumerate-函数" class="headerlink" title="enumerate() 函数"></a>enumerate() 函数</h1><p>enumerate() 函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中。</p><h2 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h2><p>以下是 enumerate() 方法的语法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enumerate(sequence, [start&#x3D;0])</span><br></pre></td></tr></table></figure><h2 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h2><ul><li>sequence – 一个序列、迭代器或其他支持迭代对象。</li><li>start – 下标起始位置。</li></ul><h2 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h2><p>返回 enumerate(枚举) 对象。</p><h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">seq = [<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span>]</span><br><span class="line"><span class="keyword">for</span> i, element <span class="keyword">in</span> enumerate(seq):</span><br><span class="line">    <span class="keyword">print</span> i, element</span><br><span class="line"> </span><br><span class="line"><span class="number">0</span> one</span><br><span class="line"><span class="number">1</span> two</span><br><span class="line"><span class="number">2</span> three</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 奇淫异巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2017D美赛论文解析(减少机场安全等待时间)</title>
      <link href="/2020/01/30/%E7%BE%8E%E8%B5%9B2017D%E8%AE%BA%E6%96%87%E5%88%86%E6%9E%90-%E5%87%8F%E5%B0%91%E6%9C%BA%E5%9C%BA%E5%AE%89%E5%85%A8%E7%AD%89%E5%BE%85%E6%97%B6%E9%97%B4/"/>
      <url>/2020/01/30/%E7%BE%8E%E8%B5%9B2017D%E8%AE%BA%E6%96%87%E5%88%86%E6%9E%90-%E5%87%8F%E5%B0%91%E6%9C%BA%E5%9C%BA%E5%AE%89%E5%85%A8%E7%AD%89%E5%BE%85%E6%97%B6%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wenku.baidu.com/view/0f08a7145627a5e9856a561252d380eb6294233e.html" target="_blank" rel="noopener">题目翻译</a></p><h1 id="数学模型"><a href="#数学模型" class="headerlink" title="数学模型"></a>数学模型</h1><a id="more"></a><h2 id="排队模型"><a href="#排队模型" class="headerlink" title="排队模型"></a>排队模型</h2><p>根据题意得到了两个先进先出的安检流程，并进行了简化。（画图精巧）</p><h3 id="指数拟合"><a href="#指数拟合" class="headerlink" title="指数拟合"></a>指数拟合</h3><p>对给出的数据做分析，发现顾客到达机场的到达时间间隔服符合指数分布,求出*<em>到达时间间隔  *</em>服从参数（秒/人）。</p><p> 文章作者估计是根据参考资料+matlab画图得知的。  </p><p>参考：<a href="https://max.book118.com/html/2017/0120/85592167.shtm" target="_blank" rel="noopener">该链接ppt第八页</a></p><p> <strong>不满足这个条件都无法做排队论，顾客的到达的时间服从泊松分布，可以得到到达时间间隔为指数分布，具体学习：<a href="https://www.doc88.com/p-3857666887191.html" target="_blank" rel="noopener">https://www.doc88.com/p-3857666887191.html</a></strong>  </p><p> <strong>结论：单位时间内独立事件发生次数服从参数为入的泊松分布，那么两次独立事件发生的时间间隔服从参数为入的指数分布。</strong>  </p><p>下面代码可以根据数据来指数分布，求出*<em>到达时间间隔  *</em>服从参数（秒/人）。</p><p>read.m</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[dt, name]</span> = <span class="title">read</span><span class="params">(type)</span></span></span><br><span class="line">d2s = <span class="number">24</span> * <span class="number">3600</span>;</span><br><span class="line"><span class="keyword">switch</span> <span class="built_in">type</span> </span><br><span class="line">    <span class="keyword">case</span>&#123;<span class="string">'A'</span>,<span class="string">'PreArrT'</span>,<span class="string">'TSA Pre-Check Arrival Times'</span>&#125;</span><br><span class="line">        col = <span class="string">'A'</span>;isinter=<span class="number">0</span>;name=<span class="string">'TSA Pre-Check Arrival Times'</span>;</span><br><span class="line">    <span class="keyword">case</span>&#123;<span class="string">'B'</span>,<span class="string">'RegArrT'</span>,<span class="string">'Regular Pax Arrival Times'</span>&#125;</span><br><span class="line">        col=<span class="string">'B'</span>;isinter=<span class="number">0</span>;name=<span class="string">'Regular Pax Arrival Times'</span>;</span><br><span class="line">    <span class="keyword">otherwise</span></span><br><span class="line">        error([<span class="string">'No data named '</span>, <span class="built_in">type</span>]);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">data = xlsread(<span class="string">'2017_ICM_Problem_D_Data.xlsx'</span>,[col,<span class="string">':'</span>,col])*d2s;</span><br><span class="line"><span class="keyword">if</span> isinter;</span><br><span class="line">    dt=data;</span><br><span class="line"><span class="keyword">else</span>;</span><br><span class="line">    dt=diff(data);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%if nargin==0; isplot = 1; end</span></span><br><span class="line"><span class="comment">% 在函数体内部， nargin是用来判断输入变量个数的函数</span></span><br><span class="line">[PreArrT , PreName] = read(<span class="string">'PreArrT'</span>);</span><br><span class="line">[RegArrT , RegName] = read(<span class="string">'RegArrT'</span>);</span><br><span class="line">lambdaPre = expfit(PreArrT); <span class="comment">% [sec/passenger]</span></span><br><span class="line"><span class="comment">%指数分布参数的最大似然估计</span></span><br><span class="line">lambdaReg = expfit(RegArrT); <span class="comment">% [sec/passenger]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span>(<span class="string">'position'</span> ,[<span class="number">100</span>,<span class="number">100</span>,<span class="number">1000</span>,<span class="number">450</span>]); <span class="comment">% Figure 2</span></span><br><span class="line"><span class="comment">% % 创建一个新的窗口</span></span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line"><span class="comment">%h =subplot（m，n，p）</span></span><br><span class="line"><span class="comment">%将数字窗口分成m×n的网格，</span></span><br><span class="line"><span class="comment">%并在当前图的第p个位置创建一个轴对象，并返回轴句柄。 </span></span><br><span class="line">hPre = histfit(PreArrT ,<span class="number">10</span>,<span class="string">'exponential'</span>);</span><br><span class="line"><span class="comment">%hisfit添加状态曲线</span></span><br><span class="line"><span class="built_in">legend</span>(hPre(<span class="number">2</span>) ,[<span class="string">'Exponential Fit: lambda = '</span>,num2str(lambdaPre)]);</span><br><span class="line">xlabel(<span class="string">'Wait time [sec]'</span>); ylabel(<span class="string">'Count'</span>); title(PreName);</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">hReg = histfit(RegArrT ,<span class="number">10</span>,<span class="string">'exponential'</span>);</span><br><span class="line"><span class="built_in">legend</span>(hReg(<span class="number">2</span>) ,[<span class="string">'Exponential Fit: lambda = '</span>,num2str(lambdaReg)]);</span><br><span class="line">xlabel(<span class="string">'Wait time [sec]'</span>); ylabel(<span class="string">'Count'</span>); title(RegName);</span><br></pre></td></tr></table></figure><h3 id="核密度估计"><a href="#核密度估计" class="headerlink" title="核密度估计"></a>核密度估计</h3><p>利用核密度来估计某种服务时间满足的分布，有一点考虑得很细，X ： 在微波扫描花费的时间 ，Y 是行李扫描的时间，则在扫描服务台花费的时间应取这两个值的最大值$S_{2}^{\mathrm{pre}}$，X和Y的服务是相互独立的，分布是可以独立出来相乘的:</p><p>$$<br>F_{S}(s) \doteq P\left(S_{2}^{\mathrm{pre}} \leq s\right)=P(\max (X, Y) \leq s)=P(X \leq s, Y \leq s)=F_{X}(s) F_{Y}(s)<br>$$</p><p>概率分布函数为:F(x) 概率密度函数为:f(x) 二者的关系为: f(x) = dF(x)/dx ,我们这样就求出了密度函数。</p><p>概率论复习：<a href="https://www.jianshu.com/p/0cfc3204af77" target="_blank" rel="noopener">https://www.jianshu.com/p/0cfc3204af77</a></p><p> ksdensity()函数是matalb的核估计函数  </p><p> 非参数估计并不加入任何先验知识，而是根据数据本身的特点、性质来拟合分布，这样能比参数估计方法得出更好的模型。核密度估计就是非参数估计中的一种。  </p><p>学习文章：<a href="https://blog.csdn.net/unixtch/article/details/78556499" target="_blank" rel="noopener">https://blog.csdn.net/unixtch/article/details/78556499</a></p><p> 直方图中bin的含义：计算颜色直方图需要将颜色空间划分为若干小的颜色区间，即直方图的bin，通过计算颜色在每个小区间内德像素得到颜色直方图，bin越多，直方图对颜色的分辨率越强，但增加了计算机的负担。即（上图所分10个竖条区域，每个竖条区域称为一个bin）  </p><p>身份认证时间的分布 <strong>直方图绘画（hist）</strong>(论文代码：IDChkPdf.m  )</p><h3 id="递推"><a href="#递推" class="headerlink" title="递推"></a>递推</h3><p><img src="https://img2018.cnblogs.com/i-beta/1880713/202001/1880713-20200131112841344-1826000296.png" alt=""></p><p>递推关系得出一个公式表示第j个乘客等待时间，并将公式转化为上面求出的指数分布参数λ。</p><p>(网站视频当中有提到过这几个公式，且是优化之后的)</p><p>泊松分布和指数分布的期望的为λ，期望的求法要有很高的基础。 </p><p>注意这里的两个队列Q1与Q2，Q1是身份检查队列，Q2是扫描检查队列，不是会员和非会员。</p><p><img src="https://img2018.cnblogs.com/i-beta/1880713/202001/1880713-20200131125804156-1874978370.png" alt=""></p><p>第一个括号表示第n位乘客到达队列2的时间，剩下的表示前面n-1个乘客完成扫描服务的时间。</p><p>化简：</p><ul><li><p>线性叠加</p></li><li><p>$\frac{d}{=}$该符号表示定义.define.将左边定义为右边.</p></li></ul><p>这样就可以求出乘客 i 在 TSA 安检全过程中花费的期望总时间，然后求平均等待时间 。</p><h2 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h2><p>用模拟（一个递推）的方法对上面的平均等待时间进行验证。并选择了模拟的结果。</p><p>代码失败，没有运行成功，有一个函数没找到。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%function [Tq1,Tq2,Ttot ,Vq1,Vq2,Vtot ,P] = simQ(lambda ,n,c,k,tc,pdfc ,ts,pdfs ,mode ,p)</span></span><br><span class="line"><span class="comment">% lambda =到达过程的速度</span></span><br><span class="line"><span class="comment">% n = 即将到达的人数</span></span><br><span class="line"><span class="comment">% c = 是ID检查程序的数量</span></span><br><span class="line"><span class="comment">% k = X射线传送带的数量</span></span><br><span class="line"><span class="comment">% p =缓慢的过客比例</span></span><br><span class="line"><span class="comment">% model='none'，'FIFO'或'priority'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%if nargin &lt;9; mode='none'; end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">n=<span class="number">9</span>;c=<span class="number">3</span>;k=<span class="number">5</span>;p=<span class="number">0.3</span>;</span><br><span class="line">mode=<span class="string">'FIFO'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">n = n + <span class="built_in">max</span>(c,k);</span><br><span class="line">slow = <span class="number">2</span>; fast = <span class="number">0.5</span>;</span><br><span class="line"><span class="keyword">switch</span> mode</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'FIFO'</span> <span class="comment">% 先进先出</span></span><br><span class="line">        nslow = <span class="built_in">round</span>(n*p); <span class="comment">% 慢一点的乘客数量</span></span><br><span class="line">        fac = fast*<span class="built_in">ones</span>(<span class="number">1</span>,n); </span><br><span class="line">        fac(randperm(n,nslow)) = slow;</span><br><span class="line">        <span class="comment">%p = randperm(n,k) 返回一行从1到n的整数中的k个，而且这k个数也是不相同的。</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'priority'</span> <span class="comment">% 首先是慢，然后是快速的乘客。</span></span><br><span class="line">        nslow = <span class="built_in">round</span>(n*p); <span class="comment">% 慢一点的乘客数量</span></span><br><span class="line">        fac = fast*<span class="built_in">ones</span>(<span class="number">1</span>,n); </span><br><span class="line">        fac(<span class="number">1</span>:nslow) = slow;</span><br><span class="line">    <span class="keyword">otherwise</span> <span class="comment">% mode = 'none '</span></span><br><span class="line">        fac = <span class="built_in">ones</span>(<span class="number">1</span>,n);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">[Arrival , ChkSta , ChkEnd , ScnSta , ScnEnd] = deal(<span class="built_in">zeros</span>(n,<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">Csample = fac.*datasample(tc,n,<span class="string">'Weights'</span>,pdfc);</span><br><span class="line"><span class="comment">%datasample()这个函数哪里冒出来的，tc为检查的时间，pdfc为参数</span></span><br><span class="line">Ssample = fac.*datasample(ts,n,<span class="string">'Weights'</span>,pdfs);</span><br><span class="line">Asample = exprnd(lambda ,n,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="built_in">max</span>(c,k)+<span class="number">1</span>:n</span><br><span class="line">    Arrival(<span class="built_in">i</span>) = Arrival(<span class="built_in">i</span><span class="number">-1</span>) + Asample(<span class="built_in">i</span>); <span class="comment">%到达时间</span></span><br><span class="line">    ChkSta(<span class="built_in">i</span>) = <span class="built_in">max</span>( Arrival(<span class="built_in">i</span>), <span class="built_in">min</span>(ChkEnd(<span class="built_in">i</span>-c:<span class="built_in">i</span><span class="number">-1</span>)) );<span class="comment">% 开始检查时间</span></span><br><span class="line">    ChkEnd(<span class="built_in">i</span>) = ChkSta(<span class="built_in">i</span>) + Csample(<span class="built_in">i</span>); <span class="comment">% 检查结束时间</span></span><br><span class="line">    ScnSta(<span class="built_in">i</span>) = <span class="built_in">max</span>( ChkEnd(<span class="built_in">i</span>), <span class="built_in">min</span>(ScnEnd(<span class="built_in">i</span>-k:<span class="built_in">i</span><span class="number">-1</span>)) );<span class="comment">% 扫描开始时间</span></span><br><span class="line">    ScnEnd(<span class="built_in">i</span>) = ScnSta(<span class="built_in">i</span>) + Ssample(<span class="built_in">i</span>); <span class="comment">% 扫描结束时间</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">Tq1 = <span class="built_in">mean</span>(ChkSta - Arrival);  <span class="comment">%队列1中的平均等待时间</span></span><br><span class="line">Tq2 = <span class="built_in">mean</span>(ScnSta - ChkEnd );  <span class="comment">%队列2中的平均等待时间</span></span><br><span class="line">Ttot = <span class="built_in">mean</span>(ScnEnd - Arrival); <span class="comment">%总队列的平均等待时间</span></span><br><span class="line"></span><br><span class="line">Vq1 = var(ChkSta - Arrival); <span class="comment">% 队列1中等待时间的方差</span></span><br><span class="line">Vq2 = var(ScnSta - ChkEnd ); <span class="comment">% 队列1中等待时间的方差</span></span><br><span class="line">Vtot = var(ScnEnd - Arrival); <span class="comment">% 总队列中等待时间的方差</span></span><br><span class="line"><span class="comment">%网上说求方差应该 var(a,1)  除数为N，var(a)除数为N-1</span></span><br><span class="line"></span><br><span class="line">Cp = <span class="number">6.60</span>; <span class="comment">% 单程费用</span></span><br><span class="line">Ct = <span class="number">18.5</span>/<span class="number">3600</span>; <span class="comment">% 运输安全官员（TSO）的费用</span></span><br><span class="line"></span><br><span class="line">P = Cp / Ttot - (c + <span class="number">3</span> * k) * Ct;</span><br></pre></td></tr></table></figure><h2 id="评价"><a href="#评价" class="headerlink" title="评价"></a>评价</h2><h3 id="身份检查服务台"><a href="#身份检查服务台" class="headerlink" title="身份检查服务台"></a>身份检查服务台</h3><p>研究了<strong>不同的到达率</strong>和<strong>检查服务台的数量（身份和扫描）</strong>将如何影响检查队列中的等待时间。</p><p>λ公式看懂了，那篇排队论课程有提到 。</p><p>但他说下面的横线符合就看不懂了。</p><p>扫描服务台是 类似</p><h3 id="乘客等待时间的方差"><a href="#乘客等待时间的方差" class="headerlink" title="乘客等待时间的方差"></a>乘客等待时间的方差</h3><p>确保乘客通常知道安检将会需要多长时间 （创新，对方差理解深刻）</p><h2 id="对模型的修改s"><a href="#对模型的修改s" class="headerlink" title="对模型的修改s"></a>对模型的修改s</h2><h3 id="成本效益分析"><a href="#成本效益分析" class="headerlink" title="成本效益分析"></a>成本效益分析</h3><p>不同的c和k来改变目标函数求其最优解，热图做法(可以借用）。</p><h3 id="灵敏度分析"><a href="#灵敏度分析" class="headerlink" title="灵敏度分析"></a>灵敏度分析</h3><p>虚拟排队和将顾客分为有经验和没经验的（创新思维，有什么措施咱也可以写，就叫灵敏度分析）</p>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 论文分析 </tag>
            
            <tag> 美赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排队论</title>
      <link href="/2020/01/29/%E6%8E%92%E9%98%9F%E8%AE%BA/"/>
      <url>/2020/01/29/%E6%8E%92%E9%98%9F%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="排队论简介"><a href="#排队论简介" class="headerlink" title="排队论简介"></a>排队论简介</h1><a id="more"></a><h2 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h2><ul><li>排队论又称随机服务系统，是研究系统随机聚散现象和随机 服务系统工作过程的数学理论和方法，是运筹学的一个分支。 </li><li>排队论的基本思想是 1909 年丹麦数学家 A.K. 埃尔朗在解 决自动电话设计问题时开始形成的，当时称为话务理论。 </li><li>现实生活中如排队买票、病人排队就诊、轮船进港、高速路 上汽车排队通过收费站、机器等待修理等都属于排队论问题。</li></ul><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ol><li>通过对服务对象到来及服务时间的统计研究</li><li>得出这些数量指标（等待时间、排队长度、忙期长短（决定<strong>服务台数量</strong>）等）的 统计规律，</li><li>然后根据这些规律来改进服务系统的结构或重新组织被服务 对象</li><li>使得服务系统既能满足服务对象的需要，又能使机构的费用 最经济或某些指标最优。</li></ol><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ul><li>CUMCM 2009B 的眼科病床的合理安排问题</li><li>MCM 2005B 收费站最佳配置问题 </li><li>ICM 2017D 机场安检问题</li></ul><h1 id="模型与模拟"><a href="#模型与模拟" class="headerlink" title="模型与模拟"></a>模型与模拟</h1><h2 id="排队论基本构成与指标"><a href="#排队论基本构成与指标" class="headerlink" title="排队论基本构成与指标"></a>排队论基本构成与指标</h2><h3 id="排队论的基本构成"><a href="#排队论的基本构成" class="headerlink" title="排队论的基本构成"></a>排队论的基本构成</h3><ul><li>输入过程：描述顾客按照怎样的规律到达排队系统。顾客总 体（有限/无限）、到达的类型（单个/成批）、到达时间间隔。 </li><li>排队规则：指顾客按怎样的规定次序接受服务。常见的有等 待制、损失制、混合制、闭合制。 </li><li>服务机构：服务台的数量; 服务时间服从的分布</li></ul><h3 id="排队系统的数量指标"><a href="#排队系统的数量指标" class="headerlink" title="排队系统的数量指标"></a>排队系统的数量指标</h3><ul><li>队长：系统中的平均顾客数（包括正在接受服务的顾客）。 </li><li>等待队长：系统中处于等待的顾客的数量。 </li><li>等待时间：等待时间包括顾客的平均逗留时间。 </li><li>忙期：连续保持服务的时长。</li></ul><h2 id="数学表示"><a href="#数学表示" class="headerlink" title="数学表示"></a>数学表示</h2><h3 id="排队论中的符号表示"><a href="#排队论中的符号表示" class="headerlink" title="排队论中的符号表示"></a>排队论中的符号表示</h3><p>$$<br>{A/B/C/n}<br>$$</p><p>A 输入过程，B 服务时间，C 服务台数，n 系统容量。 </p><h2 id="排队论表示实例-M-M-S-∞"><a href="#排队论表示实例-M-M-S-∞" class="headerlink" title="排队论表示实例　M/M/S/∞"></a>排队论表示实例　M/M/S/∞</h2><ul><li>输入过程是 Poisson 流 （顾客到达的时间服从泊松分布，到达的时间间隔便服从负指数分布）</li><li>服务时间服从负指数分布 </li><li>系统有 S 个服务台平行服务 </li><li>系统容量为无穷大的等待制排队系统</li></ul><h3 id="等待制模型-M-M-S-∞-S-1"><a href="#等待制模型-M-M-S-∞-S-1" class="headerlink" title="等待制模型 M/M/S/∞ S=1"></a>等待制模型 M/M/S/∞ S=1</h3><p><img src="https://raw.githubusercontent.com/pxlsdz/MarkDown-images/master/2020-1-29/1.png" alt=""></p><p><strong>单位时间内到达的人数为λ</strong>,所以[0,t] 时间内到达的顾客平均数为 λt</p><p>*<em>µ代表单位时间服务人的个数 *</em><br>判断模型是否稳定，一般用比较λ和µ的大小（下图的系统服务强度）</p><hr><p><img src="https://raw.githubusercontent.com/pxlsdz/MarkDown-images/master/2020-1-29/2.png" alt=""></p><p>$(1-\rho)\sum_{n=0}^{\infty}n\rho^{n}$,当$\rho$&lt;1时候级数收敛</p><p>平均等待队长比平均队长少一人，因为一人在接受服务。</p><p><img src="https://raw.githubusercontent.com/pxlsdz/MarkDown-images/master/2020-1-29/3.png" alt=""></p><p>平均等待时间=逗留的时间-服务的时间</p><p>Little公式是根据前面推导出来。</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p><img src="https://raw.githubusercontent.com/pxlsdz/MarkDown-images/master/2020-1-29/4.png" alt=""></p><p>λ/µ=8/9&lt;1,系统是稳定的。</p><p>平均等待7.1个人</p><h3 id="等待制模型-M-M-S-∞-S-gt-1-服务台数量-gt-1"><a href="#等待制模型-M-M-S-∞-S-gt-1-服务台数量-gt-1" class="headerlink" title="等待制模型 M/M/S/∞ S&gt;1(服务台数量&gt;1)"></a>等待制模型 M/M/S/∞ S&gt;1(服务台数量&gt;1)</h3><p><img src="https://raw.githubusercontent.com/pxlsdz/MarkDown-images/master/2020-1-29/5.png" alt=""></p><p>k=[0:s-1]</p><p><img src="https://raw.githubusercontent.com/pxlsdz/MarkDown-images/master/2020-1-29/6.png" alt=""></p><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><p>案例 </p><ul><li>来访人员按照 Poisson 流到达，到达速率为 µ = 20 人/小时。 </li><li>接待人员的服务速率间服 λ = 9 人/小时的负指数分布。 </li><li>为使来访问者等待不超过半小时，最少应配置几名接待员？</li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">lambda = <span class="number">20</span>; mu = <span class="number">9</span>; s = <span class="number">3</span>;</span><br><span class="line">rho = lambda/(s*mu); <span class="comment">%服务强度</span></span><br><span class="line">k=(<span class="number">0</span>:s<span class="number">-1</span>);</span><br><span class="line">p0 = <span class="number">1.</span>/( sum((s*rho).^k./<span class="built_in">factorial</span>(k)) + ... </span><br><span class="line">     (s*rho)^s/(<span class="built_in">factorial</span>(s)*(<span class="number">1</span>-rho)) ); <span class="comment">%服务台空闲的概率</span></span><br><span class="line">Ls = s*rho + (s*rho)^s*rho/(<span class="built_in">factorial</span>(s)*(<span class="number">1</span>-rho)^<span class="number">2</span>)*p0; <span class="comment">%平均长度</span></span><br><span class="line">Ws = Ls/lambda; <span class="comment">%平均逗留时间</span></span><br><span class="line">Wq = Ws - <span class="number">1</span>/mu<span class="comment">%平均等待时间</span></span><br></pre></td></tr></table></figure><h2 id="其他模型"><a href="#其他模型" class="headerlink" title="其他模型"></a>其他模型</h2><p><img src="https://raw.githubusercontent.com/pxlsdz/MarkDown-images/master/2020-1-29/7.png" alt=""></p><p>混合制：</p><p>系统容量K为队长，理发店的的凳子数（等待凳子和服务凳子）</p><p>闭合制：</p><p>工厂的工人，使用的机器。</p><h3 id="单服务台"><a href="#单服务台" class="headerlink" title="单服务台"></a>单服务台</h3><p>做模拟：</p><p>开始服务, 到达, 离开时刻和服务, 等待时长的关系</p><ul><li>服务时刻(i) = max{到达时刻(i),离开时刻(i−1)} </li><li>离开时刻(i) = 服务时刻(i) + 服务时长(i) </li><li>等待时长(i) = 离开时刻(i)−到达时刻(i)</li></ul><h3 id="多服务台"><a href="#多服务台" class="headerlink" title="多服务台"></a>多服务台</h3><p>开始服务, 到达, 离开时刻和服务, 等待时长的关系 </p><ul><li>服务时刻(i) = max{到达时刻(i),min{服务台空闲时刻}} （假设所有顾客目的尽早的接受服务）</li><li>所使用服务台(i) = k, 其中 k 使服务台空闲时刻(k) = min </li><li>离开时刻(i) = 服务时刻(i) + 服务时长(i) </li><li>服务台空闲时刻(k) = 离开时刻(i)</li><li>等待时长(i) = 离开时刻(i)−到达时刻(i)（包括服务时间）</li></ul><h3 id="自动取款机问题"><a href="#自动取款机问题" class="headerlink" title="自动取款机问题"></a>自动取款机问题</h3><p>问题 </p><ul><li>银行计划安置取款机, A 机价格和平均服务率都是 B 机的 2 倍. 应购置 1 台 A 机还是 2 台 B 机? </li><li>顾客平均每分钟到达 1 位，A 型机的平均服务时间为 0.9, B 型机为 1.8 分钟, 顾客到达间隔和服务时间都服从指数分布.</li></ul><h4 id="单服务台-1"><a href="#单服务台-1" class="headerlink" title="单服务台"></a>单服务台</h4><p>属于M/M/1/∞ 模型</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="number">100000</span>; <span class="comment">% 模拟顾客总数 </span></span><br><span class="line">mu = <span class="number">1</span>; muA = <span class="number">0.9</span>; <span class="comment">% 到达率和服务率 </span></span><br><span class="line">tarr = cumsum(exprnd(mu,<span class="number">1</span>,n));<span class="comment">% 到达时刻 ，exprnd生成指数分布（到达的时间间隔）</span></span><br><span class="line">tsrv = exprnd(muA,<span class="number">1</span>,n); <span class="comment">% 服务时长 </span></span><br><span class="line">tsta = <span class="built_in">zeros</span>(<span class="number">1</span>,n); <span class="comment">% 初始化服务时刻 </span></span><br><span class="line">tlea = <span class="built_in">zeros</span>(<span class="number">1</span>,n);<span class="comment">% 初始化离开时刻 </span></span><br><span class="line">twat = <span class="built_in">zeros</span>(<span class="number">1</span>,n); <span class="comment">% 初始化等待时长 </span></span><br><span class="line">tsta(<span class="number">1</span>) = tarr(<span class="number">1</span>);<span class="comment">% 首位顾客服务时刻=到达时刻 </span></span><br><span class="line">tlea(<span class="number">1</span>) = tsta(<span class="number">1</span>) + tsrv(<span class="number">1</span>); <span class="comment">% 首位顾客离开时刻 </span></span><br><span class="line">twtime(<span class="number">1</span>) = tlea(<span class="number">1</span>) - tarr(<span class="number">1</span>); <span class="comment">% 首位顾客等待时长=0 </span></span><br><span class="line"><span class="comment">% 上面初始化第一个顾客</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">2</span>:n</span><br><span class="line">     <span class="comment">% 服务时刻 = max&#123;到达时刻, 上一个顾客离开时刻&#125; </span></span><br><span class="line">    tsta(<span class="built_in">i</span>) = <span class="built_in">max</span>(tarr(<span class="built_in">i</span>),tlea(<span class="built_in">i</span><span class="number">-1</span>));</span><br><span class="line">    tlea(<span class="built_in">i</span>) = tsta(<span class="built_in">i</span>) + tsrv(<span class="built_in">i</span>);<span class="comment">% 离开时刻=服务时刻+服务时长 </span></span><br><span class="line">    twat(<span class="built_in">i</span>) = tlea(<span class="built_in">i</span>) - tarr(<span class="built_in">i</span>);;<span class="comment">% 等待时长=离开时刻-到达时刻 </span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">hist(twat)</span><br><span class="line">sum(twat)/n</span><br></pre></td></tr></table></figure><h4 id="两服务台-多个服务台"><a href="#两服务台-多个服务台" class="headerlink" title="两服务台(多个服务台)"></a>两服务台(多个服务台)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">n &#x3D; 100000;  % 模拟顾客总数 </span><br><span class="line">mu &#x3D; 1; muB &#x3D; 1.8; % 到达率和服务率 </span><br><span class="line">tarr &#x3D; cumsum(exprnd(mu,1,n)); % 到达时刻 </span><br><span class="line">tsrv &#x3D; exprnd(muB,1,n);% 服务时长 </span><br><span class="line">tsta &#x3D; zeros(1,n);% 初始化服务&#x2F;离开时刻 </span><br><span class="line">tlea &#x3D; zeros(1,n); % 初始化等待时长 </span><br><span class="line">twat &#x3D; zeros(1,n);% 初始化服务台结束服务时刻 </span><br><span class="line">last &#x3D; [0 0];%几个服务台几个0</span><br><span class="line">for i &#x3D; 2:n</span><br><span class="line">    [minemp, k] &#x3D; min(last); % 找出最快结束服务的服务台时刻 </span><br><span class="line">    tsta(i) &#x3D; max(tarr(i),minemp);% 服务时刻 </span><br><span class="line">    tlea(i) &#x3D; tsta(i) + tsrv(i); % 离开时刻</span><br><span class="line">    last(k) &#x3D; tlea(i); % 服务台结束服务时刻 </span><br><span class="line">    twat(i) &#x3D; tlea(i) - tarr(i);% 等待时长 </span><br><span class="line">end</span><br><span class="line">hist(twat)</span><br><span class="line">sum(twat)&#x2F;n</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/pxlsdz/MarkDown-images/master/2020-1-29/8.png" alt=""></p><h1 id="真题"><a href="#真题" class="headerlink" title="真题"></a>真题</h1><h2 id="2013HIMCM-B-银行服务问题"><a href="#2013HIMCM-B-银行服务问题" class="headerlink" title="2013HIMCM-B: 银行服务问题"></a>2013HIMCM-B: 银行服务问题</h2><p><img src="https://raw.githubusercontent.com/pxlsdz/MarkDown-images/master/2020-1-29/9.png" alt=""></p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p><strong>如何生成序列来满足题意概率分布呢？</strong></p><p>举一个例子，由时间间隔 t = [0 1 2] 和概率 p = [0.2 0.3 0.5] 得到各到顾客达时间间隔 。</p><ol><li><p>先把概率p倒过来求前缀和<br>$$<br>p′ = cumsum([0.5,0.3,0.2]) = [0.5,0.8,1.0]<br>$$</p></li><li><p>我们生成随机数x，则x&lt;=0.5的概率为0.5，0.5&lt;x&lt;=0.8的概率为0.3，0.8&lt;x&lt;=1.0的概率为0.2<br>$$<br>R = rand(1,5) = [0.1,0.9,0.2,0.4,0.8];<br>$$</p></li><li><p>替换随机序列的数</p><p>把随机序列R&lt;0.5的数换成2……</p></li></ol><p>$$<br>R(R &lt; 0.5) = 2, R(R &lt; 0.8) = 1, R(p &lt; 1.0) = 0<br>$$</p><p>由到达时间间隔得到各顾客到达时刻<br>$$<br>间隔 = [0,1,3,2] ⇒ 时刻 = cumsum(间隔) = [0,1,4,6]<br>$$</p><p>开始服务, 到达, 离开时刻和服务, 等待时间的关系: </p><ul><li><p>开始服务的时刻(i) = max{到达时刻(i),离开时刻 (i-1)} </p></li><li><p>离开时刻(i) = 开始服务的时刻(i) + 服务时间(i) </p></li><li><p>等待时间(i) = 离开时刻(i)−到达时刻(i)−服务时间(i)（不是逗留时刻</p></li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%计算 Tarrival到达时刻, Tservice服务时间</span></span><br><span class="line">n = <span class="number">150</span>; </span><br><span class="line">ta = [<span class="number">5</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span> <span class="number">0</span>]; </span><br><span class="line">pa = [<span class="number">0.05</span> <span class="number">0.25</span> <span class="number">0.35</span> <span class="number">0.10</span> <span class="number">0.15</span> <span class="number">0.10</span>]; </span><br><span class="line">ts = [ <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span> ]; </span><br><span class="line">ps = [ <span class="number">0.15</span> <span class="number">0.40</span> <span class="number">0.20</span> <span class="number">0.25</span> ]; </span><br><span class="line">pacum = cumsum(pa);<span class="comment">%递增</span></span><br><span class="line">pscum = cumsum(ps); </span><br><span class="line">Tarrival = <span class="built_in">rand</span>(<span class="number">1</span>,n); </span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">length</span>(pa) </span><br><span class="line">    Tarrival(Tarrival&lt;pacum(<span class="built_in">i</span>)) = ta(<span class="built_in">i</span>); </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">Tarrival = cumsum(Tarrival);<span class="comment">%累加才得到到达时刻 </span></span><br><span class="line">Tservice = <span class="built_in">rand</span>(<span class="number">1</span>,n); </span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">length</span>(ps) </span><br><span class="line">    Tservice(Tservice&lt;pscum(<span class="built_in">i</span>)) = ts(<span class="built_in">i</span>); </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Tstart = <span class="built_in">zeros</span>(<span class="number">1</span>,n); <span class="comment">%开始服务的时刻</span></span><br><span class="line">Tleave = <span class="built_in">zeros</span>(<span class="number">1</span>,n); <span class="comment">%离开的时刻</span></span><br><span class="line">Twait = <span class="built_in">zeros</span>(<span class="number">1</span>,n);  <span class="comment">%等待的时长</span></span><br><span class="line">line = <span class="built_in">zeros</span>(<span class="number">1</span>,n);   <span class="comment">%队长</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%初始化第一位顾客</span></span><br><span class="line">Tstart(<span class="number">1</span>) = Tarrival(<span class="number">1</span>); </span><br><span class="line">Tleave(<span class="number">1</span>) = Tstart(<span class="number">1</span>) + Tservice(<span class="number">1</span>); </span><br><span class="line">Twait(<span class="number">1</span>) = Tleave(<span class="number">1</span>) - Tarrival(<span class="number">1</span>) - Tservice(<span class="number">1</span>); </span><br><span class="line">line(<span class="number">1</span>) = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">2</span>:n </span><br><span class="line">    Tstart(<span class="built_in">i</span>) = <span class="built_in">max</span>(Tleave(<span class="built_in">i</span><span class="number">-1</span>), Tarrival(<span class="built_in">i</span>)); </span><br><span class="line">    Tleave(<span class="built_in">i</span>) = Tstart(<span class="built_in">i</span>) + Tservice(<span class="built_in">i</span>); </span><br><span class="line">    Twait(<span class="built_in">i</span>) = Tleave(<span class="built_in">i</span>) - Tarrival(<span class="built_in">i</span>) - Tservice(<span class="built_in">i</span>); </span><br><span class="line">    </span><br><span class="line">    <span class="comment">%队长的计算，一直找到前面的人离开了</span></span><br><span class="line">    k = <span class="built_in">i</span><span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> ( k&gt;<span class="number">0</span> )&amp;&amp;( Tarrival(<span class="built_in">i</span>)&lt;Tleave(k) )  </span><br><span class="line">        line(<span class="built_in">i</span>) = line(<span class="built_in">i</span>) + <span class="number">1</span>; </span><br><span class="line">        k = k - <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">hist(Twait)</span><br><span class="line">line</span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">hist(line)</span><br></pre></td></tr></table></figure><p>因为随机数，所以可以多算几次，取平均值。</p><p><img src="https://raw.githubusercontent.com/pxlsdz/MarkDown-images/master/2020-1-29/10.png" alt=""></p><h2 id="ICM2017-D-优化机场安检口旅客通行"><a href="#ICM2017-D-优化机场安检口旅客通行" class="headerlink" title="ICM2017-D: 优化机场安检口旅客通行"></a>ICM2017-D: 优化机场安检口旅客通行</h2><p><img src="https://raw.githubusercontent.com/pxlsdz/MarkDown-images/master/2020-1-29/11.png" alt=""></p><p>问题 </p><ul><li><p>建立一个或多个模型，研究旅客通过安检口的流量，确定瓶 颈，明确判断当前流程问题区域位置。 </p></li><li><p>设计两个或更多对现有系统德潜在改进，提高旅客通信，减 少等待时间。模拟这些变化展示改进如何影响流程。</p></li></ul><h3 id=""><a href="#" class="headerlink" title=""></a></h3><p><img src="https://raw.githubusercontent.com/pxlsdz/MarkDown-images/master/2020-1-29/12.png" alt=""></p><p>排队系统: µr = 10, µb = 13, µ1 = 12, µ2 = 9, µ3 = 16</p><h3 id="多服务并联"><a href="#多服务并联" class="headerlink" title="多服务并联"></a>多服务并联</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[tlea, twat, qlen]</span> = <span class="title">mms</span><span class="params">(tarr, type, mus)</span></span></span><br><span class="line"><span class="comment">% MMS Stochastic simulation for M/M/c queue</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">% [tlea, twat, qlen] = mms(tarr, type, mus)</span></span><br><span class="line"><span class="comment">%     tarr ：每一个顾客到达的时间</span></span><br><span class="line"><span class="comment">%     type ：客户类型参数</span></span><br><span class="line"><span class="comment">%     mus  ：服务台的服务速度</span></span><br><span class="line"><span class="comment">%     tlea ：服务台的离开时间</span></span><br><span class="line"><span class="comment">%     twat ：服务台的等待时间</span></span><br><span class="line"><span class="comment">%     qlen ：客户的队列长度（排队的长度） </span></span><br><span class="line"></span><br><span class="line">narr = <span class="built_in">length</span>(tarr);        <span class="comment">% 客户的个数</span></span><br><span class="line">nsvr = <span class="built_in">length</span>(mus);         <span class="comment">% 服务台的数量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% last time at which a customer left a particular server</span></span><br><span class="line">last = <span class="built_in">zeros</span>(nsvr,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">[tsta, tlea, twat, qlen] = deal(<span class="built_in">zeros</span>(narr,<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">rndm = <span class="built_in">zeros</span>(nsvr,narr);    <span class="comment">% rndm(k,i) = 第i个客户的服务时间</span></span><br><span class="line"><span class="keyword">for</span> k = <span class="number">1</span>:nsvr; </span><br><span class="line">    rndm(k,:) = exprnd(mus(k)*<span class="built_in">type</span>); <span class="comment">%生成服从指数分布的随机数</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:narr</span><br><span class="line">    <span class="comment">% find booth service was/will be emptied soonest and record</span></span><br><span class="line">    [minemp, ksvr(<span class="built_in">i</span>)] = <span class="built_in">min</span>(last); </span><br><span class="line">    </span><br><span class="line">    <span class="comment">% start time = max&#123;arrival time, minemp&#125;</span></span><br><span class="line">    tsta(<span class="built_in">i</span>) = <span class="built_in">max</span>(tarr(<span class="built_in">i</span>), minemp); </span><br><span class="line">    </span><br><span class="line">    <span class="comment">% severe time = exponential random number with mean parameter mu</span></span><br><span class="line">    tsvr(<span class="built_in">i</span>) = rndm(ksvr(<span class="built_in">i</span>),<span class="built_in">i</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">% leaving time = start time + service time</span></span><br><span class="line">    tlea(<span class="built_in">i</span>) = tsta(<span class="built_in">i</span>) + tsvr(<span class="built_in">i</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">% last time of k-th server = leaving time of i-th customer </span></span><br><span class="line">    last(ksvr(<span class="built_in">i</span>)) = tlea(<span class="built_in">i</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">% waiting time = leaving time - arrival time</span></span><br><span class="line">    twat(<span class="built_in">i</span>) = tlea(<span class="built_in">i</span>) - tarr(<span class="built_in">i</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">% queue length for i customer</span></span><br><span class="line">    <span class="built_in">j</span> = <span class="built_in">i</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">j</span>&gt;<span class="number">0</span> &amp;&amp; tarr(<span class="built_in">i</span>)&lt;tlea(<span class="built_in">j</span>)</span><br><span class="line">        <span class="keyword">if</span> ksvr(<span class="built_in">j</span>)==ksvr(<span class="built_in">i</span>); qlen(<span class="built_in">i</span>) = qlen(<span class="built_in">i</span>) + <span class="number">1</span>; <span class="keyword">end</span></span><br><span class="line">        <span class="built_in">j</span> = <span class="built_in">j</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>分别求出A区域两个队列（红色和绿色队列）的离开的时刻，作为下一阶段服务台到达的时刻。</p><p>具体使用看下面主程序。</p><h3 id="串并混合系统"><a href="#串并混合系统" class="headerlink" title="串并混合系统"></a>串并混合系统</h3><p>µr = 10, µb = 13, µ1 = 12, µ2 = 9, µ3 = 16</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">n1 = <span class="number">2</span>;  n2 = <span class="number">3</span>; n3 = <span class="number">3</span>;<span class="comment">% ni表示第i个服务台的数量</span></span><br><span class="line">mu1 = <span class="number">12</span>; mu2 = <span class="number">9</span>; mu3 = <span class="number">16</span>;<span class="comment">% 服务台的到达率</span></span><br><span class="line">muR = <span class="number">10</span>; muB = <span class="number">13</span>;<span class="comment">% 蓝色与红色服务台的服务率</span></span><br><span class="line"></span><br><span class="line">nR = <span class="built_in">ceil</span>(<span class="number">24</span>*<span class="number">3600</span>/muR); nB = <span class="built_in">ceil</span>(<span class="number">24</span>*<span class="number">3600</span>/muB);<span class="comment">% 服务的人数</span></span><br><span class="line">tArrR = cumsum(exprnd(muR,nR,<span class="number">1</span>));</span><br><span class="line">tArrB = cumsum(exprnd(muB,nB,<span class="number">1</span>)); <span class="comment">%到达时刻</span></span><br><span class="line">tArr = [tArrR; tArrB];</span><br><span class="line"><span class="built_in">type</span> = [<span class="number">0.8</span>*<span class="built_in">ones</span>(nR,<span class="number">1</span>); <span class="number">1.2</span>*<span class="built_in">ones</span>(nB,<span class="number">1</span>)];<span class="comment">%区分两种服务的时长</span></span><br><span class="line"><span class="comment">%A区域</span></span><br><span class="line">[tLeaR, tWatR, qLenR] = mms(tArrR, <span class="built_in">ones</span>(nR,<span class="number">1</span>), mu1*<span class="built_in">ones</span>(n1,<span class="number">1</span>));</span><br><span class="line">[tLeaB, tWatB, qLenB] = mms(tArrB, <span class="built_in">ones</span>(nB,<span class="number">1</span>), mu2*<span class="built_in">ones</span>(n2,<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[tArrG, order] = <span class="built_in">sort</span>([tLeaR; tLeaB]);<span class="comment">%输出为离开A区域的时间，排序进入下一区域</span></span><br><span class="line"><span class="comment">%order数组为排序后的数组在原始数组的位置，保存原来的顺序</span></span><br><span class="line"><span class="comment">%下一区域</span></span><br><span class="line">[tLeaG, tWatG, qLenG] = mms(tArrG, <span class="built_in">type</span>(order), mu3*<span class="built_in">ones</span>(n3,<span class="number">1</span>));</span><br><span class="line">tLeaG(order) = tLeaG;</span><br><span class="line">tWatG(order) = tWatG;</span><br><span class="line">qLenG(order) = qLenG;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span>(<span class="string">'position'</span>,[<span class="number">50</span>,<span class="number">50</span>,<span class="number">1200</span>,<span class="number">600</span>])</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>); hist(qLenR); ylabel(<span class="string">'Frequency'</span>); </span><br><span class="line">xlabel(<span class="string">'length of the waiting line'</span>); title(<span class="string">'Red'</span>)</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>); hist(tWatR); ylabel(<span class="string">'Frequency'</span>); </span><br><span class="line">xlabel(<span class="string">'waiting time'</span>); title(<span class="string">'Red'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>); hist(qLenB); ylabel(<span class="string">'Frequency'</span>);</span><br><span class="line">xlabel(<span class="string">'length of the waiting line'</span>); title(<span class="string">'Blue'</span>)</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>); hist(tWatB); ylabel(<span class="string">'Frequency'</span>); </span><br><span class="line">xlabel(<span class="string">'waiting time'</span>); title(<span class="string">'Blue'</span>)</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>); hist(qLenG); ylabel(<span class="string">'Frequency'</span>);</span><br><span class="line">xlabel(<span class="string">'length of the waiting line'</span>); title(<span class="string">'Green'</span>)</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>); hist(tWatG); ylabel(<span class="string">'Frequency'</span>); </span><br><span class="line">xlabel(<span class="string">'waiting time'</span>); title(<span class="string">'Green'</span>)</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/pxlsdz/MarkDown-images/master/2020-1-29/13.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MATLAB </tag>
            
            <tag> 排队论 </tag>
            
            <tag> 运筹学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>预测与评价</title>
      <link href="/2020/01/28/%E9%A2%84%E6%B5%8B%E4%B8%8E%E8%AF%84%E4%BB%B7/"/>
      <url>/2020/01/28/%E9%A2%84%E6%B5%8B%E4%B8%8E%E8%AF%84%E4%BB%B7/</url>
      
        <content type="html"><![CDATA[<h1 id="评价模型"><a href="#评价模型" class="headerlink" title="评价模型"></a>评价模型</h1><h2 id="加权平均"><a href="#加权平均" class="headerlink" title="加权平均"></a>加权平均</h2><a id="more"></a><p>一个公式：<br>$$<br>p=\sum^{n}<em>{i=1}w</em>{i}p_{i}<br>$$</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Wi = [<span class="number">0.3</span> <span class="number">0.3</span> <span class="number">0.2</span> <span class="number">0.2</span>];<span class="comment">%权值</span></span><br><span class="line">Pi = [<span class="number">95</span>  <span class="number">90</span>  <span class="number">82</span>  <span class="number">85</span>  ;<span class="number">85</span>  <span class="number">95</span>  <span class="number">85</span>  <span class="number">90</span> ];<span class="comment">%单部分评分</span></span><br><span class="line">P = Wi * Pi'</span><br></pre></td></tr></table></figure><p>权值wi难以获得。</p><h2 id="层次分析（获取权重）"><a href="#层次分析（获取权重）" class="headerlink" title="层次分析（获取权重）"></a>层次分析（获取权重）</h2><h3 id="层次分析：对女星的评价"><a href="#层次分析：对女星的评价" class="headerlink" title="层次分析：对女星的评价"></a>层次分析：对女星的评价</h3><p><img src="https://raw.githubusercontent.com/pxlsdz/MarkDown-images/master/2020-1-28/1.png" alt=""></p><p>注意可以更多层</p><h3 id="层次分析：构造判断矩阵"><a href="#层次分析：构造判断矩阵" class="headerlink" title="层次分析：构造判断矩阵"></a>层次分析：构造判断矩阵</h3><p><img src="https://raw.githubusercontent.com/pxlsdz/MarkDown-images/master/2020-1-28/2.png" alt=""></p><p>{1，2，3，…，9}:代表重要程度，逐渐递增</p><p><img src="https://img-blog.csdn.net/20140221010943953?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGVuZ3hpYW8xOTkz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p><p>判断矩阵是一个正互反矩阵：</p><p><img src="https://img-blog.csdn.net/20140221011153156?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGVuZ3hpYW8xOTkz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p><p>判断矩阵可能会出现矛盾，A&gt;B,B&gt;C,但以后评价C&gt;A，出现不一致，所以需要一致性检验</p><h3 id="层次分析：一致性检验"><a href="#层次分析：一致性检验" class="headerlink" title="层次分析：一致性检验"></a>层次分析：一致性检验</h3><p><img src="https://raw.githubusercontent.com/pxlsdz/MarkDown-images/master/2020-1-28/3.png" alt=""></p><p>平均随机一致性指标 RI 是确定的</p><p>一致性矩阵的定义：</p><p><img src="https://img-blog.csdn.net/20140221011203796?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGVuZ3hpYW8xOTkz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">% n= [ 1    2    3    4    5    6    7    8    9</span></span><br><span class="line">RI = [ <span class="number">0.00</span> <span class="number">0.00</span> <span class="number">0.58</span> <span class="number">0.90</span> <span class="number">1.12</span> <span class="number">1.24</span> <span class="number">1.32</span> <span class="number">1.41</span> <span class="number">1.45</span>];</span><br><span class="line"></span><br><span class="line">n = <span class="built_in">size</span>(A,<span class="number">1</span>);</span><br><span class="line">[V, D] = eig(A);<span class="comment">% 计算特征向量V和特征值D: A*V=V*D </span></span><br><span class="line"></span><br><span class="line">[lamda, <span class="built_in">i</span>] = <span class="built_in">max</span>(<span class="built_in">diag</span>(D));<span class="comment">% 最大特征值lambda及其位置i </span></span><br><span class="line">CI=(lamda-n)/(n<span class="number">-1</span>); <span class="comment">% 一致性指标 </span></span><br><span class="line">CR = CI/RI(n);<span class="comment">% 一致性比例 ,需要小于0.1</span></span><br></pre></td></tr></table></figure><h3 id="层次分析：层次单排序"><a href="#层次分析：层次单排序" class="headerlink" title="层次分析：层次单排序"></a>层次分析：层次单排序</h3><ul><li><p>对于上一层某因素而言，<strong>本层次各因素的重要性的排序</strong>。 </p></li><li><p>上一层次某因素相对重要性：判断矩阵 A 对应于最大特征 值 $λ_{max}$ 的特征向量 W。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">A = [<span class="number">1</span>/<span class="number">1</span>  <span class="number">2</span>/<span class="number">1</span>  <span class="number">5</span>/<span class="number">1</span>  <span class="number">3</span>/<span class="number">1</span> </span><br><span class="line">     <span class="number">1</span>/<span class="number">2</span>  <span class="number">1</span>/<span class="number">1</span>  <span class="number">3</span>/<span class="number">1</span>  <span class="number">1</span>/<span class="number">2</span> </span><br><span class="line">     <span class="number">1</span>/<span class="number">5</span>  <span class="number">1</span>/<span class="number">3</span>  <span class="number">1</span>/<span class="number">1</span>  <span class="number">1</span>/<span class="number">4</span></span><br><span class="line">     <span class="number">1</span>/<span class="number">3</span>  <span class="number">2</span>/<span class="number">1</span>  <span class="number">4</span>/<span class="number">1</span>  <span class="number">1</span>/<span class="number">1</span>];</span><br><span class="line">[w, CR] = AHP(A);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[w, CR]</span> = <span class="title">AHP</span><span class="params">(A)</span></span></span><br><span class="line"><span class="comment">% n= [ 1    2    3    4    5    6    7    8    9</span></span><br><span class="line">RI = [ <span class="number">0.00</span> <span class="number">0.00</span> <span class="number">0.58</span> <span class="number">0.90</span> <span class="number">1.12</span> <span class="number">1.24</span> <span class="number">1.32</span> <span class="number">1.41</span> <span class="number">1.45</span>];</span><br><span class="line"></span><br><span class="line">n = <span class="built_in">size</span>(A,<span class="number">1</span>);</span><br><span class="line">[V, D] = eig(A);<span class="comment">% 计算特征向量V和特征值D: A*V=V*D </span></span><br><span class="line"></span><br><span class="line">[lamda, <span class="built_in">i</span>] = <span class="built_in">max</span>(<span class="built_in">diag</span>(D));<span class="comment">% 最大特征值lambda及其位置i </span></span><br><span class="line">CI=(lamda-n)/(n<span class="number">-1</span>); <span class="comment">% 一致性指标 </span></span><br><span class="line">CR = CI/RI(n);<span class="comment">% 一致性比例 ,需要小于0.1</span></span><br><span class="line"></span><br><span class="line">W = V(:,<span class="built_in">i</span>);<span class="comment">% 最大特征值对应的特征向量</span></span><br><span class="line">w = W/sum(W);<span class="comment">% 归一化 例如：[0.48 0.19 0.07 0.26]'</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="层次分析：层次总排序"><a href="#层次分析：层次总排序" class="headerlink" title="层次分析：层次总排序"></a>层次分析：层次总排序</h3><p><img src="https://raw.githubusercontent.com/pxlsdz/MarkDown-images/master/2020-1-28/4.png" alt=""></p><p>在一个因素下，比较各个女明星，得到判断矩阵</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% face</span></span><br><span class="line">A1 = [<span class="number">1</span>/<span class="number">1</span>  <span class="number">1</span>/<span class="number">2</span>  <span class="number">3</span>/<span class="number">1</span></span><br><span class="line">      <span class="number">2</span>/<span class="number">1</span>  <span class="number">1</span>/<span class="number">1</span>  <span class="number">5</span>/<span class="number">1</span></span><br><span class="line">      <span class="number">1</span>/<span class="number">3</span>  <span class="number">1</span>/<span class="number">5</span>  <span class="number">1</span>/<span class="number">1</span>];</span><br><span class="line">[w1, CR1] = AHP(A1);</span><br><span class="line"></span><br><span class="line"><span class="comment">% body</span></span><br><span class="line">A2 = [<span class="number">1</span>/<span class="number">1</span>  <span class="number">1</span>/<span class="number">3</span>  <span class="number">2</span>/<span class="number">1</span></span><br><span class="line">      <span class="number">3</span>/<span class="number">1</span>  <span class="number">1</span>/<span class="number">1</span>  <span class="number">5</span>/<span class="number">1</span></span><br><span class="line">      <span class="number">1</span>/<span class="number">2</span>  <span class="number">1</span>/<span class="number">5</span>  <span class="number">1</span>/<span class="number">1</span>];</span><br><span class="line">[w2, CR2] = AHP(A2);</span><br><span class="line"></span><br><span class="line"><span class="comment">% voice</span></span><br><span class="line">A3 = [<span class="number">1</span>/<span class="number">1</span>  <span class="number">2</span>/<span class="number">1</span>  <span class="number">1</span>/<span class="number">5</span></span><br><span class="line">      <span class="number">1</span>/<span class="number">2</span>  <span class="number">1</span>/<span class="number">1</span>  <span class="number">1</span>/<span class="number">7</span></span><br><span class="line">      <span class="number">5</span>/<span class="number">1</span>  <span class="number">7</span>/<span class="number">1</span>  <span class="number">1</span>/<span class="number">1</span>];</span><br><span class="line">[w3, CR3] = AHP(A3);</span><br><span class="line"></span><br><span class="line"><span class="comment">% acting</span></span><br><span class="line">A4 = [<span class="number">1</span>/<span class="number">1</span>  <span class="number">2</span>/<span class="number">1</span>  <span class="number">1</span>/<span class="number">3</span></span><br><span class="line">      <span class="number">1</span>/<span class="number">2</span>  <span class="number">1</span>/<span class="number">1</span>  <span class="number">1</span>/<span class="number">5</span></span><br><span class="line">      <span class="number">3</span>/<span class="number">1</span>  <span class="number">5</span>/<span class="number">1</span>  <span class="number">1</span>/<span class="number">1</span>];</span><br><span class="line">[w4, CR4] = AHP(A4);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CRs = [CR1 CR2 CR3 CR4]</span><br><span class="line">P = [w1 w2 w3 w4] * w</span><br><span class="line"></span><br><span class="line"> <span class="comment">% ------------------------------------------------------------------------</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[w, CR]</span> = <span class="title">AHP</span><span class="params">(A)</span></span></span><br><span class="line"><span class="comment">% n= [ 1    2    3    4    5    6    7    8    9</span></span><br><span class="line">RI = [ <span class="number">0.00</span> <span class="number">0.00</span> <span class="number">0.58</span> <span class="number">0.90</span> <span class="number">1.12</span> <span class="number">1.24</span> <span class="number">1.32</span> <span class="number">1.41</span> <span class="number">1.45</span>];</span><br><span class="line"></span><br><span class="line">n = <span class="built_in">size</span>(A,<span class="number">1</span>);</span><br><span class="line">[V, D] = eig(A);<span class="comment">% 计算特征向量V和特征值D: A*V=V*D </span></span><br><span class="line"></span><br><span class="line">[lamda, <span class="built_in">i</span>] = <span class="built_in">max</span>(<span class="built_in">diag</span>(D));<span class="comment">% 最大特征值lambda及其位置i </span></span><br><span class="line">CI=(lamda-n)/(n<span class="number">-1</span>); <span class="comment">% 一致性指标 </span></span><br><span class="line">CR = CI/RI(n);<span class="comment">% 一致性比例 ,需要小于0.1</span></span><br><span class="line"></span><br><span class="line">W = V(:,<span class="built_in">i</span>);<span class="comment">% 最大特征值对应的特征向量</span></span><br><span class="line">w = W/sum(W);<span class="comment">% 归一化 例如：[0.48 0.19 0.07 0.26]'</span></span><br></pre></td></tr></table></figure><h3 id="层次分析：总代码"><a href="#层次分析：总代码" class="headerlink" title="层次分析：总代码"></a>层次分析：总代码</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ahpactor</span></span></span><br><span class="line"></span><br><span class="line">A = [<span class="number">1</span>/<span class="number">1</span>  <span class="number">2</span>/<span class="number">1</span>  <span class="number">5</span>/<span class="number">1</span>  <span class="number">3</span>/<span class="number">1</span> </span><br><span class="line">     <span class="number">1</span>/<span class="number">2</span>  <span class="number">1</span>/<span class="number">1</span>  <span class="number">3</span>/<span class="number">1</span>  <span class="number">1</span>/<span class="number">2</span> </span><br><span class="line">     <span class="number">1</span>/<span class="number">5</span>  <span class="number">1</span>/<span class="number">3</span>  <span class="number">1</span>/<span class="number">1</span>  <span class="number">1</span>/<span class="number">4</span></span><br><span class="line">     <span class="number">1</span>/<span class="number">3</span>  <span class="number">2</span>/<span class="number">1</span>  <span class="number">4</span>/<span class="number">1</span>  <span class="number">1</span>/<span class="number">1</span>];</span><br><span class="line">[w, CR] = AHP(A);</span><br><span class="line"></span><br><span class="line"><span class="comment">% face</span></span><br><span class="line">A1 = [<span class="number">1</span>/<span class="number">1</span>  <span class="number">1</span>/<span class="number">2</span>  <span class="number">3</span>/<span class="number">1</span></span><br><span class="line">      <span class="number">2</span>/<span class="number">1</span>  <span class="number">1</span>/<span class="number">1</span>  <span class="number">5</span>/<span class="number">1</span></span><br><span class="line">      <span class="number">1</span>/<span class="number">3</span>  <span class="number">1</span>/<span class="number">5</span>  <span class="number">1</span>/<span class="number">1</span>];</span><br><span class="line">[w1, CR1] = AHP(A1);</span><br><span class="line"></span><br><span class="line"><span class="comment">% body</span></span><br><span class="line">A2 = [<span class="number">1</span>/<span class="number">1</span>  <span class="number">1</span>/<span class="number">3</span>  <span class="number">2</span>/<span class="number">1</span></span><br><span class="line">      <span class="number">3</span>/<span class="number">1</span>  <span class="number">1</span>/<span class="number">1</span>  <span class="number">5</span>/<span class="number">1</span></span><br><span class="line">      <span class="number">1</span>/<span class="number">2</span>  <span class="number">1</span>/<span class="number">5</span>  <span class="number">1</span>/<span class="number">1</span>];</span><br><span class="line">[w2, CR2] = AHP(A2);</span><br><span class="line"></span><br><span class="line"><span class="comment">% voice</span></span><br><span class="line">A3 = [<span class="number">1</span>/<span class="number">1</span>  <span class="number">2</span>/<span class="number">1</span>  <span class="number">1</span>/<span class="number">5</span></span><br><span class="line">      <span class="number">1</span>/<span class="number">2</span>  <span class="number">1</span>/<span class="number">1</span>  <span class="number">1</span>/<span class="number">7</span></span><br><span class="line">      <span class="number">5</span>/<span class="number">1</span>  <span class="number">7</span>/<span class="number">1</span>  <span class="number">1</span>/<span class="number">1</span>];</span><br><span class="line">[w3, CR3] = AHP(A3);</span><br><span class="line"></span><br><span class="line"><span class="comment">% acting</span></span><br><span class="line">A4 = [<span class="number">1</span>/<span class="number">1</span>  <span class="number">2</span>/<span class="number">1</span>  <span class="number">1</span>/<span class="number">3</span></span><br><span class="line">      <span class="number">1</span>/<span class="number">2</span>  <span class="number">1</span>/<span class="number">1</span>  <span class="number">1</span>/<span class="number">5</span></span><br><span class="line">      <span class="number">3</span>/<span class="number">1</span>  <span class="number">5</span>/<span class="number">1</span>  <span class="number">1</span>/<span class="number">1</span>];</span><br><span class="line">[w4, CR4] = AHP(A4);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CRs = [CR1 CR2 CR3 CR4]</span><br><span class="line">P = [w1 w2 w3 w4] * w</span><br><span class="line"></span><br><span class="line"> <span class="comment">% ------------------------------------------------------------------------</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[w, CR]</span> = <span class="title">AHP</span><span class="params">(A)</span></span></span><br><span class="line"><span class="comment">% n= [ 1    2    3    4    5    6    7    8    9</span></span><br><span class="line">RI = [ <span class="number">0.00</span> <span class="number">0.00</span> <span class="number">0.58</span> <span class="number">0.90</span> <span class="number">1.12</span> <span class="number">1.24</span> <span class="number">1.32</span> <span class="number">1.41</span> <span class="number">1.45</span>];</span><br><span class="line"></span><br><span class="line">n = <span class="built_in">size</span>(A,<span class="number">1</span>);</span><br><span class="line">[V, D] = eig(A);<span class="comment">% 计算特征向量V和特征值D: A*V=V*D </span></span><br><span class="line"></span><br><span class="line">[lamda, <span class="built_in">i</span>] = <span class="built_in">max</span>(<span class="built_in">diag</span>(D));<span class="comment">% 最大特征值lambda及其位置i </span></span><br><span class="line">CI=(lamda-n)/(n<span class="number">-1</span>); <span class="comment">% 一致性指标 </span></span><br><span class="line">CR = CI/RI(n);<span class="comment">% 一致性比例 ,需要小于0.1</span></span><br><span class="line"></span><br><span class="line">W = V(:,<span class="built_in">i</span>);<span class="comment">% 最大特征值对应的特征向量</span></span><br><span class="line">w = W/sum(W);<span class="comment">% 归一化 例如：[0.48 0.19 0.07 0.26]'</span></span><br></pre></td></tr></table></figure><h2 id="模糊综合评价"><a href="#模糊综合评价" class="headerlink" title="模糊综合评价"></a>模糊综合评价</h2><ol><li>秃子悖论: 天下所有的人都是秃子 </li></ol><ul><li><p>设头发的根数为 n，n = 1 显然为秃子。 </p></li><li><p>若 n = k 为秃子，则 n = k+ 1 亦为秃子。</p></li></ul><ol start="2"><li>模糊概念 </li></ol><ul><li><p>从属于该概念到不属于该概念之间无明显分界线。 </p></li><li><p>用隶属程度代替属或不属于，如某人属于秃子的程度为 0.8。</p></li></ul><ol start="3"><li>模糊综合评价要素 </li></ol><ul><li>因素集：U = {颜值u1, 身材u2, 声音u3, 演技u4} </li><li>评语集：V = {超棒v1, 很棒v2, 不错v3, 一般v4, 呕心v5</li></ul><ol start="4"><li>权重 W 和网友投票 (%) R </li></ol><p>​       权重 W来自：层次分析或者权威数据</p><p>​       <img src="https://raw.githubusercontent.com/pxlsdz/MarkDown-images/master/2020-1-28/5.png" alt=""></p><p>​       苍井的第一行例子为：</p><p>​        颜值：38%的网友认为超棒，34%的网友认为很棒，……</p><ol start="5"><li><p>模糊合成 </p><p><img src="https://raw.githubusercontent.com/pxlsdz/MarkDown-images/master/2020-1-28/6.png" alt=""></p><p>代码实现：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">W = [<span class="number">0.4</span> <span class="number">0.2</span> <span class="number">0.1</span> <span class="number">0.3</span>];</span><br><span class="line">R = [<span class="number">0.38</span> <span class="number">0.34</span> <span class="number">0.17</span> <span class="number">0.11</span> <span class="number">0.00</span></span><br><span class="line">     <span class="number">0.26</span> <span class="number">0.41</span> <span class="number">0.20</span> <span class="number">0.13</span> <span class="number">0.00</span></span><br><span class="line">     <span class="number">0.27</span> <span class="number">0.23</span> <span class="number">0.21</span> <span class="number">0.15</span> <span class="number">0.14</span></span><br><span class="line">     <span class="number">0.14</span> <span class="number">0.19</span> <span class="number">0.22</span> <span class="number">0.12</span> <span class="number">0.33</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">% B = max(R .* W')%新版</span></span><br><span class="line">B = <span class="built_in">max</span>(R .* <span class="built_in">repmat</span>(W',<span class="number">1</span>,<span class="built_in">size</span>(R,<span class="number">2</span>)) )</span><br><span class="line"><span class="comment">%repmat 平铺</span></span><br></pre></td></tr></table></figure><p>结果说明：</p><p>B=[B1,B2,B3,B4,B5],</p><p>根据评语集：V = {超棒v1, 很棒v2, 不错v3, 一般v4, 呕心v5}</p><p>如果B2最大，则说明很棒v2，如果B3最大，则说明不错v3。</p></li></ol><h1 id="预测模型"><a href="#预测模型" class="headerlink" title="预测模型"></a>预测模型</h1><h2 id="拟合"><a href="#拟合" class="headerlink" title="拟合"></a>拟合</h2><p>拟合是最基本的预测方法。 </p><p>MATALB函数：polyfit / fit 。</p><h2 id="时间序列"><a href="#时间序列" class="headerlink" title="时间序列"></a>时间序列</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>时间序列：将预测对象按照时间顺序排列而成的序列。 </p><p>时序预测：根据时序过去的变化规律，推测今后趋势。</p><h3 id="时间序列的变化形式"><a href="#时间序列的变化形式" class="headerlink" title="时间序列的变化形式"></a>时间序列的变化形式</h3><ul><li><p>长期趋势变动 Tt </p></li><li><p>季节变动 St </p></li><li><p>循环变动 Ct </p></li><li><p>不规则变动 Rt</p></li></ul><h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><ul><li><p>加法模型 （$Tt+St+Ct+Rt$)</p></li><li><p>乘法模型 （$Tt<em>St</em>Ct*Rt$)</p></li><li><p>混合模型</p></li></ul><h3 id="移动平均法"><a href="#移动平均法" class="headerlink" title="移动平均法"></a>移动平均法</h3><p><img src="https://raw.githubusercontent.com/pxlsdz/MarkDown-images/master/2020-1-28/7.png" alt=""></p><p>有前几个月的收入，预测下一个月的收入，具体取前面N的月的值取一下平均即可。适用波动不大的数据。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">% 近9月企业的收入，求第10月收入 </span></span><br><span class="line">y = [<span class="number">533.8</span> <span class="number">574.6</span> <span class="number">606.9</span> <span class="number">649.8</span>  <span class="number">705.1</span>, ...  </span><br><span class="line">     <span class="number">772.0</span> <span class="number">816.4</span> <span class="number">892.7</span> <span class="number">963.9</span> ];</span><br><span class="line">m = <span class="built_in">length</span>(y);</span><br><span class="line">n = <span class="number">4</span>;<span class="comment">% 最好去波动的周期</span></span><br><span class="line">c = cumsum(y);<span class="comment">%前缀和</span></span><br><span class="line">yhat = ( c(n:<span class="keyword">end</span>)-[<span class="number">0</span> c(<span class="number">1</span>:<span class="keyword">end</span>-n)] )/n;</span><br><span class="line"><span class="comment">%[(y1+...+y4) - 0, (y1+...+y5) - y1, (y1+...+y6) - (y1+y2)]/n</span></span><br><span class="line"><span class="comment">%[cn-0,c(n+1)-c(1),c(n+2)-c(2)........]/n</span></span><br><span class="line">yhat</span><br><span class="line">S = norm(yhat(<span class="number">1</span>:<span class="keyword">end</span><span class="number">-1</span>) - y(n+<span class="number">1</span>:<span class="keyword">end</span>))/<span class="built_in">sqrt</span>(m-n)</span><br></pre></td></tr></table></figure><h3 id="平滑法"><a href="#平滑法" class="headerlink" title="平滑法"></a>平滑法</h3><p><img src="https://raw.githubusercontent.com/pxlsdz/MarkDown-images/master/2020-1-28/8.png" alt=""></p><h2 id="灰色预测"><a href="#灰色预测" class="headerlink" title="灰色预测"></a>灰色预测</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol><li>模型使用的不是原始数据，而是生成数据。 </li><li>不需要很多数据，一般只需 ≥ 4 个数据。</li><li>只适用于<strong>中短期的预测</strong>，只适合<strong>指数增长</strong>的预测。</li></ol><h3 id="GM-1-1-预测模型"><a href="#GM-1-1-预测模型" class="headerlink" title="GM(1,1) 预测模型"></a>GM(1,1) 预测模型</h3><p>GM(1,1) 表示模型是 1 阶微分方程，且只含 1 个变量。</p><p>步骤如图：</p><p><img src="https://raw.githubusercontent.com/pxlsdz/MarkDown-images/master/2020-1-28/9.png" alt=""></p><p><img src="https://raw.githubusercontent.com/pxlsdz/MarkDown-images/master/2020-1-28/10.png" alt=""></p><p><img src="https://raw.githubusercontent.com/pxlsdz/MarkDown-images/master/2020-1-28/11.png" alt=""></p><p><img src="https://raw.githubusercontent.com/pxlsdz/MarkDown-images/master/2020-1-28/12.png" alt=""></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">t0 = [<span class="number">1999</span>:<span class="number">2003</span>]';</span><br><span class="line">X0 = [<span class="number">89</span>, <span class="number">99</span>, <span class="number">109</span>, <span class="number">120</span>, <span class="number">135</span>]';<span class="comment">% 原始序列 </span></span><br><span class="line">n = <span class="built_in">length</span>(X0);</span><br><span class="line">lambda = X0(<span class="number">1</span>:n<span class="number">-1</span>)./X0(<span class="number">2</span>:n);<span class="comment">%可行性检验条件</span></span><br><span class="line">range = minmax(lambda')  <span class="comment">% 检验 </span></span><br><span class="line"><span class="built_in">exp</span>([<span class="number">-2</span>/(n+<span class="number">1</span>), <span class="number">2</span>/(n+<span class="number">2</span>)])</span><br><span class="line">X1 = cumsum(X0); <span class="comment">% 累加生成序列 </span></span><br><span class="line">Z1 = (X1(<span class="number">1</span>:n<span class="number">-1</span>)+X1(<span class="number">2</span>:n))/<span class="number">2</span>  <span class="comment">% 均值 </span></span><br><span class="line">B = [-Z1, <span class="built_in">ones</span>(n<span class="number">-1</span>,<span class="number">1</span>)];</span><br><span class="line">Y = X0(<span class="number">2</span>:n);</span><br><span class="line">u = B\Y; a = u(<span class="number">1</span>); b = u(<span class="number">2</span>);<span class="comment">% 最小二乘估计a，b</span></span><br><span class="line">k = <span class="number">0</span>:n+<span class="number">4</span>;</span><br><span class="line">xhat1 = (X0(<span class="number">1</span>) - b/a).*<span class="built_in">exp</span>(-a*k) + b/a;</span><br><span class="line">xhat0 = [X0(<span class="number">1</span>) diff(xhat1)] <span class="comment">% 还原 </span></span><br><span class="line"><span class="built_in">plot</span>(t0,X0,<span class="string">'o'</span>,t0(<span class="number">1</span>)+k, xhat0,<span class="string">'-+'</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MATLAB </tag>
            
            <tag> 加权平均 </tag>
            
            <tag> 层次分析 </tag>
            
            <tag> 模糊综合评价 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性回归</title>
      <link href="/2020/01/27/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"/>
      <url>/2020/01/27/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/</url>
      
        <content type="html"><![CDATA[<h1 id="1-简单练习"><a href="#1-简单练习" class="headerlink" title="1 简单练习"></a>1 简单练习</h1><p>输出一个5*5的单位矩阵</p><a id="more"></a><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A = <span class="built_in">eye</span>(<span class="number">5</span>);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">     1     0     0     0     0</span><br><span class="line">     0     1     0     0     0</span><br><span class="line">     0     0     1     0     0</span><br><span class="line">     0     0     0     1     0</span><br><span class="line">     0     0     0     0     1</span><br></pre></td></tr></table></figure><h1 id="2-单变量的线性回归"><a href="#2-单变量的线性回归" class="headerlink" title="2 单变量的线性回归"></a>2 单变量的线性回归</h1><p>整个2的部分需要根据城市人口数量，预测开小吃店的利润 数据在ex1data1.txt里，第一列是城市人口数量，第二列是该城市小吃店利润。</p><h2 id="2-1-Plotting-the-Data"><a href="#2-1-Plotting-the-Data" class="headerlink" title="2.1 Plotting the Data"></a>2.1 Plotting the Data</h2><p>读入数据，然后展示数据</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">fprintf(<span class="string">'Plotting Data ...\n'</span>)</span><br><span class="line">data = load(<span class="string">'ex1data1.txt'</span>);</span><br><span class="line">x= data(:, <span class="number">1</span>); </span><br><span class="line">y =data(:, <span class="number">2</span>);</span><br><span class="line">m = <span class="built_in">length</span>(y); <span class="comment">% number of training examples</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">plot</span>(x, y, <span class="string">'rx'</span>, <span class="string">'MarkerSize'</span>, <span class="number">10</span>); <span class="comment">% Plot the data </span></span><br><span class="line"><span class="comment">%绘制图形：rx代表图形中标记的点为红色的x，数字10表示标记的大小。</span></span><br><span class="line">ylabel(<span class="string">'Profit in $10,000s'</span>); <span class="comment">% Set the y−axis label </span></span><br><span class="line">xlabel(<span class="string">'Population of City in 10,000s'</span>); <span class="comment">% Set the x−axis label </span></span><br><span class="line"></span><br><span class="line">fprintf(<span class="string">'Program paused. Press enter to continue.\n'</span>);</span><br><span class="line">pause;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/pxlsdz/MarkDown-images/master/2020-1-27/1.png" alt=""></p><h2 id="2-2-梯度下降"><a href="#2-2-梯度下降" class="headerlink" title="2.2 梯度下降"></a>2.2 梯度下降</h2><p>这个部分你需要在现有数据集上，训练线性回归的参数θ</p><h3 id="2-2-1-约定公式"><a href="#2-2-1-约定公式" class="headerlink" title="2.2.1 约定公式"></a>2.2.1 约定公式</h3><p>线性回归的目的是最小化成本函数<br>$$<br>\begin{aligned}<br>J(\theta) &amp;=\frac{1}{2 m} \sum_{i=1}^{m}\left(h_{\theta}\left(x^{(i)}\right)-y^{(i)}\right)^{2}<br>\end{aligned}<br>$$<br>假设$h_{\theta}(x)$由线性模型给出<br>$$<br>\begin{aligned}<br>h_{\theta}(x) &amp;=\theta^{T} X=\theta_{0}+\theta_{1} x_{1}<br>\end{aligned}<br>$$<br>梯度下降更新来最小化成本$J{(\theta)}$:<br>$$<br>\begin{aligned}<br>\theta_{j}:=\theta_{j} &amp;-\alpha \frac{1}{m} \sum_{i=1}^{m}\left(h_{\theta}\left(x^{(i)}\right)-y^{(i)}\right) x_{j}^{(i)}<br>\end{aligned}<br>$$<br>实现代码：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">J</span> = <span class="title">computeCost</span><span class="params">(X, y, theta)</span></span></span><br><span class="line"><span class="comment">%COMPUTECOST Compute cost for linear regression</span></span><br><span class="line"><span class="comment">%   J = COMPUTECOST(X, y, theta) computes the cost of using theta as the</span></span><br><span class="line"><span class="comment">%   parameter for linear regression to fit the data points in X and y</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% Initialize some useful values</span></span><br><span class="line">m = <span class="built_in">length</span>(y); <span class="comment">% number of training examples</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% You need to return the following variables correctly </span></span><br><span class="line">J = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">% ====================== YOUR CODE HERE ======================</span></span><br><span class="line"><span class="comment">% Instructions: Compute the cost of a particular choice of theta</span></span><br><span class="line"><span class="comment">%               You should set J to the cost.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%计算代价函数</span></span><br><span class="line">J=sum((X*theta-y).^<span class="number">2</span>)/(<span class="number">2</span>*m);</span><br><span class="line"></span><br><span class="line"><span class="comment">% =========================================================================</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="2-2-2实现"><a href="#2-2-2实现" class="headerlink" title="2.2.2实现"></a>2.2.2实现</h3><p>数据前面已经读取完毕，我们要为加入一列x，用于更新$\theta_{0}$，然后我们将$θ$初始化为0，学习率初始化为0.01，迭代次数为1500次</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">X = [<span class="built_in">ones</span>(m, <span class="number">1</span>), data(:,<span class="number">1</span>)]; <span class="comment">% Add a column of ones to x</span></span><br><span class="line">theta = <span class="built_in">zeros</span>(<span class="number">2</span>, <span class="number">1</span>); <span class="comment">% initialize fitting parameters</span></span><br><span class="line">iterations = <span class="number">1500</span>;</span><br><span class="line">alpha = <span class="number">0.01</span>;</span><br></pre></td></tr></table></figure><h3 id="2-2-3计算J-θ"><a href="#2-2-3计算J-θ" class="headerlink" title="2.2.3计算J(θ)"></a>2.2.3计算J(θ)</h3><p>答案应该是32.07</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">J =</span><br><span class="line"></span><br><span class="line">   <span class="number">32.0727</span></span><br></pre></td></tr></table></figure><h3 id="2-2-4-梯度下降"><a href="#2-2-4-梯度下降" class="headerlink" title="2.2.4 梯度下降"></a>2.2.4 梯度下降</h3><p>记住J(θ)的变量是θ，而不是X和y，意思是说，我们变化θ的值来使J(θ)变化，而不是变化X和y的值。 一个检查梯度下降是不是在正常运作的方式，是打印出每一步J(θ)的值，看他是不是一直都在减小，并且最后收敛至一个稳定的值。 θ最后的结果会用来预测小吃店在35000及70000人城市规模的利润。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[theta, J_history]</span> = <span class="title">gradientDescent</span><span class="params">(X, y, theta, alpha, num_iters)</span></span></span><br><span class="line"><span class="comment">%GRADIENTDESCENT Performs gradient descent to learn theta</span></span><br><span class="line"><span class="comment">%   theta = GRADIENTDESCENT(X, y, theta, alpha, num_iters) updates theta by </span></span><br><span class="line"><span class="comment">%   taking num_iters gradient steps with learning rate alpha</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% Initialize some useful values</span></span><br><span class="line">m = <span class="built_in">length</span>(y); <span class="comment">% number of training examples</span></span><br><span class="line">J_history = <span class="built_in">zeros</span>(num_iters, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> iter = <span class="number">1</span>:num_iters</span><br><span class="line"></span><br><span class="line">    <span class="comment">% ====================== YOUR CODE HERE ======================</span></span><br><span class="line">    <span class="comment">% Instructions: Perform a single gradient step on the parameter vector</span></span><br><span class="line">    <span class="comment">%               theta. </span></span><br><span class="line">    <span class="comment">%</span></span><br><span class="line">    <span class="comment">% Hint: While debugging, it can be useful to print out the values</span></span><br><span class="line">    <span class="comment">%       of the cost function (computeCost) and gradient here.</span></span><br><span class="line">    <span class="comment">%</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    x=X(:,<span class="number">2</span>);</span><br><span class="line">    theta0=theta(<span class="number">1</span>);</span><br><span class="line">    theta1=theta(<span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    theta0=theta0-alpha/m*sum(X*theta-y);</span><br><span class="line">    theta1=theta1-alpha/m*sum((X*theta-y).*x);</span><br><span class="line">    </span><br><span class="line">    theta=[theta0;theta1];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">% ============================================================</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">% Save the cost J in every iteration    </span></span><br><span class="line">    J_history(iter) = computeCost(X, y, theta);</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>现在让我们运行梯度下降算法来将我们的参数θ适合于训练集。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theta = gradientDescent(X, y, theta, alpha, iterations);</span><br></pre></td></tr></table></figure><p>原始数据以及拟合的直线</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% Plot the linear fit</span></span><br><span class="line"><span class="built_in">hold</span> on; <span class="comment">% keep previous plot visible</span></span><br><span class="line"><span class="built_in">plot</span>(X(:,<span class="number">2</span>), X*theta, <span class="string">'-'</span>)</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">'Training data'</span>, <span class="string">'Linear regression'</span>)</span><br><span class="line"><span class="built_in">hold</span> off <span class="comment">% don't overlay any more plots on this figure</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/pxlsdz/MarkDown-images/master/2020-1-27/2.png" alt=""></p><p>预测35000和70000城市规模的小吃摊利润</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% Predict values for population sizes of 35,000 and 70,000</span></span><br><span class="line">predict1 = [<span class="number">1</span>, <span class="number">3.5</span>] *theta;</span><br><span class="line">fprintf(<span class="string">'For population = 35,000, we predict a profit of %f\n'</span>,...</span><br><span class="line">    predict1*<span class="number">10000</span>);</span><br><span class="line">predict2 = [<span class="number">1</span>, <span class="number">7</span>] * theta;</span><br><span class="line">fprintf(<span class="string">'For population = 70,000, we predict a profit of %f\n'</span>,...</span><br><span class="line">    predict2*<span class="number">10000</span>);</span><br></pre></td></tr></table></figure><h2 id="2-4-可视化J-θ"><a href="#2-4-可视化J-θ" class="headerlink" title="2.4 可视化J(θ)"></a>2.4 可视化J(θ)</h2><p>此步可以便于你理解J(<em>θ</em>)以及梯度下降。 三维图显示了<em>θ</em>0和<em>θ</em>1与J(<em>θ</em>)的对应关系，J(<em>θ</em>)是一个碗状的图形，并且有全局最小值。这个最小值就是<em>θ</em>0和<em>θ</em>1的最优解。梯度下降的每一步都会更接近这个最小值。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">fprintf(<span class="string">'Visualizing J(theta_0, theta_1) ...\n'</span>)</span><br><span class="line"><span class="comment">% Grid over which we will calculate J</span></span><br><span class="line">theta0_vals = <span class="built_in">linspace</span>(<span class="number">-10</span>, <span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line">theta1_vals = <span class="built_in">linspace</span>(<span class="number">-1</span>, <span class="number">4</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% initialize J_vals to a matrix of 0's</span></span><br><span class="line">J_vals = <span class="built_in">zeros</span>(<span class="built_in">length</span>(theta0_vals), <span class="built_in">length</span>(theta1_vals));</span><br><span class="line"></span><br><span class="line"><span class="comment">% Fill out J_vals</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">length</span>(theta0_vals)</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:<span class="built_in">length</span>(theta1_vals)</span><br><span class="line">  t = [theta0_vals(<span class="built_in">i</span>); theta1_vals(<span class="built_in">j</span>)];</span><br><span class="line">  J_vals(<span class="built_in">i</span>,<span class="built_in">j</span>) = computeCost(X, y, t);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">J_vals = J_vals';</span><br><span class="line"><span class="comment">% Surface plot</span></span><br><span class="line"><span class="built_in">figure</span>;</span><br><span class="line">surf(theta0_vals, theta1_vals, J_vals)<span class="comment">%曲面图</span></span><br><span class="line">xlabel(<span class="string">'\theta_0'</span>); </span><br><span class="line">ylabel(<span class="string">'\theta_1'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% Contour plot</span></span><br><span class="line"><span class="built_in">figure</span>;</span><br><span class="line"><span class="comment">% Plot J_vals as 15 contours spaced logarithmically between 0.01 and 100</span></span><br><span class="line">contour(theta0_vals, theta1_vals, J_vals, <span class="built_in">logspace</span>(<span class="number">-2</span>, <span class="number">3</span>, <span class="number">20</span>))<span class="comment">%矩阵的等高线图</span></span><br><span class="line"><span class="comment">%（logspace函数和linspace函数类似，此处作用生成将区间[10-2,103]等分20份的1*20矩阵）</span></span><br><span class="line">xlabel(<span class="string">'\theta_0'</span>);</span><br><span class="line">ylabel(<span class="string">'\theta_1'</span>);</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line"><span class="built_in">plot</span>(theta(<span class="number">1</span>), theta(<span class="number">2</span>), <span class="string">'rx'</span>, <span class="string">'MarkerSize'</span>, <span class="number">10</span>, <span class="string">'LineWidth'</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>结果如下：</p><ul><li><p>从图中可看出代价函数值<strong><em>J\</em>(θ)</strong>有全局最优解（最低点）</p></li><li><p>可以看出我们求出的最优参数θ所对应的代价值，正好位于等高线图最低的位置</p><p><img src="https://raw.githubusercontent.com/pxlsdz/MarkDown-images/master/2020-1-27/3.png" alt=""></p><p><img src="https://raw.githubusercontent.com/pxlsdz/MarkDown-images/master/2020-1-27/4.png" alt=""></p><h2 id="2-5完整代码"><a href="#2-5完整代码" class="headerlink" title="2.5完整代码"></a>2.5完整代码</h2><h3 id="2-5-1-主代码"><a href="#2-5-1-主代码" class="headerlink" title="2.5.1 主代码"></a>2.5.1 主代码</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">A = <span class="built_in">eye</span>(<span class="number">5</span>);</span><br><span class="line">  </span><br><span class="line">  fprintf(<span class="string">'Plotting Data ...\n'</span>)</span><br><span class="line">  data = load(<span class="string">'ex1data1.txt'</span>);</span><br><span class="line">  x= data(:, <span class="number">1</span>); <span class="comment">% 表示data矩阵的第一列所有行， 并且取转置</span></span><br><span class="line">  y =data(:, <span class="number">2</span>);</span><br><span class="line">  m = <span class="built_in">length</span>(y); <span class="comment">% number of training examples</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="built_in">plot</span>(x, y, <span class="string">'rx'</span>, <span class="string">'MarkerSize'</span>, <span class="number">10</span>); <span class="comment">% Plot the data </span></span><br><span class="line">  <span class="comment">%绘制图形：rx代表图形中标记的点为红色的x，数字10表示标记的大小。</span></span><br><span class="line">  ylabel(<span class="string">'Profit in $10,000s'</span>); <span class="comment">% Set the y−axis label </span></span><br><span class="line">  xlabel(<span class="string">'Population of City in 10,000s'</span>); <span class="comment">% Set the x−axis label </span></span><br><span class="line">  </span><br><span class="line">  fprintf(<span class="string">'Program paused. Press enter to continue.\n'</span>);</span><br><span class="line">  pause;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  X = [<span class="built_in">ones</span>(m, <span class="number">1</span>), data(:,<span class="number">1</span>)]; <span class="comment">% Add a column of ones to x</span></span><br><span class="line">  theta = <span class="built_in">zeros</span>(<span class="number">2</span>, <span class="number">1</span>); <span class="comment">% initialize fitting parameters</span></span><br><span class="line">  iterations = <span class="number">1500</span>;</span><br><span class="line">  alpha = <span class="number">0.01</span>;</span><br><span class="line">  </span><br><span class="line">  fprintf(<span class="string">'\nTesting the cost function ...\n'</span>)</span><br><span class="line">  <span class="comment">% compute and display initial cost</span></span><br><span class="line">  J = computeCost(X, y, theta);</span><br><span class="line">  fprintf(<span class="string">'With theta = [0 ; 0]\nCost computed = %f\n'</span>, J);</span><br><span class="line">  fprintf(<span class="string">'Expected cost value (approx) 32.07\n'</span>);</span><br><span class="line">  </span><br><span class="line">  fprintf(<span class="string">'Program paused. Press enter to continue.\n'</span>);</span><br><span class="line">  pause;</span><br><span class="line">  </span><br><span class="line">  fprintf(<span class="string">'\nRunning Gradient Descent ...\n'</span>)</span><br><span class="line">  <span class="comment">% run gradient descent</span></span><br><span class="line">  theta = gradientDescent(X, y, theta, alpha, iterations);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">% print theta to screen</span></span><br><span class="line">  fprintf(<span class="string">'Theta found by gradient descent:\n'</span>);</span><br><span class="line">  fprintf(<span class="string">'%f\n'</span>, theta);</span><br><span class="line">  fprintf(<span class="string">'Expected theta values (approx)\n'</span>);</span><br><span class="line">  fprintf(<span class="string">' -3.6303\n  1.1664\n\n'</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">% Plot the linear fit</span></span><br><span class="line">  <span class="built_in">hold</span> on; <span class="comment">% keep previous plot visible</span></span><br><span class="line">  <span class="built_in">plot</span>(X(:,<span class="number">2</span>), X*theta, <span class="string">'-'</span>)</span><br><span class="line">  <span class="built_in">legend</span>(<span class="string">'Training data'</span>, <span class="string">'Linear regression'</span>)</span><br><span class="line">  <span class="built_in">hold</span> off <span class="comment">% don't overlay any more plots on this figure</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">% Predict values for population sizes of 35,000 and 70,000</span></span><br><span class="line">  predict1 = [<span class="number">1</span>, <span class="number">3.5</span>] *theta;</span><br><span class="line">  fprintf(<span class="string">'For population = 35,000, we predict a profit of %f\n'</span>,...</span><br><span class="line">      predict1*<span class="number">10000</span>);</span><br><span class="line">  predict2 = [<span class="number">1</span>, <span class="number">7</span>] * theta;</span><br><span class="line">  fprintf(<span class="string">'For population = 70,000, we predict a profit of %f\n'</span>,...</span><br><span class="line">      predict2*<span class="number">10000</span>);</span><br><span class="line">  </span><br><span class="line">  fprintf(<span class="string">'Program paused. Press enter to continue.\n'</span>);</span><br><span class="line">  pause;</span><br><span class="line">  </span><br><span class="line">  fprintf(<span class="string">'Visualizing J(theta_0, theta_1) ...\n'</span>)</span><br><span class="line">  <span class="comment">% Grid over which we will calculate J</span></span><br><span class="line">  theta0_vals = <span class="built_in">linspace</span>(<span class="number">-10</span>, <span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line">  theta1_vals = <span class="built_in">linspace</span>(<span class="number">-1</span>, <span class="number">4</span>, <span class="number">100</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">% initialize J_vals to a matrix of 0's</span></span><br><span class="line">  J_vals = <span class="built_in">zeros</span>(<span class="built_in">length</span>(theta0_vals), <span class="built_in">length</span>(theta1_vals));</span><br><span class="line">  </span><br><span class="line">  <span class="comment">% Fill out J_vals</span></span><br><span class="line">  <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">length</span>(theta0_vals)</span><br><span class="line">      <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:<span class="built_in">length</span>(theta1_vals)</span><br><span class="line">    t = [theta0_vals(<span class="built_in">i</span>); theta1_vals(<span class="built_in">j</span>)];</span><br><span class="line">    J_vals(<span class="built_in">i</span>,<span class="built_in">j</span>) = computeCost(X, y, t);</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  </span><br><span class="line">  J_vals = J_vals';</span><br><span class="line">  <span class="comment">% Surface plot</span></span><br><span class="line">  <span class="built_in">figure</span>;</span><br><span class="line">  surf(theta0_vals, theta1_vals, J_vals)<span class="comment">%曲面图</span></span><br><span class="line">  xlabel(<span class="string">'\theta_0'</span>); </span><br><span class="line">  ylabel(<span class="string">'\theta_1'</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">% Contour plot</span></span><br><span class="line">  <span class="built_in">figure</span>;</span><br><span class="line">  <span class="comment">% Plot J_vals as 15 contours spaced logarithmically between 0.01 and 100</span></span><br><span class="line">  contour(theta0_vals, theta1_vals, J_vals, <span class="built_in">logspace</span>(<span class="number">-2</span>, <span class="number">3</span>, <span class="number">20</span>))<span class="comment">%矩阵的等高线图</span></span><br><span class="line">  <span class="comment">%（logspace函数和linspace函数类似，此处作用生成将区间[10-2,103]等分20份的1*20矩阵）</span></span><br><span class="line">  xlabel(<span class="string">'\theta_0'</span>);</span><br><span class="line">  ylabel(<span class="string">'\theta_1'</span>);</span><br><span class="line">  <span class="built_in">hold</span> on;</span><br><span class="line">  <span class="built_in">plot</span>(theta(<span class="number">1</span>), theta(<span class="number">2</span>), <span class="string">'rx'</span>, <span class="string">'MarkerSize'</span>, <span class="number">10</span>, <span class="string">'LineWidth'</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-5-2-求梯度代码"><a href="#2-5-2-求梯度代码" class="headerlink" title="2.5.2 求梯度代码"></a>2.5.2 求梯度代码</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[theta, J_history]</span> = <span class="title">gradientDescent</span><span class="params">(X, y, theta, alpha, num_iters)</span></span></span><br><span class="line"><span class="comment">%GRADIENTDESCENT Performs gradient descent to learn theta</span></span><br><span class="line"><span class="comment">%   theta = GRADIENTDESCENT(X, y, theta, alpha, num_iters) updates theta by </span></span><br><span class="line"><span class="comment">%   taking num_iters gradient steps with learning rate alpha</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% Initialize some useful values</span></span><br><span class="line">m = <span class="built_in">length</span>(y); <span class="comment">% number of training examples</span></span><br><span class="line">J_history = <span class="built_in">zeros</span>(num_iters, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> iter = <span class="number">1</span>:num_iters</span><br><span class="line"></span><br><span class="line">    <span class="comment">% ====================== YOUR CODE HERE ======================</span></span><br><span class="line">    <span class="comment">% Instructions: Perform a single gradient step on the parameter vector</span></span><br><span class="line">    <span class="comment">%               theta. </span></span><br><span class="line">    <span class="comment">%</span></span><br><span class="line">    <span class="comment">% Hint: While debugging, it can be useful to print out the values</span></span><br><span class="line">    <span class="comment">%       of the cost function (computeCost) and gradient here.</span></span><br><span class="line">    <span class="comment">%</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    x=X(:,<span class="number">2</span>);</span><br><span class="line">    theta0=theta(<span class="number">1</span>);</span><br><span class="line">    theta1=theta(<span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    theta0=theta0-alpha/m*sum(X*theta-y);</span><br><span class="line">    theta1=theta1-alpha/m*sum((X*theta-y).*x);</span><br><span class="line">    </span><br><span class="line">    theta=[theta0;theta1];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">% ============================================================</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">% Save the cost J in every iteration    </span></span><br><span class="line">    J_history(iter) = computeCost(X, y, theta);</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="2-5-3-计算代价函数"><a href="#2-5-3-计算代价函数" class="headerlink" title="2.5.3 计算代价函数"></a>2.5.3 计算代价函数</h3>  <figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">J</span> = <span class="title">computeCost</span><span class="params">(X, y, theta)</span></span></span><br><span class="line"><span class="comment">%COMPUTECOST Compute cost for linear regression</span></span><br><span class="line"><span class="comment">%   J = COMPUTECOST(X, y, theta) computes the cost of using theta as the</span></span><br><span class="line"><span class="comment">%   parameter for linear regression to fit the data points in X and y</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% Initialize some useful values</span></span><br><span class="line">m = <span class="built_in">length</span>(y); <span class="comment">% number of training examples</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% You need to return the following variables correctly </span></span><br><span class="line">J = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">% ====================== YOUR CODE HERE ======================</span></span><br><span class="line"><span class="comment">% Instructions: Compute the cost of a particular choice of theta</span></span><br><span class="line"><span class="comment">%               You should set J to the cost.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%计算代价函数</span></span><br><span class="line">J=sum((X*theta-y).^<span class="number">2</span>)/(<span class="number">2</span>*m);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">% =========================================================================</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h1 id="3-多变量线性回归"><a href="#3-多变量线性回归" class="headerlink" title="3 多变量线性回归"></a>3 多变量线性回归</h1><p>ex1data2.txt里的数据，第一列是房屋大小，第二列是卧室数量，第三列是房屋售价 根据已有数据，建立模型，预测房屋的售价</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%%加载数据</span></span><br><span class="line">data = load(<span class="string">'ex1data2.txt'</span>);</span><br><span class="line">X=data(:,<span class="number">1</span>:<span class="number">2</span>)</span><br><span class="line">y=data(:,<span class="number">3</span>)</span><br><span class="line">m=<span class="built_in">length</span>(y)</span><br><span class="line"></span><br><span class="line"><span class="comment">% Print out some data points</span></span><br><span class="line">fprintf(<span class="string">'First 10 examples from the dataset: \n'</span>);</span><br><span class="line">fprintf(<span class="string">' x = [%.0f %.0f], y = %.0f \n'</span>, [X(<span class="number">1</span>:<span class="number">10</span>,:) y(<span class="number">1</span>:<span class="number">10</span>,:)]');</span><br><span class="line"></span><br><span class="line">fprintf(<span class="string">'Program paused. Press enter to continue.\n'</span>);</span><br><span class="line">pause;</span><br></pre></td></tr></table></figure><h2 id="3-1-特征归一化"><a href="#3-1-特征归一化" class="headerlink" title="3.1 特征归一化"></a>3.1 特征归一化</h2><p>观察数据发现，size变量是bedrooms变量的1000倍大小,统一量级会让梯度下降收敛的更快。做法就是:<strong>将每类特征减去他的平均值后除以标准差</strong><br>$$<br>x_{n}=\frac{X_{n}-u_{n} }{s_{n} }<br>$$<br>$u_{n}$是平均值，$s_{n}$是标准差</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[X_norm, mu, sigma]</span> = <span class="title">featureNormalize</span><span class="params">(X)</span></span></span><br><span class="line"><span class="comment">%FEATURENORMALIZE Normalizes the features in X </span></span><br><span class="line"><span class="comment">%   FEATURENORMALIZE(X) returns a normalized version of X where</span></span><br><span class="line"><span class="comment">%   the mean value of each feature is 0 and the standard deviation</span></span><br><span class="line"><span class="comment">%   is 1. This is often a good preprocessing step to do when</span></span><br><span class="line"><span class="comment">%   working with learning algorithms.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% You need to set these values correctly</span></span><br><span class="line">X_norm = X;</span><br><span class="line">mu = <span class="built_in">zeros</span>(<span class="number">1</span>, <span class="built_in">size</span>(X, <span class="number">2</span>));</span><br><span class="line">sigma = <span class="built_in">zeros</span>(<span class="number">1</span>, <span class="built_in">size</span>(X, <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">% ====================== YOUR CODE HERE ======================</span></span><br><span class="line"><span class="comment">% Instructions: First, for each feature dimension, compute the mean</span></span><br><span class="line"><span class="comment">%               of the feature and subtract it from the dataset,</span></span><br><span class="line"><span class="comment">%               storing the mean value in mu. Next, compute the </span></span><br><span class="line"><span class="comment">%               standard deviation of each feature and divide</span></span><br><span class="line"><span class="comment">%               each feature by it's standard deviation, storing</span></span><br><span class="line"><span class="comment">%               the standard deviation in sigma. </span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">%               Note that X is a matrix where each column is a </span></span><br><span class="line"><span class="comment">%               feature and each row is an example. You need </span></span><br><span class="line"><span class="comment">%               to perform the normalization separately for </span></span><br><span class="line"><span class="comment">%               each feature. </span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">% Hint: You might find the 'mean' and 'std' functions useful.</span></span><br><span class="line"><span class="comment">%       </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mu=<span class="built_in">mean</span>(X)</span><br><span class="line">sigma=std(X)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">size</span>(X,<span class="number">2</span>),</span><br><span class="line">    X_norm(:,<span class="built_in">i</span>) = (X(:,<span class="built_in">i</span>) - mu(<span class="built_in">i</span>)) / sigma(<span class="built_in">i</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">% ============================================================</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>主函数运行：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% Scale features and set them to zero mean</span></span><br><span class="line">fprintf(<span class="string">'Normalizing Features ...\n'</span>);</span><br><span class="line"></span><br><span class="line">[X mu sigma] = featureNormalize(X);</span><br><span class="line"></span><br><span class="line"><span class="comment">% Add intercept term to X</span></span><br><span class="line">X = [<span class="built_in">ones</span>(m, <span class="number">1</span>) X];</span><br></pre></td></tr></table></figure><h2 id="3-2-代价函数和梯度下降"><a href="#3-2-代价函数和梯度下降" class="headerlink" title="3.2 代价函数和梯度下降"></a>3.2 代价函数和梯度下降</h2><p>代价函数：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">J</span> = <span class="title">computeCostMulti</span><span class="params">(X, y, theta)</span></span></span><br><span class="line"><span class="comment">%COMPUTECOSTMULTI Compute cost for linear regression with multiple variables</span></span><br><span class="line"><span class="comment">%   J = COMPUTECOSTMULTI(X, y, theta) computes the cost of using theta as the</span></span><br><span class="line"><span class="comment">%   parameter for linear regression to fit the data points in X and y</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% Initialize some useful values</span></span><br><span class="line">m = <span class="built_in">length</span>(y); <span class="comment">% number of training examples</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% You need to return the following variables correctly </span></span><br><span class="line">J = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">% ====================== YOUR CODE HERE ======================</span></span><br><span class="line"><span class="comment">% Instructions: Compute the cost of a particular choice of theta</span></span><br><span class="line"><span class="comment">%               You should set J to the cost.</span></span><br><span class="line"></span><br><span class="line">J = ((X * theta - y)' * (X * theta - y))/(<span class="number">2</span>*m);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">% =========================================================================</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>梯度下降：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[theta, J_history]</span> = <span class="title">gradientDescentMulti</span><span class="params">(X, y, theta, alpha, num_iters)</span></span></span><br><span class="line"><span class="comment">%GRADIENTDESCENTMULTI Performs gradient descent to learn theta</span></span><br><span class="line"><span class="comment">%   theta = GRADIENTDESCENTMULTI(x, y, theta, alpha, num_iters) updates theta by</span></span><br><span class="line"><span class="comment">%   taking num_iters gradient steps with learning rate alpha</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% Initialize some useful values</span></span><br><span class="line">m = <span class="built_in">length</span>(y); <span class="comment">% number of training examples</span></span><br><span class="line">J_history = <span class="built_in">zeros</span>(num_iters, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> iter = <span class="number">1</span>:num_iters</span><br><span class="line"></span><br><span class="line">    <span class="comment">% ====================== YOUR CODE HERE ======================</span></span><br><span class="line">    <span class="comment">% Instructions: Perform a single gradient step on the parameter vector</span></span><br><span class="line">    <span class="comment">%               theta. </span></span><br><span class="line">    <span class="comment">%</span></span><br><span class="line">    <span class="comment">% Hint: While debugging, it can be useful to print out the values</span></span><br><span class="line">    <span class="comment">%       of the cost function (computeCostMulti) and gradient here.</span></span><br><span class="line">    <span class="comment">%</span></span><br><span class="line">    </span><br><span class="line">    theta = theta - alpha / m * X' * (X * theta - y);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">% ============================================================</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">% Save the cost J in every iteration    </span></span><br><span class="line">    J_history(iter) = computeCostMulti(X, y, theta);</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="3-3梯度下降的完整代码"><a href="#3-3梯度下降的完整代码" class="headerlink" title="3.3梯度下降的完整代码"></a>3.3梯度下降的完整代码</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">%%加载数据</span></span><br><span class="line">data = load(<span class="string">'ex1data2.txt'</span>);</span><br><span class="line">X=data(:,<span class="number">1</span>:<span class="number">2</span>)</span><br><span class="line">y=data(:,<span class="number">3</span>)</span><br><span class="line">m=<span class="built_in">length</span>(y)</span><br><span class="line"></span><br><span class="line"><span class="comment">% Print out some data points</span></span><br><span class="line">fprintf(<span class="string">'First 10 examples from the dataset: \n'</span>);</span><br><span class="line">fprintf(<span class="string">' x = [%.0f %.0f], y = %.0f \n'</span>, [X(<span class="number">1</span>:<span class="number">10</span>,:) y(<span class="number">1</span>:<span class="number">10</span>,:)]');</span><br><span class="line"></span><br><span class="line">fprintf(<span class="string">'Program paused. Press enter to continue.\n'</span>);</span><br><span class="line">pause;</span><br><span class="line"></span><br><span class="line"><span class="comment">% Scale features and set them to zero mean</span></span><br><span class="line">fprintf(<span class="string">'Normalizing Features ...\n'</span>);</span><br><span class="line"></span><br><span class="line">[X mu sigma] = featureNormalize(X);</span><br><span class="line"></span><br><span class="line"><span class="comment">% Add intercept term to X</span></span><br><span class="line">X = [<span class="built_in">ones</span>(m, <span class="number">1</span>) X];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fprintf(<span class="string">'Running gradient descent ...\n'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% Choose some alpha value</span></span><br><span class="line">alpha = <span class="number">0.01</span>;</span><br><span class="line">num_iters = <span class="number">400</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">% Init Theta and Run Gradient Descent </span></span><br><span class="line">theta = <span class="built_in">zeros</span>(<span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line">[theta, J_history] = gradientDescentMulti(X, y, theta, alpha, num_iters);</span><br><span class="line"></span><br><span class="line"><span class="comment">% Plot the convergence graph</span></span><br><span class="line"><span class="built_in">figure</span>;</span><br><span class="line"><span class="built_in">plot</span>(<span class="number">1</span>:<span class="built_in">numel</span>(J_history), J_history, <span class="string">'-b'</span>, <span class="string">'LineWidth'</span>, <span class="number">2</span>);</span><br><span class="line">xlabel(<span class="string">'Number of iterations'</span>);</span><br><span class="line">ylabel(<span class="string">'Cost J'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% Display gradient descent's result</span></span><br><span class="line">fprintf(<span class="string">'Theta computed from gradient descent: \n'</span>);</span><br><span class="line">fprintf(<span class="string">' %f \n'</span>, theta);</span><br><span class="line">fprintf(<span class="string">'\n'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% Estimate the price of a 1650 sq-ft, 3 br house</span></span><br><span class="line"><span class="comment">% ====================== YOUR CODE HERE ======================</span></span><br><span class="line"><span class="comment">% Recall that the first column of X is all-ones. Thus, it does</span></span><br><span class="line"><span class="comment">% not need to be normalized.</span></span><br><span class="line">price = [<span class="number">1</span>,<span class="number">1650</span>,<span class="number">3</span>]*theta; <span class="comment">% You should change this</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% ============================================================</span></span><br><span class="line">fprintf([<span class="string">'Predicted price of a 1650 sq-ft, 3 br house '</span> ...</span><br><span class="line">         <span class="string">'(using gradient descent):\n $%f\n'</span>], price);</span><br><span class="line"></span><br><span class="line">fprintf(<span class="string">'Program paused. Press enter to continue.\n'</span>);</span><br><span class="line">pause;</span><br></pre></td></tr></table></figure><p>图片（选择学习速率）</p><p><img src="https://images2018.cnblogs.com/blog/1342883/201803/1342883-20180309144200582-1981235826.png" alt=""></p><h2 id="3-4-正规方程"><a href="#3-4-正规方程" class="headerlink" title="3.4 正规方程"></a>3.4 正规方程</h2><p>正规方程是通过求解下面的方程来找出使得代价函数最小的参数的：$\frac{\partial}{\partial \theta_{j} }J(\theta_{j})=0$ 。 假设我们的训练集特征矩阵为 X（包含了<strong>x0=1</strong>）并且我们的训练集结果为向量 y，则利用正规方程解出向量$(X^{T}X)^{-1}X^{T}y$ 。 上标T代表矩阵转置，上标-1 代表矩阵的逆。设矩阵$A=X^{T}X$,则$A^{-1}=(X^{T}X)^{-1}$</p><p><img src="https://raw.githubusercontent.com/pxlsdz/MarkDown-images/master/2020-1-27/5.png" alt=""></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[theta]</span> = <span class="title">normalEqn</span><span class="params">(X, y)</span></span></span><br><span class="line"><span class="comment">%NORMALEQN Computes the closed-form solution to linear regression </span></span><br><span class="line"><span class="comment">%   NORMALEQN(X,y) computes the closed-form solution to linear </span></span><br><span class="line"><span class="comment">%   regression using the normal equations.</span></span><br><span class="line"></span><br><span class="line">theta = <span class="built_in">zeros</span>(<span class="built_in">size</span>(X, <span class="number">2</span>), <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% ====================== YOUR CODE HERE ======================</span></span><br><span class="line"><span class="comment">% Instructions: Complete the code to compute the closed form solution</span></span><br><span class="line"><span class="comment">%               to linear regression and put the result in theta.</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% ---------------------- Sample Solution ----------------------</span></span><br><span class="line"></span><br><span class="line">theta = pinv(X' * X) * X' * y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">% -------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">% ============================================================</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>主函数完整代码</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% ================ Part 3: Normal Equations ================</span></span><br><span class="line"></span><br><span class="line">fprintf(<span class="string">'Solving with normal equations...\n'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% ====================== YOUR CODE HERE ======================</span></span><br><span class="line"><span class="comment">% Instructions: The following code computes the closed form </span></span><br><span class="line"><span class="comment">%               solution for linear regression using the normal</span></span><br><span class="line"><span class="comment">%               equations. You should complete the code in </span></span><br><span class="line"><span class="comment">%               normalEqn.m</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">%               After doing so, you should complete this code </span></span><br><span class="line"><span class="comment">%               to predict the price of a 1650 sq-ft, 3 br house.</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% Load Data</span></span><br><span class="line">data = csvread(<span class="string">'ex1data2.txt'</span>);</span><br><span class="line">X = data(:, <span class="number">1</span>:<span class="number">2</span>);</span><br><span class="line">y = data(:, <span class="number">3</span>);</span><br><span class="line">m = <span class="built_in">length</span>(y);</span><br><span class="line"></span><br><span class="line"><span class="comment">% Add intercept term to X</span></span><br><span class="line">X = [<span class="built_in">ones</span>(m, <span class="number">1</span>) X];</span><br><span class="line"></span><br><span class="line"><span class="comment">% Calculate the parameters from the normal equation</span></span><br><span class="line">theta = normalEqn(X, y);</span><br><span class="line"></span><br><span class="line"><span class="comment">% Display normal equation's result</span></span><br><span class="line">fprintf(<span class="string">'Theta computed from the normal equations: \n'</span>);</span><br><span class="line">fprintf(<span class="string">' %f \n'</span>, theta);</span><br><span class="line">fprintf(<span class="string">'\n'</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">% Estimate the price of a 1650 sq-ft, 3 br house</span></span><br><span class="line"><span class="comment">% ====================== YOUR CODE HERE ======================</span></span><br><span class="line">price = [<span class="number">1</span>,<span class="number">1650</span>,<span class="number">3</span>]*theta; <span class="comment">% You should change this</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">% ============================================================</span></span><br><span class="line"></span><br><span class="line">fprintf([<span class="string">'Predicted price of a 1650 sq-ft, 3 br house '</span> ...</span><br><span class="line">         <span class="string">'(using normal equations):\n $%f\n'</span>], price);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MATLAB </tag>
            
            <tag> 线性回归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>相关系数</title>
      <link href="/2020/01/27/%E7%9B%B8%E5%85%B3%E7%B3%BB%E6%95%B0/"/>
      <url>/2020/01/27/%E7%9B%B8%E5%85%B3%E7%B3%BB%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="相关系数-皮尔逊相关系数"><a href="#相关系数-皮尔逊相关系数" class="headerlink" title="相关系数(皮尔逊相关系数)"></a>相关系数(皮尔逊相关系数)</h1><a id="more"></a><p>（1）如果两个变量本身就是<strong>线性的关系</strong>，那么皮尔逊相关系数绝对值大的就是相关性强，小的就是相关性弱；<br>（2）在不确定两个变量是什么关系的情况下，即使算出皮尔逊相关系数，发现很大，也不能说明那两个变量线性相关，甚至不能说他们相关，我们一定要画出散点图（spss很方便）来看才行。</p><p><font color=red><strong>事实上，比起相关系数的大小，我们往往更关注的是显著性。（假设检验）</strong></font></p><h1 id="假设检验"><a href="#假设检验" class="headerlink" title="假设检验"></a>假设检验</h1><h2 id="对皮尔逊相关系数进行假设检验"><a href="#对皮尔逊相关系数进行假设检验" class="headerlink" title="对皮尔逊相关系数进行假设检验"></a>对皮尔逊相关系数进行假设检验</h2><ol><li><p>第一步：提出原假设H0和备择假设H1</p><p>两个假设是截然相反,假设我们计算出了一个皮尔逊相关系数r，我们想检验它是否显著的异于0.那么我们可以这样设定原假设和备择假设：H0：r=0,H1:r≠0</p></li><li><p>第二步：在原假设成立的条件下，利用我们要检验的量构造出一个符合某一分布的统计量</p><p>（注1：统计量相当于我们要检验的量的一个函数，里面不能有其他的随机变量）<br>（注2：这里的分布一般有四种：标准正态分布、t分布、x2分布和F分布）</p><p>对于皮尔逊相关系数r而言，在满足一定条件下，我们可以构造统计量：<br>$$<br>t = r\sqrt{(n-2)/(1-r^{2})}<br>$$</p></li></ol><p>   可以证明t是服从自由度为n-2的t分布</p><ol start="3"><li><p>第三步：将我们要检验的这个值带入这个统计量中，可以得到一个特定的值（检验值）。<br>假设我们现在计算出来的相关系数为0.5，样本为30，那么我们带入第二步公式可以得到$t^{*}=3.05505$</p></li><li><p>第四步：由于我们知道统计量的分布情况，因此我们可以画出该分布的概率密度函数pdf，并给定一个置信水平，根据这个置信水平查表找到临界值，并画出检验统计量的接受域和拒绝域。<br>例如，我们知道上述统计量服从自由度为28的t分布，代码</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">-4</span>:<span class="number">0.1</span>:<span class="number">4</span>;</span><br><span class="line">y = tpdf(x,<span class="number">28</span>);</span><br><span class="line"><span class="built_in">plot</span>(x,y,<span class="string">'-'</span>)</span><br><span class="line">grid on <span class="comment">% 在画出的图上加上网格线</span></span><br></pre></td></tr></table></figure><p>常见的置信水平有三个：90%，95%和99%，其中95%是三者中最为常用的。<br>因为我们这里是双侧检验，所以我们需要找出能覆盖0.95概率的部分t分布表：<a href="https://wenku.baidu.com/view/d94dbd116bd97f192279e94a.html" target="_blank" rel="noopener">https://wenku.baidu.com/view/d94dbd116bd97f192279e94a.html</a></p><p>查表可知，对应的临界值为2.048，因此我们可以做出接受域和拒绝域。</p></li><li><p>第五步：看我们计算出来的检验值是落在了拒绝域还是接受域，并下结论。因为我们得到的t*=3.05505&gt;2.048，因此我们可以下结论：<br>在95%的置信水平上，我们拒绝原假设H0:r=0，因此r是显著的不为0的。</p></li></ol><h2 id="p值判断法"><a href="#p值判断法" class="headerlink" title="p值判断法"></a>p值判断法</h2><p>我们得到的检验值t*=3.05505，根据这个值，我们可以计算出其对应的那个概率。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">disp</span>(<span class="string">'该检验值对应的p值为： '</span>)</span><br><span class="line"><span class="built_in">disp</span>((<span class="number">1</span>-tcdf(<span class="number">3.055</span>,<span class="number">28</span>))*<span class="number">2</span>)</span><br><span class="line"><span class="comment">%双侧检验的p值要乘以2</span></span><br></pre></td></tr></table></figure><ul><li>p&lt;0.01，说明在99%的置信水平上拒绝原假设；p值&gt;0.01，说明在99%的置信水平无法拒绝原假设；</li><li>p&lt;0.05，说明在95%的置信水平上拒绝原假设；p&gt;0.05，说明在95%的置信水平上无法拒绝原假设：</li><li>p&lt;0.10，说明在90%的置信水平上拒绝原假设；p&gt;0.10，说明在90%的置信水平上无法拒绝原假设；</li></ul><p>小补充： $0.5、 0.5* 、 0.5<strong>、 0.5*</strong>$的含义是什么？（显著性标记）  </p><ul><li>0.5*:90%的水平上显著异于0，p&lt;0.1</li><li>0.5**:95%的水平上显著异于0，p&lt;0.05</li><li>0.5***:99%的水平上显著异于0，p&lt;0.01</li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% 计算各列之间的相关系数以及p值</span></span><br><span class="line">[R,P] = corrcoef(Test)</span><br><span class="line"><span class="comment">% 在EXCEL表格中给数据右上角标上显著性符号吧</span></span><br><span class="line">P &lt; <span class="number">0.01</span> <span class="comment">% 标记3颗星的位置</span></span><br><span class="line">(P &lt; <span class="number">0.05</span>) .* (P &gt; <span class="number">0.01</span>) <span class="comment">% 标记2颗星的位置</span></span><br><span class="line">(P &lt; <span class="number">0.1</span>) .* (P &gt; <span class="number">0.05</span>) <span class="comment">% 标记1颗星的位置</span></span><br></pre></td></tr></table></figure><h2 id="皮尔逊相关系数假设检验的条件"><a href="#皮尔逊相关系数假设检验的条件" class="headerlink" title="皮尔逊相关系数假设检验的条件"></a>皮尔逊相关系数假设检验的条件</h2><p>第一， <strong>实验数据通常假设是成对的来自于正态分布的总体(需要验证）</strong>。 因为我们在求皮尔逊相关性系数以后，通常还会用t检验之类的方法来进行皮尔逊相关性系数检验，而t检验是基于数据呈正态分布的假设的。<br>第二， <strong>实验数据之间的差距不能太大</strong>。 皮尔逊相关性系数受异常值的影响比较<br>大。<br>第三：<strong>每组样本之间是独立抽样的</strong>。 构造t统计量时需要用到。  </p><h3 id="正态分布JB检验（大样本-n-gt-30）"><a href="#正态分布JB检验（大样本-n-gt-30）" class="headerlink" title="正态分布JB检验（大样本 n&gt;30）"></a>正态分布JB检验（大样本 n&gt;30）</h3><p>对于一个随机变量{Xi}，假设其偏度为s，峰度为K，那么我们可以构造JB统计量：<br>$$<br>JB=\frac{n}{6}[S^{2}+\frac{(k-3)^{2} }{4}]<br>$$<br>可以证明，如果{Xi}是正态分布，那么在大样本情况下JB-x（2）（自由度为2的卡方分布）</p><p>正态分布的偏度为0，峰度为3</p><p>那么进行假设检验的步骤如下：<br>H0：该随机变量服从正态分布 </p><p>H1：该随机变量不服从正态分布</p><p>然后计算该变量的偏度和峰度，得到检验值JB*，并计算出其对应的p值</p><p>将p值与0.05比较，如果小于0.05则可拒绝原假设，否则我们不能拒绝原假设。</p><p>MATLAB中进行JB检验的语法： [h,p] = jbtest(x,alpha)<br>当输出h等于1时，表示拒绝原假设； h等于0则代表不能拒绝原假设。<br>alpha就是显著性水平，一般取0.05，此时置信水平为1‐0.05=0.95<br>x就是我们要检验的随机变量，注意这里的x只能是向量。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">%% 假设检验部分</span><br><span class="line">x &#x3D; -4:0.1:4;</span><br><span class="line">y &#x3D; tpdf(x,28);  %求t分布的概率密度值 28是自由度  </span><br><span class="line">figure(1)</span><br><span class="line">plot(x,y,&#39;-&#39;)</span><br><span class="line">grid on  % 在画出的图上加上网格线</span><br><span class="line">hold on  % 保留原来的图，以便继续在上面操作</span><br><span class="line">% matlab可以求出临界值，函数如下</span><br><span class="line">tinv(0.975,28)    %    2.0484</span><br><span class="line">% 这个函数是累积密度函数cdf的反函数</span><br><span class="line">plot([-2.048,-2.048],[0,tpdf(-2.048,28)],&#39;r-&#39;)</span><br><span class="line">plot([2.048,2.048],[0,tpdf(2.048,28)],&#39;r-&#39;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">%% 计算p值</span><br><span class="line">x &#x3D; -4:0.1:4;</span><br><span class="line">y &#x3D; tpdf(x,28);</span><br><span class="line">figure(2)</span><br><span class="line">plot(x,y,&#39;-&#39;)</span><br><span class="line">grid on </span><br><span class="line">hold on</span><br><span class="line">% 画线段的方法</span><br><span class="line">plot([-3.055,-3.055],[0,tpdf(-3.055,28)],&#39;r-&#39;)</span><br><span class="line">plot([3.055,3.055],[0,tpdf(3.055,28)],&#39;r-&#39;)</span><br><span class="line">disp(&#39;该检验值对应的p值为：&#39;)</span><br><span class="line">disp((1-tcdf(3.055,28))*2)  %双侧检验的p值要乘以2</span><br><span class="line"></span><br><span class="line">%% 计算各列之间的相关系数以及p值</span><br><span class="line">[R,P] &#x3D; corrcoef(Test)</span><br><span class="line">% 在EXCEL表格中给数据右上角标上显著性符号吧</span><br><span class="line">P &lt; 0.01  % 标记3颗星的位置</span><br><span class="line">(P &lt; 0.05) .* (P &gt; 0.01)  % 标记2颗星的位置</span><br><span class="line">(P &lt; 0.1) .* (P &gt; 0.05) % % 标记1颗星的位置</span><br><span class="line">% 也可以使用Spss操作哦 看我演示</span><br><span class="line"></span><br><span class="line">%% 正态分布检验</span><br><span class="line">% 正态分布的偏度和峰度</span><br><span class="line">x &#x3D; normrnd(2,3,100,1);   % 生成100*1的随机向量，每个元素是均值为2，标准差为3的正态分布</span><br><span class="line">skewness(x)  %偏度</span><br><span class="line">kurtosis(x)  %峰度</span><br><span class="line">qqplot(x)</span><br><span class="line">    </span><br><span class="line">% 检验第一列数据是否为正态分布</span><br><span class="line">[h,p] &#x3D; jbtest(Test(:,1),0.05)%只能一组一组检验</span><br><span class="line">[h,p] &#x3D; jbtest(Test(:,1),0.01)</span><br><span class="line"></span><br><span class="line">% 用循环检验所有列的数据</span><br><span class="line">n_c &#x3D; size(Test,2);  % number of column 数据的列数</span><br><span class="line">H &#x3D; zeros(1,6);  % 初始化节省时间和消耗</span><br><span class="line">P &#x3D; zeros(1,6);</span><br><span class="line">for i &#x3D; 1:n_c</span><br><span class="line">    [h,p] &#x3D; jbtest(Test(:,i),0.05);</span><br><span class="line">    H(i)&#x3D;h;</span><br><span class="line">    P(i)&#x3D;p;</span><br><span class="line">end</span><br><span class="line">disp(H)</span><br><span class="line">disp(P)</span><br></pre></td></tr></table></figure><pre><code>### 小样本3≤n≤50：Shapiro-wilk检验  </code></pre><p>H0：该随机变量服从正态分布</p><p>H1：该随机变量不服从正态分布</p><p>计算出威尔克统计量后，得到相应的p值</p><p>将p值与0.05比较，如果小于0.05则可拒绝原假设，否则我们不能拒绝原假设。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     </p><h3 id="Q-Q图-大样本"><a href="#Q-Q图-大样本" class="headerlink" title="Q-Q图  (大样本 )"></a>Q-Q图  (大样本 )</h3><p>在统计学中， Q‐Q图（Q代表分位数Quantile）是一种通过比较两个概率分布的分位数对这两个概率分布进行比较的概率图方法。<br>首先选定分位数的对应概率区间集合，在此概率区间上，点(x,y)对应于第一个分布的一个分位数x和第二个分布在和x相同概率区间上相同的分位数。<br>这里，我们选择正态分布和要检验的随机变量，并对其做出QQ图，可想而知，如果要检验的随机变量是正态分布，那么QQ图就是一条直线。<br>要利用Q‐Q图鉴别样本数据是否近似于正态分布,只需看Q‐Q图上的点是否近似地在一条直线附近。（要求数据量非常大）  </p><h1 id="斯皮尔曼spearman相关系数"><a href="#斯皮尔曼spearman相关系数" class="headerlink" title="斯皮尔曼spearman相关系数"></a>斯皮尔曼spearman相关系数</h1><p>定义：X和Y为两组数据，其斯皮尔曼（等级）相关系数：<br>$$<br>r_{s}=1-\frac{6\sum_{i=1}^{n}d^{2}_{i} }{n(n^2-1)}<br>$$</p><p>$$<br>d_{i}为X_{i}和Y_{i}之间的等级差。<br>$$</p><p>（一个数的等级，就是将它所在的一列数按照从小到大排序后，这个数所在的位置）可以证明：$r_{s}$位于-1和1之间。</p><table><thead><tr><th>X</th><th>Y</th><th>X的等级</th><th>Y的等级</th><th>等级差</th><th>等级差的平方</th></tr></thead><tbody><tr><td>3</td><td>5</td><td>2</td><td>1</td><td>1</td><td>1</td></tr><tr><td>8</td><td>10</td><td>5</td><td>4.5</td><td>0.5</td><td>0.25</td></tr><tr><td>4</td><td>8</td><td>3</td><td>3</td><td>0</td><td>0</td></tr><tr><td>7</td><td>10</td><td>4</td><td>4.5</td><td>‐0.5</td><td>0.25</td></tr><tr><td>2</td><td>6</td><td>1</td><td>2</td><td>‐1</td><td>1</td></tr></tbody></table><p>注：如果有的数值相同，则将它们所在的位置取算术平均  </p><p>斯皮尔曼相关系数被定义成等级之间的皮尔逊相关系数。  </p><h2 id="MATLAB中计算"><a href="#MATLAB中计算" class="headerlink" title="MATLAB中计算"></a>MATLAB中计算</h2><p>两种用法<br>（1） corr(X , Y , ‘type’ , ‘Spearman’)<br>这里的X和Y必须是列向量哦~<br>（2） corr(X , ‘type’ , ‘Spearman’)<br>这时计算X矩阵各列之间的斯皮尔曼相关系数  </p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% 斯皮尔曼相关系数</span></span><br><span class="line">X = [<span class="number">3</span> <span class="number">8</span> <span class="number">4</span> <span class="number">7</span> <span class="number">2</span>]'  <span class="comment">% 一定要是列向量哦，一撇'表示求转置</span></span><br><span class="line">Y = [<span class="number">5</span> <span class="number">10</span> <span class="number">9</span> <span class="number">10</span> <span class="number">6</span>]'</span><br><span class="line"><span class="comment">% 第一种计算方法</span></span><br><span class="line"><span class="number">1</span><span class="number">-6</span>*(<span class="number">1</span>+<span class="number">0.25</span>+<span class="number">0.25</span>+<span class="number">1</span>)/<span class="number">5</span>/<span class="number">24</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 第二种计算方法</span></span><br><span class="line">coeff = corr(X , Y , <span class="string">'type'</span> , <span class="string">'Spearman'</span>)</span><br><span class="line"><span class="comment">% 等价于：</span></span><br><span class="line">RX = [<span class="number">2</span> <span class="number">5</span> <span class="number">3</span> <span class="number">4</span> <span class="number">1</span>]</span><br><span class="line">RY = [<span class="number">1</span> <span class="number">4.5</span> <span class="number">3</span> <span class="number">4.5</span> <span class="number">2</span>]</span><br><span class="line">R = corrcoef(RX,RY)</span><br><span class="line"></span><br><span class="line"><span class="comment">% 计算矩阵各列的斯皮尔曼相关系数</span></span><br><span class="line">R = corr(Test, <span class="string">'type'</span> , <span class="string">'Spearman'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">% 大样本下的假设检验</span></span><br><span class="line"><span class="comment">% 计算检验值</span></span><br><span class="line"><span class="built_in">disp</span>(<span class="built_in">sqrt</span>(<span class="number">590</span>)*<span class="number">0.0301</span>)</span><br><span class="line"><span class="comment">% 计算p值</span></span><br><span class="line"><span class="built_in">disp</span>((<span class="number">1</span>-normcdf(<span class="number">0.7311</span>))*<span class="number">2</span>) <span class="comment">% normcdf用来计算标准正态分布的累积概率密度函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 直接给出相关系数和p值</span></span><br><span class="line">[R,P]=corr(Test, <span class="string">'type'</span> , <span class="string">'Spearman'</span>)</span><br></pre></td></tr></table></figure><h2 id="斯皮尔曼相关系数的假设检验"><a href="#斯皮尔曼相关系数的假设检验" class="headerlink" title="斯皮尔曼相关系数的假设检验"></a>斯皮尔曼相关系数的假设检验</h2><h3 id="小样本"><a href="#小样本" class="headerlink" title="小样本"></a>小样本</h3><p>小样本情况，即n≤30时，直接查临界值表即可。</p><p>样本相关系数r必须大于等于表中的临界值，才能得出显著的结论。<br>$$<br>H_{0}:r_{s}=0<br>$$</p><p>$$<br>H_{1}:r_{s}!=0<br>$$</p><h3 id="大样本"><a href="#大样本" class="headerlink" title="大样本"></a>大样本</h3><p>大样本情况下，统计量$r_{s}\sqrt{n-1}~N(0,1)$<br>$$<br>H_{0}:r_{s}=0<br>$$</p><p>$$<br>H_{1}:r_{s}!=0<br>$$</p><p>我们计算检验值$r_{s}\sqrt{n-1}$，并求出对应的p值与0.05相比即可。</p><p>p值大于0.05,因此我们无法拒绝原假设。（和0没有显著的差异  </p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 大样本下的假设检验</span></span><br><span class="line"><span class="comment">% 计算检验值</span></span><br><span class="line"><span class="built_in">disp</span>(<span class="built_in">sqrt</span>(<span class="number">590</span>)*<span class="number">0.0301</span>)</span><br><span class="line"><span class="comment">% 计算p值</span></span><br><span class="line"><span class="built_in">disp</span>((<span class="number">1</span>-normcdf(<span class="number">0.7311</span>))*<span class="number">2</span>) <span class="comment">% normcdf用来计算标准正态分布的累积概率密度函数</span></span><br></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 直接给出相关系数和p值</span></span><br><span class="line">[R,P]=corr(Test, <span class="string">'type'</span> , <span class="string">'Spearman'</span>)</span><br></pre></td></tr></table></figure><h1 id="斯皮尔曼相关系数和皮尔逊相关系数选择"><a href="#斯皮尔曼相关系数和皮尔逊相关系数选择" class="headerlink" title="斯皮尔曼相关系数和皮尔逊相关系数选择:"></a>斯皮尔曼相关系数和皮尔逊相关系数选择:</h1><ol><li><p>连续数据，正态分布，线性关系，用pearson相关系数是最恰当，当然用spearman相关系数也可以， 就是效率没有pearson相关系数高。</p></li><li><p>上述任一条件不满足，就用spearman相关系数，不能用pearson相关系数。</p></li><li><p>两个定序数据之间也用spearman相关系数，不能用pearson相关系数。</p></li></ol><p>   定序数据是指仅仅反映观测对象等级、顺序关系的数据，是由定序尺度计量形成的，表现为类别，可以进行排序，属于品质数据。<br>   例如：优、良、差；<br>   我们可以用1表示差、 2表示良、 3表示优，但请注意，用2除以1得出的2并不代表任何含义。定序数据最重要的意义代表了一组数据中的某种逻辑顺序。<br>   注：斯皮尔曼相关系数的适用条件比皮尔逊相关系数要广，只要数据满足单调关系（例如线性函数、指数函数、对数函数等）就能够使用  </p><h1 id="总代码"><a href="#总代码" class="headerlink" title="总代码"></a>总代码</h1><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">clear;clc</span><br><span class="line">load <span class="string">'physical fitness test.mat'</span>  <span class="comment">%文件名如果有空格隔开，那么需要加引号</span></span><br><span class="line"><span class="comment">% https://ww2.mathworks.cn/help/matlab/ref/corrcoef.html</span></span><br><span class="line"><span class="comment">%% 统计描述</span></span><br><span class="line">MIN = <span class="built_in">min</span>(Test);  <span class="comment">% 每一列的最小值</span></span><br><span class="line">MAX = <span class="built_in">max</span>(Test);   <span class="comment">% 每一列的最大值</span></span><br><span class="line">MEAN = <span class="built_in">mean</span>(Test);  <span class="comment">% 每一列的均值</span></span><br><span class="line">MEDIAN = median(Test);  <span class="comment">%每一列的中位数</span></span><br><span class="line">SKEWNESS = skewness(Test); <span class="comment">%每一列的偏度</span></span><br><span class="line">KURTOSIS = kurtosis(Test);  <span class="comment">%每一列的峰度</span></span><br><span class="line">STD = std(Test);  <span class="comment">% 每一列的标准差</span></span><br><span class="line">RESULT = [MIN;MAX;MEAN;MEDIAN;SKEWNESS;KURTOSIS;STD]  <span class="comment">%将这些统计量放到一个矩阵中中表示</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 计算各列之间的相关系数</span></span><br><span class="line"><span class="comment">% 在计算皮尔逊相关系数之前,一定要做出散点图来看两组变量之间是否有线性关系</span></span><br><span class="line"><span class="comment">% 这里使用Spss比较方便: 图形 - 旧对话框 - 散点图/点图 - 矩阵散点图</span></span><br><span class="line"></span><br><span class="line">R = corrcoef(Test)   <span class="comment">% correlation coefficient</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 假设检验部分</span></span><br><span class="line">x = <span class="number">-4</span>:<span class="number">0.1</span>:<span class="number">4</span>;</span><br><span class="line">y = tpdf(x,<span class="number">28</span>);  <span class="comment">%求t分布的概率密度值 28是自由度  </span></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">plot</span>(x,y,<span class="string">'-'</span>)</span><br><span class="line">grid on  <span class="comment">% 在画出的图上加上网格线</span></span><br><span class="line"><span class="built_in">hold</span> on  <span class="comment">% 保留原来的图，以便继续在上面操作</span></span><br><span class="line"><span class="comment">% matlab可以求出临界值，函数如下</span></span><br><span class="line">tinv(<span class="number">0.975</span>,<span class="number">28</span>)    <span class="comment">%    2.0484</span></span><br><span class="line"><span class="comment">% 这个函数是累积密度函数cdf的反函数</span></span><br><span class="line"><span class="built_in">plot</span>([<span class="number">-2.048</span>,<span class="number">-2.048</span>],[<span class="number">0</span>,tpdf(<span class="number">-2.048</span>,<span class="number">28</span>)],<span class="string">'r-'</span>)</span><br><span class="line"><span class="built_in">plot</span>([<span class="number">2.048</span>,<span class="number">2.048</span>],[<span class="number">0</span>,tpdf(<span class="number">2.048</span>,<span class="number">28</span>)],<span class="string">'r-'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 计算p值</span></span><br><span class="line">x = <span class="number">-4</span>:<span class="number">0.1</span>:<span class="number">4</span>;</span><br><span class="line">y = tpdf(x,<span class="number">28</span>);</span><br><span class="line"><span class="built_in">figure</span>(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">plot</span>(x,y,<span class="string">'-'</span>)</span><br><span class="line">grid on </span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line"><span class="comment">% 画线段的方法</span></span><br><span class="line"><span class="built_in">plot</span>([<span class="number">-3.055</span>,<span class="number">-3.055</span>],[<span class="number">0</span>,tpdf(<span class="number">-3.055</span>,<span class="number">28</span>)],<span class="string">'r-'</span>)</span><br><span class="line"><span class="built_in">plot</span>([<span class="number">3.055</span>,<span class="number">3.055</span>],[<span class="number">0</span>,tpdf(<span class="number">3.055</span>,<span class="number">28</span>)],<span class="string">'r-'</span>)</span><br><span class="line"><span class="built_in">disp</span>(<span class="string">'该检验值对应的p值为：'</span>)</span><br><span class="line"><span class="built_in">disp</span>((<span class="number">1</span>-tcdf(<span class="number">3.055</span>,<span class="number">28</span>))*<span class="number">2</span>)  <span class="comment">%双侧检验的p值要乘以2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 计算各列之间的相关系数以及p值</span></span><br><span class="line">[R,P] = corrcoef(Test)</span><br><span class="line"><span class="comment">% 在EXCEL表格中给数据右上角标上显著性符号吧</span></span><br><span class="line">P &lt; <span class="number">0.01</span>  <span class="comment">% 标记3颗星的位置</span></span><br><span class="line">(P &lt; <span class="number">0.05</span>) .* (P &gt; <span class="number">0.01</span>)  <span class="comment">% 标记2颗星的位置</span></span><br><span class="line">(P &lt; <span class="number">0.1</span>) .* (P &gt; <span class="number">0.05</span>) <span class="comment">% % 标记1颗星的位置</span></span><br><span class="line"><span class="comment">% 也可以使用Spss操作哦 看我演示</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 正态分布检验</span></span><br><span class="line"><span class="comment">% 正态分布的偏度和峰度</span></span><br><span class="line">x = normrnd(<span class="number">2</span>,<span class="number">3</span>,<span class="number">100</span>,<span class="number">1</span>);   <span class="comment">% 生成100*1的随机向量，每个元素是均值为2，标准差为3的正态分布</span></span><br><span class="line">skewness(x)  <span class="comment">%偏度</span></span><br><span class="line">kurtosis(x)  <span class="comment">%峰度</span></span><br><span class="line">qqplot(x)</span><br><span class="line">    </span><br><span class="line"><span class="comment">% 检验第一列数据是否为正态分布</span></span><br><span class="line">[h,p] = jbtest(Test(:,<span class="number">1</span>),<span class="number">0.05</span>)<span class="comment">%只能一组一组检验</span></span><br><span class="line">[h,p] = jbtest(Test(:,<span class="number">1</span>),<span class="number">0.01</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">% 用循环检验所有列的数据</span></span><br><span class="line">n_c = <span class="built_in">size</span>(Test,<span class="number">2</span>);  <span class="comment">% number of column 数据的列数</span></span><br><span class="line">H = <span class="built_in">zeros</span>(<span class="number">1</span>,<span class="number">6</span>);  <span class="comment">% 初始化节省时间和消耗</span></span><br><span class="line">P = <span class="built_in">zeros</span>(<span class="number">1</span>,<span class="number">6</span>);</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:n_c</span><br><span class="line">    [h,p] = jbtest(Test(:,<span class="built_in">i</span>),<span class="number">0.05</span>);</span><br><span class="line">    H(<span class="built_in">i</span>)=h;</span><br><span class="line">    P(<span class="built_in">i</span>)=p;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">disp</span>(H)</span><br><span class="line"><span class="built_in">disp</span>(P)</span><br><span class="line"></span><br><span class="line"><span class="comment">% Q-Q图</span></span><br><span class="line">qqplot(Test(:,<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 斯皮尔曼相关系数</span></span><br><span class="line">X = [<span class="number">3</span> <span class="number">8</span> <span class="number">4</span> <span class="number">7</span> <span class="number">2</span>]'  <span class="comment">% 一定要是列向量哦，一撇'表示求转置</span></span><br><span class="line">Y = [<span class="number">5</span> <span class="number">10</span> <span class="number">9</span> <span class="number">10</span> <span class="number">6</span>]'</span><br><span class="line"><span class="comment">% 第一种计算方法</span></span><br><span class="line"><span class="number">1</span><span class="number">-6</span>*(<span class="number">1</span>+<span class="number">0.25</span>+<span class="number">0.25</span>+<span class="number">1</span>)/<span class="number">5</span>/<span class="number">24</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 第二种计算方法</span></span><br><span class="line">coeff = corr(X , Y , <span class="string">'type'</span> , <span class="string">'Spearman'</span>)</span><br><span class="line"><span class="comment">% 等价于：</span></span><br><span class="line">RX = [<span class="number">2</span> <span class="number">5</span> <span class="number">3</span> <span class="number">4</span> <span class="number">1</span>]</span><br><span class="line">RY = [<span class="number">1</span> <span class="number">4.5</span> <span class="number">3</span> <span class="number">4.5</span> <span class="number">2</span>]</span><br><span class="line">R = corrcoef(RX,RY)</span><br><span class="line"></span><br><span class="line"><span class="comment">% 计算矩阵各列的斯皮尔曼相关系数</span></span><br><span class="line">R = corr(Test, <span class="string">'type'</span> , <span class="string">'Spearman'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">% 大样本下的假设检验</span></span><br><span class="line"><span class="comment">% 计算检验值</span></span><br><span class="line"><span class="built_in">disp</span>(<span class="built_in">sqrt</span>(<span class="number">590</span>)*<span class="number">0.0301</span>)</span><br><span class="line"><span class="comment">% 计算p值</span></span><br><span class="line"><span class="built_in">disp</span>((<span class="number">1</span>-normcdf(<span class="number">0.7311</span>))*<span class="number">2</span>) <span class="comment">% normcdf用来计算标准正态分布的累积概率密度函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 直接给出相关系数和p值</span></span><br><span class="line">[R,P]=corr(Test, <span class="string">'type'</span> , <span class="string">'Spearman'</span>)</span><br></pre></td></tr></table></figure><h1 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h1><p>写一篇文章，分析男生体测数据各指标之间的相关性，并与女生的数据得到的结论进行对比。<br>要求：要说明选择哪一种相关系数的原因，并要求做出散点图。（可以自己动手试试相关矩阵可视化哦）</p><h2 id="确定相关系数"><a href="#确定相关系数" class="headerlink" title="确定相关系数"></a>确定相关系数</h2><p>​      为了度量两个变量间的线性关系，一般采用皮尔逊（Pearson）相关系数或斯皮尔曼（Spearman）相关系数进行分析。其中，只有当数据满足连续且呈线性关系时，才能使用皮尔逊（Pearson）相关系数描述变量间的相关性，且估计数据显著性时候需要数据服从正态分布；相对地，斯皮尔曼（Spearman）相关系数则没有使用条件限制。<br>​      因此，在确定使用哪种相关系数之前，应对各指标数据绘制散点图判断是否呈线性关系以及正态分布检验。</p><h3 id="绘制散点图"><a href="#绘制散点图" class="headerlink" title="绘制散点图"></a>绘制散点图</h3><p><img src="https://img2018.cnblogs.com/blog/1880713/202002/1880713-20200220221940227-645930610.png" alt=""></p><p>由散点图司知，各指标彼此之间均无线性关系。</p><h3 id="正态分布检验"><a href="#正态分布检验" class="headerlink" title="正态分布检验"></a>正态分布检验</h3><p>  由于本整数据的样本容里；730，属于大样本苷量，应采用JB检始的方式检验备描标款据是否愿从正态分布·我们将通过MATLAB 的 jbtest的数对各指标数据进行正态分布检验。<br>    假设原指标均服从正态分布，在95%的置信水平下，各指标数据的正态分布检验结果如下表所示(附录中的代码）：</p><p>​     由表1可知，经正态分布检验之后，各指标的h值均为1且p值均小于0.05，即拒绝原假设。<br>​    经散点图与正态分布检验分析可知，本不能使用皮尔逊（Pearson）相关系数分析.故考虑使用斯皮尔曼（Speaman）相关系数。</p><h2 id="斯皮尔曼（Spearman）相关系数"><a href="#斯皮尔曼（Spearman）相关系数" class="headerlink" title="斯皮尔曼（Spearman）相关系数"></a>斯皮尔曼（Spearman）相关系数</h2><p>   我们将本题数据导入到SPSS中，进行相关性分析，结果如下表所示：<br>   <img src="https://img2018.cnblogs.com/blog/1880713/202002/1880713-20200220225528808-376239688.png" alt=""></p><h2 id="结果分析。"><a href="#结果分析。" class="headerlink" title="结果分析。"></a>结果分析。</h2><p>   根据SPSS求解结果，可得结论如下：<br>   当显著性水平a=0.01时，身高与肺活量呈正相关，身高与坐位体前屈呈负相关，体重与立定跳远呈正相关。</p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% 导入电子表格中的数据</span></span><br><span class="line"><span class="comment">% 用于从以下电子表格导入数据的脚本:</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">%    工作簿: G:\数学建模学习材料\参考资料\清风数学建模\第1-14讲和番外篇的课件和代码(1月16日修订版本)\第1-14讲和番外篇课件和代码\第5讲.相关系数\代码和例题数据\八年级男生体测数据.xls</span></span><br><span class="line"><span class="comment">%    工作表: 八年级数据</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">% 要扩展代码以供其他选定数据或其他电子表格使用，请生成函数来代替脚本。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 由 MATLAB 自动生成于 2020/02/20 23:38:50</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 导入数据</span></span><br><span class="line">[~, ~, raw] = xlsread(<span class="string">'G:\数学建模学习材料\参考资料\清风数学建模\第1-14讲和番外篇的课件和代码(1月16日修订版本)\第1-14讲和番外篇课件和代码\第5讲.相关系数\代码和例题数据\八年级男生体测数据.xls'</span>,<span class="string">'八年级数据'</span>,<span class="string">'A2:F731'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 创建输出变量</span></span><br><span class="line">data = <span class="built_in">reshape</span>([raw&#123;:&#125;],<span class="built_in">size</span>(raw));</span><br><span class="line"></span><br><span class="line"><span class="comment">%% JB检验</span></span><br><span class="line">n_c = <span class="built_in">size</span>(data,<span class="number">2</span>);  <span class="comment">% number of column 数据的列数</span></span><br><span class="line">H = <span class="built_in">zeros</span>(<span class="number">1</span>,<span class="number">6</span>);  <span class="comment">% 初始化节省时间和消耗</span></span><br><span class="line">P = <span class="built_in">zeros</span>(<span class="number">1</span>,<span class="number">6</span>);</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:n_c</span><br><span class="line">    [h,p] = jbtest(data(:,<span class="built_in">i</span>),<span class="number">0.05</span>);</span><br><span class="line">    H(<span class="built_in">i</span>)=h;</span><br><span class="line">    P(<span class="built_in">i</span>)=p;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">disp</span>(H)</span><br><span class="line"><span class="built_in">disp</span>(P)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 清除临时变量</span></span><br><span class="line">clearvars data raw;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MATLAB </tag>
            
            <tag> 统计 </tag>
            
            <tag> spss </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MATLAB作图</title>
      <link href="/2020/01/24/MATLAB%E4%BD%9C%E5%9B%BE/"/>
      <url>/2020/01/24/MATLAB%E4%BD%9C%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="曲线图"><a href="#曲线图" class="headerlink" title="曲线图"></a><strong>曲线图</strong></h1><a id="more"></a><h2 id="plot"><a href="#plot" class="headerlink" title="plot()"></a>plot()</h2><ul><li><p>plot(X,Y)—画实线</p></li><li><p>plot(X,Y1,S1,X,Y2,S2,……,X,Yn,Sn)—将多条线画在一起</p></li></ul><p><em>*在[0,2]用红线画sin *x</em>,用绿圈画cos <em>x</em>. **</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x=linspace(<span class="number">0</span>,<span class="number">2</span>*pi,<span class="number">30</span>);</span><br><span class="line">%linspace（x1,x2,N)均分计算指令，用于产生x1,x2之间的N点行线性的矢量。</span><br><span class="line">%其中x1、x2、N分别为起始值、终止值、元素个数。若默认N，默认点数为<span class="number">100</span>。</span><br><span class="line">y=sin(x);</span><br><span class="line">z=cos(x);</span><br><span class="line">plot(x,y,<span class="string">'r'</span>,x,z,<span class="string">'go'</span>)</span><br><span class="line">%plot(X,Y1,S1,X,Y2,S2,……,X,Yn,Sn)       %— 将多条线画在一起</span><br></pre></td></tr></table></figure><p>1</p><p>其他作图方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">y  黄色   . 点   -  连线</span><br><span class="line">m  洋红   o 圈   :  短虚线</span><br><span class="line">c  蓝绿色     x  x-符号       -.  长短线     r  红色        +   加号      --  长虚线</span><br></pre></td></tr></table></figure><p>相关函数：<a href="https://baike.baidu.com/item/logspace" target="_blank" rel="noopener">logspace</a></p><p>用法：x=logspace(a, b, n)</p><p>功能：logspace(a, b, n)生成一个数组，数据的第一个元素值为a，最后一个元素为b，n是总采样点数。需要注意的是，此时产生的数组元素在10^a 到10^b上并不是均匀分布的，而形成一个对数曲线。</p><hr><h2 id="符号函数-显函数、隐函数和参数方程-画图"><a href="#符号函数-显函数、隐函数和参数方程-画图" class="headerlink" title="符号函数(显函数、隐函数和参数方程)画图"></a>符号函数(显函数、隐函数和参数方程)画图</h2><h3 id="ezplot"><a href="#ezplot" class="headerlink" title="ezplot"></a>ezplot</h3><ul><li><p>ezplot(‘f(x)’,[a,b]) </p><p>表示在a&lt;x&lt;b绘制显函数f=f(x)的函数图.</p></li><li><p><strong>ezplot</strong>(‘f(x,y)’,[xmin,xmax,ymin,ymax]) </p><p>表示在区间xmin&lt;x&lt;xmax和 ymin&lt;y&lt;ymax绘制隐函数f(x,y)=0的函数图.</p></li><li><p>ezplot(‘x(t)’,’y(t)’,[tmin,tmax])         </p><p> 表示在区间tmin&lt;t&lt;tmax绘制参数方程                                                x=x(t),y=y(t)的函数图.</p></li></ul><p><strong>例</strong>  在[0, Π ]上画<em>y</em>=cos <em>x</em> 的图形.</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ezplot(<span class="string">'sin(x)'</span>,[<span class="number">0</span>,<span class="built_in">pi</span>])</span><br></pre></td></tr></table></figure><p>2.png</p><p><strong>例</strong> 在[0, 2Π ]上画$y=cost^{3}(t),y=sin^{3}t$的星形图.</p><p>3.png</p><hr><p>2020/1/26更新</p><p>后面的内容太多，美赛迫在眉睫！！！看完了ppt和资料，等回来有空整理下来。</p>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MATLAB作图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round #615 (Div. 3) 题解</title>
      <link href="/2020/01/23/Codeforces-Round-615-Div-3-%E9%A2%98%E8%A7%A3/"/>
      <url>/2020/01/23/Codeforces-Round-615-Div-3-%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>本次打的极差，我哭了！！！</p><a id="more"></a><hr><h1 id="A-Collecting-Coins"><a href="#A-Collecting-Coins" class="headerlink" title="A - Collecting Coins"></a><strong>A - Collecting Coins</strong></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>A. Collecting Coins</p><p>time limit per test</p><p>2 seconds</p><p>memory limit per test</p><p>256 megabytes</p><p>input</p><p>standard input</p><p>output</p><p>standard output</p><p>Polycarp has three sisters: Alice, Barbara, and Cerene. They’re collecting coins. Currently, Alice has aa coins, Barbara has bb coins and Cerene has cc coins. Recently Polycarp has returned from the trip around the world and brought nn coins.</p><p>He wants to distribute <strong>all</strong> these nn coins between his sisters in such a way that the number of coins Alice has is equal to the number of coins Barbara has and is equal to the number of coins Cerene has. In other words, if Polycarp gives AA coins to Alice, BB coins to Barbara and CC coins to Cerene (A+B+C=nA+B+C=n), then a+A=b+B=c+Ca+A=b+B=c+C.</p><p><strong>Note</strong> that A, B or C (the number of coins Polycarp gives to Alice, Barbara and Cerene correspondingly) can be 0.</p><p>Your task is to find out if it is possible to distribute <strong>all</strong> nn coins between sisters in a way described above.</p><p>You have to answer tt independent test cases.</p><p>Input</p><p>The first line of the input contains one integer tt (1≤t≤1041≤t≤104) — the number of test cases.</p><p>The next tt lines describe test cases. Each test case is given on a new line and consists of four space-separated integers a,b,ca,b,c and nn (1≤a,b,c,n≤1081≤a,b,c,n≤108) — the number of coins Alice has, the number of coins Barbara has, the number of coins Cerene has and the number of coins Polycarp has.</p><p>Output</p><p>For each test case, print “YES” if Polycarp can distribute <strong>all</strong> nn coins between his sisters and “NO” otherwise.</p><p>Example</p><p>input</p><p>Copy</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">5 3 2 8</span><br><span class="line">100 101 102 105</span><br><span class="line">3 2 1 100000000</span><br><span class="line">10 20 15 14</span><br><span class="line">101 101 101 3</span><br></pre></td></tr></table></figure><p>output</p><p>Copy</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">YES</span><br><span class="line">YES</span><br><span class="line">NO</span><br><span class="line">NO</span><br><span class="line">YES</span><br></pre></td></tr></table></figure><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a><strong>题意</strong></h2><p>给你四个数a，b，c，d，n.问你是否能将n拆成三个数A,B,C，使得A+a=B+b=C+c。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a><strong>思路</strong></h2><p>先计算三个数的差值的绝对值abs,如果abs大于n则肯定不行，如果小于n，还需判断(n-abs)%3是否为0，不为0则不行。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> queue</span><br><span class="line">sys.setrecursionlimit(<span class="number">10</span> ** <span class="number">9</span>)</span><br><span class="line">IA = <span class="keyword">lambda</span>: map(int, input().split())</span><br><span class="line">IAL = <span class="keyword">lambda</span>: list(map(int, input().split()))</span><br><span class="line">IM = <span class="keyword">lambda</span> N: [IA() <span class="keyword">for</span> _ <span class="keyword">in</span> range(N)]</span><br><span class="line"><span class="comment"># !/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line">N = <span class="number">105</span></span><br><span class="line">T=int(input())</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,T):</span><br><span class="line">    a,b,c,n=IA()</span><br><span class="line">    <span class="comment">#print(n-(2*max(a,b,c)-(a+b+c-max(a,b,c))))</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">2</span>*max(a,b,c)-(a+b+c-max(a,b,c)))&gt;n:</span><br><span class="line">        print(<span class="string">"NO"</span>)</span><br><span class="line">    <span class="keyword">elif</span> (n-(<span class="number">2</span>*max(a,b,c)-(a+b+c-max(a,b,c))))%<span class="number">3</span>==<span class="number">0</span>:</span><br><span class="line">        print(<span class="string">"YES"</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">"NO"</span>)</span><br></pre></td></tr></table></figure><hr><h1 id="B-Collecting-Packages"><a href="#B-Collecting-Packages" class="headerlink" title="B. Collecting Packages"></a>B. Collecting Packages</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>time limit per test</p><p>1 second</p><p>memory limit per test</p><p>256 megabytes</p><p>input</p><p>standard input</p><p>output</p><p>standard output</p><p>There is a robot in a warehouse and nn packages he wants to collect. The warehouse can be represented as a coordinate grid. Initially, the robot stays at the point (0,0)(0,0). The ii-th package is at the point (xi,yi)(xi,yi). It is guaranteed that there are no two packages at the same point. It is also guaranteed that the point (0,0)(0,0) doesn’t contain a package.</p><p>The robot is semi-broken and only can move up (‘U’) and right (‘R’). In other words, in one move the robot can go from the point (x,y)(x,y) to the point (x+1,yx+1,y) or to the point (x,y+1)(x,y+1).</p><p>As we say above, the robot wants to collect all nn packages (<strong>in arbitrary order</strong>). He wants to do it with the minimum possible number of moves. If there are several possible traversals, the robot wants to choose the lexicographically smallest path.</p><p>The string ss of length nn is lexicographically less than the string tt of length nn if there is some index 1≤j≤n1≤j≤n that for all ii from 11 to j−1j−1 si=tisi=ti and sj&lt;tjsj&lt;tj. It is the standard comparison of string, like in a dictionary. Most programming languages compare strings in this way.</p><p>Input</p><p>The first line of the input contains an integer tt (1≤t≤1001≤t≤100) — the number of test cases. Then test cases follow.</p><p>The first line of a test case contains one integer nn (1≤n≤10001≤n≤1000) — the number of packages.</p><p>The next nn lines contain descriptions of packages. The ii-th package is given as two integers xixi and yiyi (0≤xi,yi≤10000≤xi,yi≤1000) — the xx-coordinate of the package and the yy-coordinate of the package.</p><p>It is guaranteed that there are no two packages at the same point. It is also guaranteed that the point (0,0)(0,0) doesn’t contain a package.</p><p>The sum of all values nn over test cases in the test doesn’t exceed 10001000.</p><p>Output</p><p>Print the answer for each test case.</p><p>If it is impossible to collect all nn packages in some order starting from (0,00,0), print “NO” on the first line.</p><p>Otherwise, print “YES” in the first line. Then print the <strong>shortest</strong> path — a string consisting of characters ‘R’ and ‘U’. Among all such paths choose the lexicographically smallest path.</p><p><strong>Note that in this problem “YES” and “NO” can be only uppercase words, i.e. “Yes”, “no” and “YeS” are not acceptable</strong>.</p><p>Example</p><p>input</p><p>Copy</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">5</span><br><span class="line">1 3</span><br><span class="line">1 2</span><br><span class="line">3 3</span><br><span class="line">5 5</span><br><span class="line">4 3</span><br><span class="line">2</span><br><span class="line">1 0</span><br><span class="line">0 1</span><br><span class="line">1</span><br><span class="line">4 3</span><br></pre></td></tr></table></figure><p>output</p><p>Copy</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">YES</span><br><span class="line">RUUURRRRUU</span><br><span class="line">NO</span><br><span class="line">YES</span><br><span class="line">RRRRUUU</span><br></pre></td></tr></table></figure><p>Note</p><p>For the first test case in the example the optimal path RUUURRRRUU is shown below:</p><p><img src="https://espresso.codeforces.com/8ba8beb3d4798d0c00f093234601e29f45df5fd2.png" alt="##"></p><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a><strong>题意</strong></h2><p>给出直角坐标系中的一些坐标，你只能向上(‘U’)或向右(‘R’)走，问你能否走完这些坐标，如果能请输出字典序最小的行进路线</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a><strong>思路</strong></h2><p>先x后y坐标排序，如果有一个点的纵坐标在上一个点的纵坐标下方，则无法走。输出顺序只需要从上一个点先走R再走U走到下一个点即可</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.setrecursionlimit(<span class="number">10</span>**<span class="number">9</span>)</span><br><span class="line">IA =<span class="keyword">lambda</span>: map(int,input().split())</span><br><span class="line"></span><br><span class="line">T=int(input())</span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> range(<span class="number">0</span>,T):</span><br><span class="line">    n=int(input())</span><br><span class="line">    a=[]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,n):</span><br><span class="line">        x,y=IA()</span><br><span class="line">        a.append([x,y])</span><br><span class="line">    a.sort()</span><br><span class="line">    sx=<span class="number">0</span></span><br><span class="line">    sy=<span class="number">0</span></span><br><span class="line">    ans=<span class="string">""</span></span><br><span class="line">    flag=<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> a:</span><br><span class="line">        <span class="keyword">if</span> item[<span class="number">0</span>]&gt;=sx <span class="keyword">and</span> item[<span class="number">1</span>]&gt;=sy:</span><br><span class="line">            ans=ans+(item[<span class="number">0</span>]-sx)*<span class="string">'R'</span>+(item[<span class="number">1</span>]-sy)*<span class="string">'U'</span></span><br><span class="line">            sx=item[<span class="number">0</span>]</span><br><span class="line">            sy=item[<span class="number">1</span>]</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">"NO"</span>)</span><br><span class="line">            flag=<span class="number">-1</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> flag==<span class="number">1</span>:</span><br><span class="line">        print(<span class="string">"YES"</span>)</span><br><span class="line">        print(ans)</span><br></pre></td></tr></table></figure><hr><h1 id="C-Product-of-Three-Numbers"><a href="#C-Product-of-Three-Numbers" class="headerlink" title="C - Product of Three Numbers"></a><strong>C - Product of Three Numbers</strong></h1><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h2><p>C. Product of Three Numbers</p><p>time limit per test</p><p>2 seconds</p><p>memory limit per test</p><p>256 megabytes</p><p>input</p><p>standard input</p><p>output</p><p>standard output</p><p>You are given one integer number nn. Find three <strong>distinct integers</strong> a,b,ca,b,c such that 2≤a,b,c2≤a,b,c and a⋅b⋅c=na⋅b⋅c=n or say that it is impossible to do it.</p><p>If there are several answers, you can print any.</p><p>You have to answer tt independent test cases.</p><p>Input</p><p>The first line of the input contains one integer tt (1≤t≤1001≤t≤100) — the number of test cases.</p><p>The next nn lines describe test cases. The ii-th test case is given on a new line as one integer nn (2≤n≤1092≤n≤109).</p><p>Output</p><p>For each test case, print the answer on it. Print “NO” if it is impossible to represent nn as a⋅b⋅ca⋅b⋅c for some <strong>distinct integers</strong> a,b,ca,b,c such that 2≤a,b,c2≤a,b,c.</p><p>Otherwise, print “YES” and <strong>any</strong> possible such representation.</p><p>Example</p><p>input</p><p>Copy</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">64</span><br><span class="line">32</span><br><span class="line">97</span><br><span class="line">2</span><br><span class="line">12345</span><br></pre></td></tr></table></figure><p>output</p><p>Copy</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">YES</span><br><span class="line">2 4 8 </span><br><span class="line">NO</span><br><span class="line">NO</span><br><span class="line">NO</span><br><span class="line">YES</span><br><span class="line">3 5 823</span><br></pre></td></tr></table></figure><h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a><strong>题意</strong></h2><p>给你一个数n，问你是否能将n分解成三个不同的数相乘，可以的话则输出任一解</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a><strong>思路</strong></h2><p>只需要将遍历从2到<img src="https://img2018.cnblogs.com/i-beta/1918757/202001/1918757-20200123125243675-572954954.png" alt="img">，如果i为n的因子，就将i记录，并将n除以i。这样的操作执行三次之后，就可以跳出循环。</p><p>判断条件直接暴力就行，因为就三个。</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.setrecursionlimit(<span class="number">10</span>**<span class="number">9</span>)</span><br><span class="line">IA =<span class="keyword">lambda</span>: map(int,input().split())</span><br><span class="line">ans=[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solve</span><span class="params">(n)</span>:</span></span><br><span class="line">    num=int(<span class="number">0</span>)</span><br><span class="line">    i=int(<span class="number">2</span>)</span><br><span class="line">    tmp=<span class="number">1</span></span><br><span class="line">    m=n</span><br><span class="line">    <span class="keyword">while</span> i*i&lt;=n:</span><br><span class="line">        <span class="keyword">if</span> n%i==<span class="number">0</span>:</span><br><span class="line">            n=n//i</span><br><span class="line">            tmp*=i</span><br><span class="line">            <span class="keyword">if</span> tmp <span class="keyword">not</span> <span class="keyword">in</span> ans:</span><br><span class="line">                num+=<span class="number">1</span></span><br><span class="line">                ans[num]=tmp</span><br><span class="line">                tmp=<span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> num&gt;=<span class="number">3</span>:</span><br><span class="line">                    ans[num]*=n</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        i+=<span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> n&gt;<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">if</span> tmp*n <span class="keyword">not</span> <span class="keyword">in</span> ans:</span><br><span class="line">            num+=<span class="number">1</span></span><br><span class="line">            ans[num]=n*tmp</span><br><span class="line">    <span class="keyword">if</span> num&gt;=<span class="number">3</span>: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">T=int(input())</span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> range(<span class="number">0</span>,T):</span><br><span class="line">    ans=[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">    n=int(input())</span><br><span class="line">    <span class="keyword">if</span> solve(n)==<span class="number">1</span>:</span><br><span class="line">        print(<span class="string">"YES"</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">4</span>):</span><br><span class="line">            print(ans[i],end=<span class="string">" "</span>)</span><br><span class="line">        print()</span><br><span class="line">    <span class="keyword">else</span>:print(<span class="string">"NO"</span>)</span><br></pre></td></tr></table></figure><hr><h1 id="D-MEX-maximizing"><a href="#D-MEX-maximizing" class="headerlink" title="D. MEX maximizing"></a>D. MEX maximizing</h1><h2 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h2><p>D. MEX maximizing</p><p>time limit per test</p><p>3 seconds</p><p>memory limit per test</p><p>256 megabytes</p><p>input</p><p>standard input</p><p>output</p><p>standard output</p><p>Recall that <strong>MEX</strong> of an array is a <strong>minimum non-negative integer</strong> that does not belong to the array. Examples:</p><ul><li>for the array [0,0,1,0,2][0,0,1,0,2] MEX equals to 33 because numbers 0,10,1 and 22 are presented in the array and 33 is the minimum non-negative integer not presented in the array;</li><li>for the array [1,2,3,4][1,2,3,4] MEX equals to 00 because 00 is the minimum non-negative integer not presented in the array;</li><li>for the array [0,1,4,3][0,1,4,3] MEX equals to 22 because 22 is the minimum non-negative integer not presented in the array.</li></ul><p>You are given an empty array a=[]a=[] (in other words, a zero-length array). You are also given a positive integer xx.</p><p>You are also given qq queries. The jj-th query consists of one integer yjyj and means that you have to append one element yjyj to the array. The array length increases by 11 after a query.</p><p>In one move, you can choose any index ii and set ai:=ai+xai:=ai+x or ai:=ai−xai:=ai−x (i.e. increase or decrease any element of the array by xx). The only restriction is that <strong>aiai cannot become negative</strong>. Since initially the array is empty, you can perform moves only after the first query.</p><p>You have to maximize the <strong>MEX</strong> (minimum excluded) of the array if you can perform any number of such operations (you can even perform the operation multiple times with one element).</p><p>You have to find the answer after each of qq queries (i.e. the jj-th answer corresponds to the array of length jj).</p><p><strong>Operations are discarded before each query. I.e. the array aa after the jj-th query equals to [y1,y2,…,yj][y1,y2,…,yj].</strong></p><p>Input</p><p>The first line of the input contains two integers q,xq,x (1≤q,x≤4⋅1051≤q,x≤4⋅105) — the number of queries and the value of xx.</p><p>The next qq lines describe queries. The jj-th query consists of one integer yjyj (0≤yj≤1090≤yj≤109) and means that you have to append one element yjyj to the array.</p><p>Output</p><p>Print the answer to the initial problem after each query — for the query jj print the maximum value of <strong>MEX</strong> after first jj queries. Note that queries are dependent (the array changes after each query) but operations are independent between queries.</p><p>Examples</p><p>input</p><p>Copy</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">7 3</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">2</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">10</span><br></pre></td></tr></table></figure><p>output</p><p>Copy</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">4</span><br><span class="line">7</span><br></pre></td></tr></table></figure><p>input</p><p>Copy</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4 3</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure><p>output</p><p>Copy</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>Note</p><p>In the first example:</p><ul><li><p>After the first query, the array is a=[0]a=[0]: you don’t need to perform any operations, maximum possible MEX is 11.</p></li><li><p>After the second query, the array is a=[0,1]a=[0,1]: you don’t need to perform any operations, maximum possible MEX is 22.</p></li><li><p>After the third query, the array is a=[0,1,2]a=[0,1,2]: you don’t need to perform any operations, maximum possible MEX is 33.</p></li><li><p>After the fourth query, the array is a=[0,1,2,2]a=[0,1,2,2]: you don’t need to perform any operations, maximum possible MEX is 33 (you can’t make it greater with operations).</p></li><li><p>After the fifth query, the array is a=[0,1,2,2,0]a=[0,1,2,2,0]: you can perform a[4]:=a[4]+3=3a[4]:=a[4]+3=3. The array changes to be a=[0,1,2,2,3]a=[0,1,2,2,3]. Now MEX is maximum possible and equals to 44.</p></li><li><p>After the sixth query, the array is a=[0,1,2,2,0,0]a=[0,1,2,2,0,0]: you can perform a[4]:=a[4]+3=0+3=3a[4]:=a[4]+3=0+3=3. The array changes to be a=[0,1,2,2,3,0]a=[0,1,2,2,3,0]. Now MEX is maximum possible and equals to 44.</p></li><li><p>After the seventh query, the array is</p></li></ul><p>  a=[0,1,2,2,0,0,10]a=[0,1,2,2,0,0,10]</p><p>  . You can perform the following operations:</p><ul><li><p>a[3]:=a[3]+3=2+3=5a[3]:=a[3]+3=2+3=5,</p></li><li><p>a[4]:=a[4]+3=0+3=3a[4]:=a[4]+3=0+3=3,</p></li><li><p>a[5]:=a[5]+3=0+3=3a[5]:=a[5]+3=0+3=3,</p></li><li><p>a[5]:=a[5]+3=3+3=6a[5]:=a[5]+3=3+3=6,</p></li><li><p>a[6]:=a[6]−3=10−3=7a[6]:=a[6]−3=10−3=7,</p></li><li><p>a[6]:=a[6]−3=7−3=4a[6]:=a[6]−3=7−3=4.</p><p>The resulting array will be</p></li></ul><p>  a=[0,1,2,5,3,6,4]a=[0,1,2,5,3,6,4]</p><p>  . Now MEX is maximum possible and equals to 7</p><h2 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h2><ul><li>输入q，x，然后输入q个数（q个询问)，每次放进一个数（开始为空数组）</li><li>同时每次可以对数组内的某个数或者某几个数做任意操作数的加x或者减x （x为input第二个数），</li><li>输出：处理完后询问，在该数组情况下的最小整数（就是数组里的数都被排除的情况下）从0开始找，第一个不在数组里的整数就是了，然后要求操作加x或者减x的任意操作后使得那个询问结果最大化。</li></ul><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>  构建mod x的剩余系，每次找到这个剩余系里面最大的加上x即可，从0开始判断即可，直接看代码，很短。</p><h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.setrecursionlimit(<span class="number">10</span>**<span class="number">9</span>)</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">IA =<span class="keyword">lambda</span>: map(int,input().split())</span><br><span class="line">ans=[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">T,x=IA()</span><br><span class="line">se=defaultdict(int)</span><br><span class="line">be=<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> range(<span class="number">0</span>,T):</span><br><span class="line">    </span><br><span class="line">    a=int(input())</span><br><span class="line">    temp=<span class="number">0</span></span><br><span class="line">    se[a%x]+=<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> se[be%x] &gt; <span class="number">0</span>:</span><br><span class="line">        se[be%x]-=<span class="number">1</span></span><br><span class="line">        be+=<span class="number">1</span></span><br><span class="line">    print(be)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>牛客小白月赛21</title>
      <link href="/2020/01/18/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B21/"/>
      <url>/2020/01/18/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B21/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th align="center">题号</th><th align="center">标题</th><th align="center">已通过代码</th><th align="center">题解</th><th align="center">讨论</th><th align="center">通过率</th><th align="center">我的状态</th></tr></thead><tbody><tr><td align="center">A</td><td align="center"><a href="https://ac.nowcoder.com/acm/contest/3947/A" target="_blank" rel="noopener">Audio</a></td><td align="center"><a href="https://ac.nowcoder.com/acm/contest/3947#submit/{" target="_blank" rel="noopener"problemIdFilter"%3A201604%2C"statusTypeFilter"%3A5}">点击查看</a></td><td align="center"><a href="https://ac.nowcoder.com/acm/problem/blogs/201604" target="_blank" rel="noopener">进入题解</a></td><td align="center"><a href="https://ac.nowcoder.com/discuss/tag/115266?type=101&appendTagId=115265" target="_blank" rel="noopener">进入讨论</a></td><td align="center">498/1102</td><td align="center">通过</td></tr><tr><td align="center">B</td><td align="center"><a href="https://ac.nowcoder.com/acm/contest/3947/B" target="_blank" rel="noopener">Bits</a></td><td align="center"><a href="https://ac.nowcoder.com/acm/contest/3947#submit/{" target="_blank" rel="noopener"problemIdFilter"%3A201605%2C"statusTypeFilter"%3A5}">点击查看</a></td><td align="center"><a href="https://ac.nowcoder.com/acm/problem/blogs/201605" target="_blank" rel="noopener">进入题解</a></td><td align="center"><a href="https://ac.nowcoder.com/discuss/tag/115267?type=101&appendTagId=115265" target="_blank" rel="noopener">进入讨论</a></td><td align="center">19/39</td><td align="center">未通过</td></tr><tr><td align="center">C</td><td align="center"><a href="https://ac.nowcoder.com/acm/contest/3947/C" target="_blank" rel="noopener">Channels</a></td><td align="center"><a href="https://ac.nowcoder.com/acm/contest/3947#submit/{" target="_blank" rel="noopener"problemIdFilter"%3A201606%2C"statusTypeFilter"%3A5}">点击查看</a></td><td align="center"><a href="https://ac.nowcoder.com/acm/problem/blogs/201606" target="_blank" rel="noopener">进入题解</a></td><td align="center"><a href="https://ac.nowcoder.com/discuss/tag/115268?type=101&appendTagId=115265" target="_blank" rel="noopener">进入讨论</a></td><td align="center">275/1227</td><td align="center">通过</td></tr><tr><td align="center">D</td><td align="center"><a href="https://ac.nowcoder.com/acm/contest/3947/D" target="_blank" rel="noopener">DDoS</a></td><td align="center"><a href="https://ac.nowcoder.com/acm/contest/3947#submit/{" target="_blank" rel="noopener"problemIdFilter"%3A201607%2C"statusTypeFilter"%3A5}">点击查看</a></td><td align="center"><a href="https://ac.nowcoder.com/acm/problem/blogs/201607" target="_blank" rel="noopener">进入题解</a></td><td align="center"><a href="https://ac.nowcoder.com/discuss/tag/115269?type=101&appendTagId=115265" target="_blank" rel="noopener">进入讨论</a></td><td align="center">41/188</td><td align="center">未通过</td></tr><tr><td align="center">E</td><td align="center"><a href="https://ac.nowcoder.com/acm/contest/3947/E" target="_blank" rel="noopener">Exams</a></td><td align="center"><a href="https://ac.nowcoder.com/acm/contest/3947#submit/{" target="_blank" rel="noopener"problemIdFilter"%3A201608%2C"statusTypeFilter"%3A5}">点击查看</a></td><td align="center"><a href="https://ac.nowcoder.com/acm/problem/blogs/201608" target="_blank" rel="noopener">进入题解</a></td><td align="center"><a href="https://ac.nowcoder.com/discuss/tag/115270?type=101&appendTagId=115265" target="_blank" rel="noopener">进入讨论</a></td><td align="center">218/607</td><td align="center">通过</td></tr><tr><td align="center">F</td><td align="center"><a href="https://ac.nowcoder.com/acm/contest/3947/F" target="_blank" rel="noopener">Fool Problem</a></td><td align="center"><a href="https://ac.nowcoder.com/acm/contest/3947#submit/{" target="_blank" rel="noopener"problemIdFilter"%3A201609%2C"statusTypeFilter"%3A5}">点击查看</a></td><td align="center"><a href="https://ac.nowcoder.com/acm/problem/blogs/201609" target="_blank" rel="noopener">进入题解</a></td><td align="center"><a href="https://ac.nowcoder.com/discuss/tag/115271?type=101&appendTagId=115265" target="_blank" rel="noopener">进入讨论</a></td><td align="center">489/1357</td><td align="center">通过</td></tr><tr><td align="center">G</td><td align="center"><a href="https://ac.nowcoder.com/acm/contest/3947/G" target="_blank" rel="noopener">Game</a></td><td align="center"><a href="https://ac.nowcoder.com/acm/contest/3947#submit/{" target="_blank" rel="noopener"problemIdFilter"%3A201610%2C"statusTypeFilter"%3A5}">点击查看</a></td><td align="center"><a href="https://ac.nowcoder.com/acm/problem/blogs/201610" target="_blank" rel="noopener">进入题解</a></td><td align="center"><a href="https://ac.nowcoder.com/discuss/tag/115272?type=101&appendTagId=115265" target="_blank" rel="noopener">进入讨论</a></td><td align="center">207/617</td><td align="center">通过</td></tr><tr><td align="center">H</td><td align="center"><a href="https://ac.nowcoder.com/acm/contest/3947/H" target="_blank" rel="noopener">”Happy New Year!“</a></td><td align="center"><a href="https://ac.nowcoder.com/acm/contest/3947#submit/{" target="_blank" rel="noopener"problemIdFilter"%3A201611%2C"statusTypeFilter"%3A5}">点击查看</a></td><td align="center"><a href="https://ac.nowcoder.com/acm/problem/blogs/201611" target="_blank" rel="noopener">进入题解</a></td><td align="center"><a href="https://ac.nowcoder.com/discuss/tag/115273?type=101&appendTagId=115265" target="_blank" rel="noopener">进入讨论</a></td><td align="center">1120/2908</td><td align="center">通过</td></tr><tr><td align="center">I</td><td align="center"><a href="https://ac.nowcoder.com/acm/contest/3947/I" target="_blank" rel="noopener">I love you</a></td><td align="center"><a href="https://ac.nowcoder.com/acm/contest/3947#submit/{" target="_blank" rel="noopener"problemIdFilter"%3A201612%2C"statusTypeFilter"%3A5}">点击查看</a></td><td align="center"><a href="https://ac.nowcoder.com/acm/problem/blogs/201612" target="_blank" rel="noopener">进入题解</a></td><td align="center"><a href="https://ac.nowcoder.com/discuss/tag/115274?type=101&appendTagId=115265" target="_blank" rel="noopener">进入讨论</a></td><td align="center">172/312</td><td align="center">通过</td></tr><tr><td align="center">J</td><td align="center"><a href="https://ac.nowcoder.com/acm/contest/3947/J" target="_blank" rel="noopener">Jelly</a></td><td align="center"><a href="https://ac.nowcoder.com/acm/contest/3947#submit/{" target="_blank" rel="noopener"problemIdFilter"%3A201613%2C"statusTypeFilter"%3A5}">点击查看</a></td><td align="center"><a href="https://ac.nowcoder.com/acm/problem/blogs/201613" target="_blank" rel="noopener">进入题解</a></td><td align="center"><a href="https://ac.nowcoder.com/discuss/tag/115275?type=101&appendTagId=115265" target="_blank" rel="noopener">进入讨论</a></td><td align="center">174/511</td><td align="center">通过</td></tr></tbody></table><a id="more"></a><h1 id="A-Audio"><a href="#A-Audio" class="headerlink" title="A Audio"></a>A Audio</h1><p>链接：<a href="https://ac.nowcoder.com/acm/contest/3947/A" target="_blank" rel="noopener">https://ac.nowcoder.com/acm/contest/3947/A</a><br>来源：牛客网</p><p>时间限制：C/C++ 1秒，其他语言2秒<br> 空间限制：C/C++ 131072K，其他语言262144K<br> 64bit IO Format: %lld</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Nancy很喜欢音乐。<br> 她能同时分辨出三种不同的音乐。恰巧，一座城市中有三处同时有交响音乐会（音源响度相同）。但是Nancy每一场都不想错过，于是她想寻找一个地点，使得三处音乐会声音的响度相同，这样她就可以同时欣赏三场音乐会啦！<br> （注：假设声音传播过程中不会受障碍物作用，声音传播满足平方反比定律）</p><h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">共三行：每行两个整数xix_ixi与yiy_iyi，三点不共线。</span><br><span class="line">数据满足：0≤∣xi∣,∣yi∣≤1090 \leq |x_i|, |y_i| \leq 10^&#123;9&#125;0≤∣xi∣,∣yi∣≤109。</span><br></pre></td></tr></table></figure><h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">共一行：两个实数posx,posypos_x, pos_yposx,posy，表示Nancy欣赏音乐会的地点（保留三位小数）</span><br></pre></td></tr></table></figure><p>示例1</p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p><a href="javascript:void(0);">复制</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0 0</span><br><span class="line">1 3</span><br><span class="line">4 2</span><br></pre></td></tr></table></figure><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p><a href="javascript:void(0);">复制</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2.000 1.000</span><br></pre></td></tr></table></figure><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>根据题意，需要找到三点距离相等的点，数学上即外心，亦称外圆圆心。输入的三个点不共线，这个条件能保证外心的存在。</p><p><strong>计算三角形两边中垂线交点</strong>是外心的常用求解方法。首先我们需要中垂线的直线方程表达出来，这里涉及到的是高中知识,直线方程如下，</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">给定三角形三个顶点的坐标，如何求三角形的外心的坐标呢？</span><br><span class="line">例如 ：给定a（x1,y1） b（x2,y2） c（x3,y3）求外接圆心坐标O（x，y）</span><br><span class="line"><span class="number">1.</span> 首先，外接圆的圆心是三角形三条边的垂直平分线的交点，我们根据圆心到顶点的距离相等，可以列出以下方程：</span><br><span class="line">       (x1-x)*(x1-x)+(y1-y)*(y1-y)=(x2-x)*(x2-x)+(y2-y)*(y2-y);</span><br><span class="line">       (x2-x)*(x2-x)+(y2-y)*(y2-y)=(x3-x)*(x3-x)+(y3-y)*(y3-y);</span><br><span class="line"><span class="number">2.</span>化简得到：</span><br><span class="line">        <span class="number">2</span>*(x2-x1)*x+<span class="number">2</span>*(y2-y1)y=x2^<span class="number">2</span>+y2^<span class="number">2</span>-x1^<span class="number">2</span>-y1^<span class="number">2</span>;</span><br><span class="line">        <span class="number">2</span>*(x3-x2)*x+<span class="number">2</span>*(y3-y2)y=x3^<span class="number">2</span>+y3^<span class="number">2</span>-x2^<span class="number">2</span>-y2^<span class="number">2</span>;</span><br><span class="line">        令A1=<span class="number">2</span>*(x2-x1)；</span><br><span class="line">            B1=<span class="number">2</span>*(y2-y1)；</span><br><span class="line">            C1=x2^<span class="number">2</span>+y2^<span class="number">2</span>-x1^<span class="number">2</span>-y1^<span class="number">2</span>;</span><br><span class="line">            A2=<span class="number">2</span>*(x3-x2)；</span><br><span class="line">            B2=<span class="number">2</span>*(y3-y2)；</span><br><span class="line">            C2=x3^<span class="number">2</span>+y3^<span class="number">2</span>-x2^<span class="number">2</span>-y2^<span class="number">2</span>;</span><br><span class="line">            即</span><br><span class="line">                A1*x+B1y=C1;</span><br><span class="line">                A2*x+B2y=C2;</span><br><span class="line"><span class="number">3.</span>最后根据克拉默法则：</span><br><span class="line">          x=((C1*B2)-(C2*B1))/((A1*B2)-(A2*B1))；</span><br><span class="line">          y=((A1*C2)-(A2*C1))/((A1*B2)-(A2*B1))；</span><br><span class="line">因此，x，y为最终结果；</span><br><span class="line">对于空间中的三角形，只不过最后解方程组的时候是三元方程组</span><br><span class="line">Ps：克拉默法则可以用向量积和数量积的方法证明，也可以用高等代数的知识证明</span><br></pre></td></tr></table></figure><p><img src="" alt=""></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.setrecursionlimit(<span class="number">10</span> ** <span class="number">9</span>)</span><br><span class="line">IA = <span class="keyword">lambda</span>: map(eval, input().split())</span><br><span class="line">IAL = <span class="keyword">lambda</span>: list(map(eval, input().split()))</span><br><span class="line">IM = <span class="keyword">lambda</span> N: [IA() <span class="keyword">for</span> _ <span class="keyword">in</span> range(N)]</span><br><span class="line"><span class="comment"># !/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line">N = <span class="number">100005</span></span><br><span class="line">a = [int(<span class="number">0</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(N)]</span><br><span class="line">x1,y1=IA()</span><br><span class="line">x2,y2=IA()</span><br><span class="line">x3,y3=IA()</span><br><span class="line">a=((y2-y1)*(y3*y3-y1*y1+x3*x3-x1*x1)-(y3-y1)*(y2*y2-y1*y1+x2*x2-x1*x1))/(<span class="number">2.0</span>*((x3-x1)*(y2-y1)-(x2-x1)*(y3-y1)))</span><br><span class="line">b=((x2-x1)*(x3*x3-x1*x1+y3*y3-y1*y1)-(x3-x1)*(x2*x2-x1*x1+y2*y2-y1*y1))/(<span class="number">2.0</span>*((y3-y1)*(x2-x1)-(y2-y1)*(x3-x1)))</span><br><span class="line">print(<span class="string">'%.3f'</span> %a,end=<span class="string">" "</span>)</span><br><span class="line">print(<span class="string">'%.3f'</span> %b)</span><br><span class="line"><span class="comment">#print("%.3lf %.3lf"%(a,b))</span></span><br></pre></td></tr></table></figure><h1 id="C-Channels"><a href="#C-Channels" class="headerlink" title="C Channels"></a>C Channels</h1><p>链接：<a href="https://ac.nowcoder.com/acm/contest/3947/C" target="_blank" rel="noopener">https://ac.nowcoder.com/acm/contest/3947/C</a><br>来源：牛客网</p><p>时间限制：C/C++ 1秒，其他语言2秒<br> 空间限制：C/C++ 131072K，其他语言262144K<br> 64bit IO Format: %lld</p><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>Nancy喜欢学习，也喜欢看电视。<br> 为了想了解她能看多长时间的节目，不妨假设节目从时刻1开始，一直播放到时刻6×101006 \times 10^{100}6×10100。每个节目持续50个时刻，节目与节目间会有10个时刻的广告时间。<br> 然而，Nancy实在是太忙了，她从t1t_1t1​时刻开始观看，观看至t2t_2t2​时刻，请你帮忙计算她有多少个时刻能欣赏到电视节目。</p><h2 id="输入描述-1"><a href="#输入描述-1" class="headerlink" title="输入描述:"></a>输入描述:</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">若干行：每行两个整数t1t_1t1与t2t_2t2。</span><br><span class="line">数据满足：1≤t1≤t2≤10181 \leq t_1 \leq t_2 \leq 10^&#123;18&#125;1≤t1≤t2≤1018。</span><br></pre></td></tr></table></figure><h2 id="输出描述-1"><a href="#输出描述-1" class="headerlink" title="输出描述:"></a>输出描述:</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">若干行：每行一个整数，表示能品味电视节目的时刻数。</span><br></pre></td></tr></table></figure><p>示例1</p><h2 id="输入-1"><a href="#输入-1" class="headerlink" title="输入"></a>输入</h2><p><a href="javascript:void(0);">复制</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 61</span><br></pre></td></tr></table></figure><h2 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h2><p><a href="javascript:void(0);">复制</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">51</span><br></pre></td></tr></table></figure><p>示例2</p><h2 id="输入-2"><a href="#输入-2" class="headerlink" title="输入"></a>输入</h2><p><a href="javascript:void(0);">复制</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">116969978 507978500</span><br><span class="line">180480072 791550396</span><br><span class="line">139567120 655243745</span><br><span class="line">1470545 167613747</span><br><span class="line">57644034 176077476</span><br><span class="line">44676 56984808</span><br><span class="line">215706822 369042088</span><br><span class="line">108368065 320914746</span><br></pre></td></tr></table></figure><h2 id="输出-2"><a href="#输出-2" class="headerlink" title="输出"></a>输出</h2><p><a href="javascript:void(0);">复制</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">325840433</span><br><span class="line">509225275</span><br><span class="line">429730516</span><br><span class="line">138452673</span><br><span class="line">98694536</span><br><span class="line">47450113</span><br><span class="line">127779387</span><br><span class="line">177122232</span><br></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>前缀和+容斥：统计[L,R]中60的个数：num=R/60-(L-1)/60。（注意num先-1，因为首个60可能不完整）</p><p>然后计算端点L,R的贡献</p><p>多组输入</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.setrecursionlimit(<span class="number">10</span> ** <span class="number">9</span>)</span><br><span class="line">IA = <span class="keyword">lambda</span>: [int(x) <span class="keyword">for</span> x <span class="keyword">in</span> input().split()]</span><br><span class="line">IM = <span class="keyword">lambda</span> N: [IA() <span class="keyword">for</span> _ <span class="keyword">in</span> range(N)]</span><br><span class="line"><span class="comment"># !/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line">N = <span class="number">100005</span></span><br><span class="line">a = [int(<span class="number">0</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(N)]</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        x,y=IA()</span><br><span class="line">        n=y//<span class="number">60</span>-(x<span class="number">-1</span>)//<span class="number">60</span></span><br><span class="line">        n-=<span class="number">1</span></span><br><span class="line">        add1=min(y%<span class="number">60</span>,<span class="number">50</span>)</span><br><span class="line">        add2=max(<span class="number">60</span>-(x<span class="number">-1</span>)%<span class="number">60</span><span class="number">-10</span>,<span class="number">0</span>)</span><br><span class="line">        <span class="comment">#print(add2)</span></span><br><span class="line">        ans=n*<span class="number">50</span>+add1+add2</span><br><span class="line">        print(ans)</span><br><span class="line">    <span class="keyword">except</span> EOFError:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><hr><h1 id="D-DDoS"><a href="#D-DDoS" class="headerlink" title="D DDoS"></a>D DDoS</h1><p>链接：<a href="https://ac.nowcoder.com/acm/contest/3947/D" target="_blank" rel="noopener">https://ac.nowcoder.com/acm/contest/3947/D</a><br>来源：牛客网</p><p>时间限制：C/C++ 1秒，其他语言2秒<br> 空间限制：C/C++ 131072K，其他语言262144K<br> 64bit IO Format: %lld</p><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>Nancy的男朋友喜欢网络安全！<br> 最近，一种新的DDoS——脉冲波悄然来临。其基本原理是利用不同线路服务器的延时，使得Request同时到达目标服务器，以堵塞其它正常的通讯。<br> 不妨假设攻击者在1号节点，目标服务器在nnn号节点，其余节点（2到n-1号节点）为中继服务器。<br> 攻击者可以在任意时间发送一个定向数据包（即规定其经过中继服务器的路线，但不同数据包的路线不能完全相同），目标服务器对这种数据包具有100%的识别率，一旦识别到这种数据包，则会屏蔽这一时刻后的所有数据包。<br> Nancy好奇，攻击者在最优策略下，目标服务器能够收到多少份数据包呢？</p><h2 id="输入描述-2"><a href="#输入描述-2" class="headerlink" title="输入描述:"></a>输入描述:</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第一行：两个整数n,m。</span><br><span class="line">接下来m行：每行三个整数x,y,z，表示节点x与y可以单向通信（x到y），耗时为z。</span><br><span class="line">数据满足：3≤n≤100000,1≤m≤2000003 \leq n \leq 100000, 1 \leq m \leq 2000003≤n≤100000,1≤m≤200000，0≤z≤⌊10πe⌋0 \leq z \leq \lfloor10^&#123;\pi e&#125;\rfloor0≤z≤⌊10πe⌋，图为拓扑图（有向无环图）。</span><br></pre></td></tr></table></figure><h2 id="输出描述-2"><a href="#输出描述-2" class="headerlink" title="输出描述:"></a>输出描述:</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">共一行：表示攻击者在最优策略下，目标服务器能够收到数据包的数量。</span><br><span class="line">由于数量可能会很大，你只需要输出答案对20010905取模后的值。</span><br></pre></td></tr></table></figure><p>示例1</p><h2 id="输入-3"><a href="#输入-3" class="headerlink" title="输入"></a>输入</h2><p><a href="javascript:void(0);">复制</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4 4</span><br><span class="line">1 2 3</span><br><span class="line">1 3 1</span><br><span class="line">2 4 1</span><br><span class="line">3 4 3</span><br></pre></td></tr></table></figure><h2 id="输出-3"><a href="#输出-3" class="headerlink" title="输出"></a>输出</h2><p><a href="javascript:void(0);">复制</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">显然，攻击者在0时刻发送两个定向数据包（1-2-4和1-3-4），它们同时在第4时刻到达目标服务器。</span><br></pre></td></tr></table></figure><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>官方题解：</p><p><strong>不易观察、挺难发现、较难得到攻击者可以通过调整发送数据包的时间来使得所有数据包同时到达服务器</strong>(想打出题人），故原题意转化为求1到n的路径条数，拓扑图上DP即可。</p><p>注意定向的含义是规定路线及经过的中继节点，所以重边的时候格外小心（需要算两倍）。</p><p>边权无用（其实这里给了个奇怪的数据范围是在暗示呢QwQ）</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><p>python（超时）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> queue</span><br><span class="line">sys.setrecursionlimit(<span class="number">10</span> ** <span class="number">9</span>)</span><br><span class="line">IA = <span class="keyword">lambda</span>: map(eval, input().split())</span><br><span class="line">IAL = <span class="keyword">lambda</span>: list(map(eval, input().split()))</span><br><span class="line">IM = <span class="keyword">lambda</span> N: [IA() <span class="keyword">for</span> _ <span class="keyword">in</span> range(N)]</span><br><span class="line"><span class="comment"># !/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line">N = <span class="number">100005</span></span><br><span class="line">MOD = <span class="number">20010905</span></span><br><span class="line">tot = int(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Edge</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span>  <span class="title">__init__</span><span class="params">(self,to,next)</span>:</span></span><br><span class="line">        self.to=to</span><br><span class="line">        self.next=next</span><br><span class="line"></span><br><span class="line">e=[]</span><br><span class="line">e.append(Edge(<span class="number">-1</span>,<span class="number">-1</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = [int(<span class="number">0</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(N)]</span><br><span class="line">ru = [int(<span class="number">0</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(N)]</span><br><span class="line">head = [int(<span class="number">-1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(N)]</span><br><span class="line">dp = [int(<span class="number">0</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(N)]</span><br><span class="line">q = queue.Queue(maxsize = N)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x,y)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> tot</span><br><span class="line">    tot=tot+<span class="number">1</span></span><br><span class="line">    e.append(Edge(y,head[x]))</span><br><span class="line">    head[x]=tot</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">query_num</span><span class="params">(st, en)</span>:</span></span><br><span class="line">    q.put(<span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">1</span>]=<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> q.empty() == <span class="literal">False</span>:</span><br><span class="line">        now = q.get()</span><br><span class="line">        <span class="comment">#print(now)</span></span><br><span class="line">        i=head[now]</span><br><span class="line">        <span class="keyword">while</span> i!=<span class="number">-1</span>:</span><br><span class="line">            ru[e[i].to]-=<span class="number">1</span>;</span><br><span class="line">            <span class="comment">#print(e[i].to)</span></span><br><span class="line">            dp[e[i].to]=(dp[e[i].to]+dp[now])%MOD</span><br><span class="line">            <span class="keyword">if</span> ru[e[i].to]==<span class="number">0</span>:</span><br><span class="line">                q.put(e[i].to)</span><br><span class="line">            i=e[i].next</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">n,m=IA()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">    x,y,z=IA()</span><br><span class="line">    add(x,y)</span><br><span class="line">    ru[y]+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">query_num(<span class="number">1</span>,n)</span><br><span class="line">print(dp[n])</span><br></pre></td></tr></table></figure><p>C++</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">20010905</span>;</span><br><span class="line"><span class="keyword">int</span> num[N], w[N];</span><br><span class="line"><span class="keyword">int</span> en, head[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, nxt;</span><br><span class="line">&#125; e[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"> </span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[++en].to = y;</span><br><span class="line">    e[en].nxt = head[x];</span><br><span class="line">    head[x] = en;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>, x, y, z; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;x, &amp;y, &amp;z);</span><br><span class="line">        add(x, y);</span><br><span class="line">        ++num[y];</span><br><span class="line">    &#125;</span><br><span class="line">    q.push(<span class="number">1</span>);</span><br><span class="line">    w[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">register</span> <span class="keyword">int</span> now = q.front(); q.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = head[now]; i; i = e[i].nxt) &#123;</span><br><span class="line">            --num[e[i].to];</span><br><span class="line">            w[e[i].to] = (w[e[i].to] + w[now]) % mod;</span><br><span class="line">            <span class="keyword">if</span> (!num[e[i].to]) &#123;</span><br><span class="line">                q.push(e[i].to);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, w[n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="E-Exams"><a href="#E-Exams" class="headerlink" title="E    Exams"></a>E    Exams</h1><p>链接：<a href="https://ac.nowcoder.com/acm/contest/3947/E" target="_blank" rel="noopener">https://ac.nowcoder.com/acm/contest/3947/E</a><br>来源：牛客网</p><p>时间限制：C/C++ 1秒，其他语言2秒<br> 空间限制：C/C++ 131072K，其他语言262144K<br> 64bit IO Format: %lld</p><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>Nancy是老师的小帮手！<br> 众所周知，大学的学分绩点十分难以计算 。<br> 一门课程，有必修、限选、任选之分，而其成绩，又由平时成绩、期中考试、期末考试之分，最后还要对总分数进行四舍五入。<br> 具体的，一名同学的学分绩点是这样计算的：</p><ul><li><p>计算且仅计算必修和限选课程    </p></li><li><p>根据平时成绩、期中成绩、期末成绩对应的不同比例求和，并四舍五入到整数    </p></li><li><p>学分绩点为各门课成绩乘以学分占总学分的比例    </p></li><li><p>对计算结果进行四舍五入（保留两位小数）   </p><p>下面你知道了Nancy的成绩单，请你计算其最终学分绩点。</p></li></ul><h2 id="输入描述-3"><a href="#输入描述-3" class="headerlink" title="输入描述:"></a>输入描述:</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第一行：一个整数n，表示Nancy本学期修读了n门课程</span><br><span class="line">接下来n行：每行一个整数和七个实数，表示课程性质（0为必修，1为限选，2为任选），学分，平时成绩及其比例，期中考试及其比例，期末考试及其比例，保证比例之和为1，且实数最多有一位小数。</span><br><span class="line">数据满足1≤n≤641 \leq n \leq 641≤n≤64，课程性质∈&#123;0,1,2&#125;\in\&#123;0,1,2\&#125;∈&#123;0,1,2&#125;，学分∈[1,16]\in[1,16]∈[1,16]成绩∈[0,100]\in[0, 100]∈[0,100]，比例∈[0,1]\in[0,1]∈[0,1]，数据保证至少有一门必修或限选课。</span><br></pre></td></tr></table></figure><h2 id="输出描述-3"><a href="#输出描述-3" class="headerlink" title="输出描述:"></a>输出描述:</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">共一行：表示Nancy的学分绩点。</span><br></pre></td></tr></table></figure><p>示例1</p><h2 id="输入-4"><a href="#输入-4" class="headerlink" title="输入"></a>输入</h2><p><a href="javascript:void(0);">复制</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">0 1 97 1 0 0 0 0</span><br><span class="line">0 2.5 98 0.3 0 0 92 0.7</span><br><span class="line">0 4 100 0.3 0 0 100 0.7</span><br><span class="line">0 1 0 0 0 0 74 1</span><br><span class="line">0 2 94 1 0 0 0 0</span><br></pre></td></tr></table></figure><h2 id="输出-4"><a href="#输出-4" class="headerlink" title="输出"></a>输出</h2><p><a href="javascript:void(0);">复制</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">94.67</span><br></pre></td></tr></table></figure><h2 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h2><p>模拟即可，注意四舍五入</p><h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.setrecursionlimit(<span class="number">10</span> ** <span class="number">9</span>)</span><br><span class="line">IA = <span class="keyword">lambda</span>: [float(x) <span class="keyword">for</span> x <span class="keyword">in</span> input().split()]</span><br><span class="line">IM = <span class="keyword">lambda</span> N: [IA() <span class="keyword">for</span> _ <span class="keyword">in</span> range(N)]</span><br><span class="line"><span class="comment"># !/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line">N = <span class="number">100005</span></span><br><span class="line">x = [float(<span class="number">0</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(N)]</span><br><span class="line">sum1 = [int(<span class="number">0</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(N)]</span><br><span class="line">xue = [float(<span class="number">0</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(N)]</span><br><span class="line">n=int(input())</span><br><span class="line"></span><br><span class="line">sum=float(<span class="number">0</span>)</span><br><span class="line">sum2=float(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,n):</span><br><span class="line">    x[<span class="number">0</span>], x[<span class="number">1</span>], x[<span class="number">2</span>], x[<span class="number">3</span>], x[<span class="number">4</span>], x[<span class="number">5</span>], x[<span class="number">6</span>], x[<span class="number">7</span>] = IA()</span><br><span class="line">    <span class="keyword">if</span> (x[<span class="number">0</span>] == <span class="number">2</span>): <span class="keyword">continue</span></span><br><span class="line">    sum1[i]=int(x[<span class="number">2</span>]*x[<span class="number">3</span>]+x[<span class="number">4</span>]*x[<span class="number">5</span>]+x[<span class="number">6</span>]*x[<span class="number">7</span>]+<span class="number">0.5</span>)</span><br><span class="line">    sum2+=x[<span class="number">1</span>]</span><br><span class="line">    xue[i]=x[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,n):</span><br><span class="line">    sum+=sum1[i]*(xue[i]/sum2)</span><br><span class="line">print(<span class="string">'%.2f'</span> %sum)</span><br></pre></td></tr></table></figure><hr><h1 id="F-Fool-Problem"><a href="#F-Fool-Problem" class="headerlink" title="F Fool Problem"></a>F Fool Problem</h1><p>链接：<a href="https://ac.nowcoder.com/acm/contest/3947/F" target="_blank" rel="noopener">https://ac.nowcoder.com/acm/contest/3947/F</a><br>来源：牛客网</p><p>时间限制：C/C++ 1秒，其他语言2秒<br> 空间限制：C/C++ 131072K，其他语言262144K<br> 64bit IO Format: %lld</p><h2 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h2><p>  Nancy喜欢斐波那契数列！ </p><p>  若f0=0,f1=1,f2=1f_0=0,f_1=1,f_2=1f0=0,f1=1,f2=1，请求：fn+1fn−1−fn2(n≥2)f_{n+1}f_{n-1}-f_n^2(n\geq2)fn+1fn−1−fn2(n≥2)，其中fif_ifi表示斐波那契数列第i项。 </p><h2 id="输入描述-4"><a href="#输入描述-4" class="headerlink" title="输入描述:"></a>输入描述:</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">共一行：一个整数n。</span><br><span class="line">数据满足：2≤n≤1020202 \leq n \leq 10^&#123;2020&#125;2≤n≤102020。</span><br></pre></td></tr></table></figure><h2 id="输出描述-4"><a href="#输出描述-4" class="headerlink" title="输出描述:"></a>输出描述:</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">共一行：表示表达式的值。</span><br></pre></td></tr></table></figure><p>示例1</p><h2 id="输入-5"><a href="#输入-5" class="headerlink" title="输入"></a>输入</h2><p><a href="javascript:void(0);">复制</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><h2 id="输出-5"><a href="#输出-5" class="headerlink" title="输出"></a>输出</h2><p><a href="javascript:void(0);">复制</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.setrecursionlimit(<span class="number">10</span> ** <span class="number">9</span>)</span><br><span class="line">IA = <span class="keyword">lambda</span>: [int(x) <span class="keyword">for</span> x <span class="keyword">in</span> input().split()]</span><br><span class="line">IM = <span class="keyword">lambda</span> N: [IA() <span class="keyword">for</span> _ <span class="keyword">in</span> range(N)]</span><br><span class="line"><span class="comment"># !/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line">N = <span class="number">100005</span></span><br><span class="line">a = [int(<span class="number">0</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(N)]</span><br><span class="line">n=IA()</span><br><span class="line"><span class="keyword">if</span> n[<span class="number">0</span>]%<span class="number">2</span>==<span class="number">0</span>:</span><br><span class="line">    print(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="number">-1</span>)</span><br></pre></td></tr></table></figure><hr><h1 id="G-Game"><a href="#G-Game" class="headerlink" title="G Game"></a>G Game</h1><p>链接：<a href="https://ac.nowcoder.com/acm/contest/3947/G" target="_blank" rel="noopener">https://ac.nowcoder.com/acm/contest/3947/G</a><br>来源：牛客网</p><p>时间限制：C/C++ 1秒，其他语言2秒<br> 空间限制：C/C++ 131072K，其他语言262144K<br> 64bit IO Format: %lld</p><h2 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h2><p>Nancy喜欢博弈！<br> Johnson和Nancy得到了一个神奇的多重集合，仅包含一个正整数n，两个人轮流进行操作。<br> 一次操作可以将集合中一个数字分解为它的任意两个非1的因数，并加入集合中。<br> 他们想知道，在Johnson和Nancy绝顶聪明的情况下，如果Nancy先手进行操作，最后谁没有办法继续操作了呢？</p><h2 id="输入描述-5"><a href="#输入描述-5" class="headerlink" title="输入描述:"></a>输入描述:</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">第一行：一个整数n。</span><br><span class="line">数据满足：1≤n≤957181 \leq n \leq 957181≤n≤95718。</span><br></pre></td></tr></table></figure><h2 id="输出描述-5"><a href="#输出描述-5" class="headerlink" title="输出描述:"></a>输出描述:</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">共一行：一个字符串，表示最后谁（Johnson或者Nancy）无法进行操作。</span><br></pre></td></tr></table></figure><p>示例1</p><h2 id="输入-6"><a href="#输入-6" class="headerlink" title="输入"></a>输入</h2><p><a href="javascript:void(0);">复制</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><h2 id="输出-6"><a href="#输出-6" class="headerlink" title="输出"></a>输出</h2><p><a href="javascript:void(0);">复制</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Johnson</span><br></pre></td></tr></table></figure><h2 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h2><p>不难发现某一个数字的质因子个数是一定的，计算其质因子个数来探究可分解的步数进行博弈即可。</p><p>其实最后只需要考虑质因子个数的奇偶性。</p><h2 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> queue</span><br><span class="line">sys.setrecursionlimit(<span class="number">10</span> ** <span class="number">9</span>)</span><br><span class="line">IA = <span class="keyword">lambda</span>: map(int, input().split())</span><br><span class="line">IAL = <span class="keyword">lambda</span>: list(map(int, input().split()))</span><br><span class="line">IM = <span class="keyword">lambda</span> N: [IA() <span class="keyword">for</span> _ <span class="keyword">in</span> range(N)]</span><br><span class="line"><span class="comment"># !/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line">N = <span class="number">100005</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(n)</span>:</span></span><br><span class="line">    num = int(<span class="number">0</span>)</span><br><span class="line">    i = int(<span class="number">2</span>)</span><br><span class="line">    temp=int(n)</span><br><span class="line">    <span class="keyword">while</span> i*i &lt;=temp:</span><br><span class="line">        <span class="keyword">if</span>(temp%i==<span class="number">0</span>):</span><br><span class="line">            <span class="keyword">while</span> temp % i==<span class="number">0</span>:</span><br><span class="line">                temp/=i</span><br><span class="line">                num+=<span class="number">1</span></span><br><span class="line">        i+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> temp &gt;<span class="number">1</span>:</span><br><span class="line">        num+=<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> num</span><br><span class="line">n=int(input())</span><br><span class="line"><span class="keyword">if</span> n == <span class="number">1</span>  <span class="keyword">or</span> n == <span class="number">2</span>:</span><br><span class="line">    print(<span class="string">"Johnson"</span>)</span><br><span class="line"><span class="keyword">elif</span> f(n)%<span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">    print(<span class="string">"Johnson"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">"Nancy"</span>)</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  LL long long</span></span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">f</span><span class="params">(LL m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL sum = <span class="number">0</span>;</span><br><span class="line">    LL tmp = m;</span><br><span class="line">    <span class="keyword">for</span>(LL i = <span class="number">2</span>; i*i&lt;=tmp; i++)    </span><br><span class="line">        <span class="keyword">if</span>(tmp%i==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">           </span><br><span class="line">            <span class="keyword">while</span>(tmp%i==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                tmp /=  i;</span><br><span class="line">                sum++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span>(tmp&gt;<span class="number">1</span>)</span><br><span class="line">        sum++;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="comment">//cout&lt;&lt;f(n)&lt;&lt;endl;</span></span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>||n==<span class="number">2</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Johnson\n"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(f(n)%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Johnson\n"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Nancy\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="I、I-love-you"><a href="#I、I-love-you" class="headerlink" title="I、I love you"></a>I、I love you</h1><p>链接：<a href="https://ac.nowcoder.com/acm/contest/3947/I" target="_blank" rel="noopener">https://ac.nowcoder.com/acm/contest/3947/I</a><br>来源：牛客网</p><p>时间限制：C/C++ 1秒，其他语言2秒<br> 空间限制：C/C++ 131072K，其他语言262144K<br> 64bit IO Format: %lld</p><h2 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote><p>  此时相望不相闻，愿逐月华流照君。 </p></blockquote><p> 一纸情书，到底蕴含了多少倍的爱情呢？</p><blockquote><p>  I love you, not only for what you are, but for what I am when I am with you. </p></blockquote><h2 id="输入描述-6"><a href="#输入描述-6" class="headerlink" title="输入描述:"></a>输入描述:</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">共一行：一封若干个字符的情书（大小写不敏感）。</span><br><span class="line">情书不会超过684594个字符（大写、小写字母）。</span><br></pre></td></tr></table></figure><h2 id="输出描述-6"><a href="#输出描述-6" class="headerlink" title="输出描述:"></a>输出描述:</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">共一行：包含一个整数，即iloveyou在情书中作为子序列出现的次数。</span><br><span class="line">由于答案可能很大，请输出对20010905取模后的值。</span><br></pre></td></tr></table></figure><p>示例1</p><h2 id="输入-7"><a href="#输入-7" class="headerlink" title="输入"></a>输入</h2><p><a href="javascript:void(0);">复制</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IloveyouNotonlyforwhatyouareButforwhatIamWhenIamwithyouIloveyouNotonlyforwhatYouhavemadeofyourselfButforwhatYouaremakingofme</span><br></pre></td></tr></table></figure><h2 id="输出-7"><a href="#输出-7" class="headerlink" title="输出"></a>输出</h2><p><a href="javascript:void(0);">复制</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2864</span><br></pre></td></tr></table></figure><h2 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h2><p>小思维</p><h2 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.setrecursionlimit(<span class="number">10</span> ** <span class="number">9</span>)</span><br><span class="line">IA = <span class="keyword">lambda</span>: [int(x) <span class="keyword">for</span> x <span class="keyword">in</span> input().split()]</span><br><span class="line">IM = <span class="keyword">lambda</span> N: [IA() <span class="keyword">for</span> _ <span class="keyword">in</span> range(N)]</span><br><span class="line"><span class="comment"># !/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line">N = <span class="number">100005</span></span><br><span class="line">a = [int(<span class="number">0</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(N)]</span><br><span class="line">str=input().lower()</span><br><span class="line">l=len(str)</span><br><span class="line">a=int(<span class="number">0</span>)</span><br><span class="line">b=int(<span class="number">0</span>)</span><br><span class="line">c=int(<span class="number">0</span>)</span><br><span class="line">e=int(<span class="number">0</span>)</span><br><span class="line">f=int(<span class="number">0</span>)</span><br><span class="line">g=int(<span class="number">0</span>)</span><br><span class="line">h=int(<span class="number">0</span>)</span><br><span class="line">d=int(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">MOD = int(<span class="number">20010905</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,l):</span><br><span class="line">    <span class="keyword">if</span> str[i]==<span class="string">'i'</span>:a=(a+<span class="number">1</span>)%MOD</span><br><span class="line">    <span class="keyword">if</span> str[i]==<span class="string">'l'</span>:b=(b+a)%MOD</span><br><span class="line">    <span class="keyword">if</span> str[i] == <span class="string">'o'</span>: c = (c + b) % MOD</span><br><span class="line">    <span class="keyword">if</span> str[i] == <span class="string">'v'</span>: d=(d+c)%MOD</span><br><span class="line">    <span class="keyword">if</span> str[i] == <span class="string">'e'</span>: e=(e+d)%MOD</span><br><span class="line">    <span class="keyword">if</span> str[i] == <span class="string">'y'</span>: f=(f+e)%MOD</span><br><span class="line">    <span class="keyword">if</span> str[i] == <span class="string">'o'</span>: g=(g+f)%MOD</span><br><span class="line">    <span class="keyword">if</span> str[i] == <span class="string">'u'</span>: h=(h+g)%MOD</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(h)</span><br><span class="line"></span><br><span class="line"><span class="comment">#I love you Notonlyforwhat you areButforwhat I amWhen I amwith you I love you Notonlyforwhat You havemadeof your selfButforwhat You aremakingofme</span></span><br></pre></td></tr></table></figure><hr><h1 id="J-Jelly"><a href="#J-Jelly" class="headerlink" title="J Jelly"></a>J Jelly</h1><p>链接：<a href="https://ac.nowcoder.com/acm/problem/201613" target="_blank" rel="noopener">https://ac.nowcoder.com/acm/problem/201613</a><br>来源：牛客网</p><p>时间限制：C/C++ 1秒，其他语言2秒<br> 空间限制：C/C++ 131072K，其他语言262144K<br> 64bit IO Format: %lld</p><h2 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h2><p>Nancy喜欢吃果冻！</p><p>  Nancy钻进了一个n×n×nn \times n \times nn×n×n的果冻里，她想从(1,1,1)一路上、下、左、右、前、后六个方向吃到(n,n,n)。 </p><p>  但果冻毕竟是有许多口味的，标记为*的口味是Nancy不愿意吃的，其余的果冻均标记为.。 </p><p> Nancy不想吃坏肚子，于是她想尽可能少的吃果冻。<br> 下面给出果冻的情况，请你帮忙计算一下她能吃多少块果冻叭！</p><h2 id="输入描述-7"><a href="#输入描述-7" class="headerlink" title="输入描述:"></a>输入描述:</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第一行：一个整数n。</span><br><span class="line">接下来n层，每组n行，每行n列，表示果冻(i,j,k)的情况（如题目描述所述）。</span><br><span class="line">数据满足：1≤n≤1001 \leq n \leq 1001≤n≤100，保证果冻(1,1,1)不是Nancy不愿意吃的。</span><br></pre></td></tr></table></figure><h2 id="输出描述-7"><a href="#输出描述-7" class="headerlink" title="输出描述:"></a>输出描述:</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果可以到达(n,n,n)，请输出路上吃的果冻数量，否则请输出-1。</span><br></pre></td></tr></table></figure><p>示例1</p><h2 id="输入-8"><a href="#输入-8" class="headerlink" title="输入"></a>输入</h2><p><a href="javascript:void(0);">复制</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">.*</span><br><span class="line">..</span><br><span class="line">*.</span><br><span class="line">..</span><br></pre></td></tr></table></figure><h2 id="输出-8"><a href="#输出-8" class="headerlink" title="输出"></a>输出</h2><p><a href="javascript:void(0);">复制</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><h2 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h2><p>bfs即可，不过python依旧超时</p><h2 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> queue</span><br><span class="line">sys.setrecursionlimit(<span class="number">10</span> ** <span class="number">9</span>)</span><br><span class="line">IA = <span class="keyword">lambda</span>: map(int, input().split())</span><br><span class="line">IAL = <span class="keyword">lambda</span>: list(map(int, input().split()))</span><br><span class="line">IM = <span class="keyword">lambda</span> N: [IA() <span class="keyword">for</span> _ <span class="keyword">in</span> range(N)]</span><br><span class="line"><span class="comment"># !/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,x,y,z,step)</span>:</span></span><br><span class="line">        self.x=<span class="number">0</span></span><br><span class="line">        self.y=<span class="number">0</span></span><br><span class="line">        self.z=<span class="number">0</span></span><br><span class="line">        self.step=<span class="number">0</span></span><br><span class="line"></span><br><span class="line">dx=[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>]</span><br><span class="line">dy=[<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">dz=[<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">N = <span class="number">105</span></span><br><span class="line">n=int(input())</span><br><span class="line">mp = [[[int(<span class="number">0</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(n)] <span class="keyword">for</span> i <span class="keyword">in</span> range(n)] <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">vis = [[[int(<span class="number">0</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(n)] <span class="keyword">for</span> i <span class="keyword">in</span> range(n)] <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,n):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>,n):</span><br><span class="line">        s=input()</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">0</span>,n):</span><br><span class="line">            <span class="keyword">if</span> s[k]==<span class="string">'*'</span>:</span><br><span class="line">                mp[i][j][k]=<span class="number">-1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">q=queue.Queue()</span><br><span class="line">q.put(Node(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>))</span><br><span class="line">vis[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span></span><br><span class="line">ans=int(<span class="number">1e9</span>)</span><br><span class="line">flag=int(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">while</span> q.empty()==<span class="literal">False</span> :</span><br><span class="line">    a=q.get()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">6</span>):</span><br><span class="line">        b = Node(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        b.x=a.x+dx[i]</span><br><span class="line">        b.y=a.y+dy[i]</span><br><span class="line">        b.z=a.z+dz[i]</span><br><span class="line">        b.step=a.step+<span class="number">1</span></span><br><span class="line">        <span class="comment">#print(str(b.x) + " " + str(b.y) + " " + str(b.z)+" "+str(mp[b.x][b.y][b.z]))</span></span><br><span class="line">        <span class="keyword">if</span>(b.x&gt;=<span class="number">0</span> <span class="keyword">and</span> b.x&lt;n <span class="keyword">and</span> b.y&gt;=<span class="number">0</span> <span class="keyword">and</span> b.y&lt;n <span class="keyword">and</span> b.z&gt;=<span class="number">0</span> <span class="keyword">and</span> b.z&lt;n <span class="keyword">and</span> mp[b.x][b.y][b.z]!=<span class="number">-1</span> <span class="keyword">and</span> vis[b.x][b.y][b.z]==<span class="number">0</span>):</span><br><span class="line">            q.put(b)</span><br><span class="line">            vis[b.x][b.y][b.z]=<span class="number">1</span></span><br><span class="line">            <span class="comment">#print(str(b.x)+" "+str(b.y)+" "+str(b.z))</span></span><br><span class="line">            <span class="keyword">if</span>(b.x==n<span class="number">-1</span> <span class="keyword">and</span> b.y==n<span class="number">-1</span> <span class="keyword">and</span> b.z==n<span class="number">-1</span>):</span><br><span class="line">                ans=b.step</span><br><span class="line">                flag=<span class="number">1</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> flag==<span class="number">1</span>:<span class="keyword">break</span></span><br><span class="line"><span class="keyword">if</span> ans==<span class="number">1e9</span>:print(<span class="number">-1</span>)</span><br><span class="line"><span class="keyword">else</span>:print(ans+<span class="number">1</span>)</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">const</span> ll mod=<span class="number">20010905</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> mp[maxn][maxn][maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn][maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> dx[]=&#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> dy[]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> dz[]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y,z;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">step</span>;</span><br><span class="line">    Node(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z,<span class="keyword">int</span> <span class="built_in">step</span>):x(x),y(y),z(z),<span class="built_in">step</span>(<span class="built_in">step</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=n; j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>; k&lt;=n; k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">char</span> a;</span><br><span class="line">                <span class="built_in">cin</span>&gt;&gt;a;</span><br><span class="line">                <span class="keyword">if</span>(a==<span class="string">'.'</span>)</span><br><span class="line">                    mp[i][j][k]=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    mp[i][j][k]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="built_in">queue</span>&lt;Node &gt;Q;</span><br><span class="line">    Q.push(Node(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>));</span><br><span class="line">    vis[<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">1e9</span>+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!Q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        Node node=Q.front();</span><br><span class="line">        Q.pop();</span><br><span class="line">        <span class="keyword">int</span> x=node.x,y=node.y,z=node.z;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">step</span>=node.<span class="built_in">step</span>;</span><br><span class="line">        <span class="keyword">if</span>(x==n&amp;&amp;y==n&amp;&amp;z==n)</span><br><span class="line">        &#123;</span><br><span class="line">            ans=<span class="built_in">min</span>(ans,<span class="built_in">step</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> nx=x+dx[i];</span><br><span class="line">            <span class="keyword">int</span> ny=y+dy[i];</span><br><span class="line">            <span class="keyword">int</span> nz=z+dz[i];</span><br><span class="line">            <span class="keyword">if</span>(nx&lt;<span class="number">1</span>||nx&gt;n) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(ny&lt;<span class="number">1</span>||ny&gt;n) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(nz&lt;<span class="number">1</span>||nz&gt;n) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(vis[nx][ny][nz]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(mp[nx][ny][nz]==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            vis[nx][ny][nz]=<span class="number">1</span>;</span><br><span class="line">            Q.push(Node(nx,ny,nz,<span class="built_in">step</span>+<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ans==<span class="number">1e9</span>+<span class="number">1</span>)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"-1"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    f();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>美赛2019A论文分析</title>
      <link href="/2020/01/18/%E7%BE%8E%E8%B5%9B2019A%E8%AE%BA%E6%96%87%E5%88%86%E6%9E%90/"/>
      <url>/2020/01/18/%E7%BE%8E%E8%B5%9B2019A%E8%AE%BA%E6%96%87%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="数学模型"><a href="#数学模型" class="headerlink" title="数学模型"></a>数学模型</h1><a id="more"></a><h2 id="Logistic阻滞增长模型求龙的重量"><a href="#Logistic阻滞增长模型求龙的重量" class="headerlink" title="Logistic阻滞增长模型求龙的重量"></a>Logistic阻滞增长模型求龙的重量</h2><p>学习资料：</p><p><a href="https://wenku.baidu.com/view/9f843184a0116c175f0e4862.html" target="_blank" rel="noopener">Logistic人口阻滞增长模型</a></p><p><a href="https://wenku.baidu.com/view/366b4abf5122aaea998fcc22bcd126fff6055d6f.html" target="_blank" rel="noopener">人口模型(马尔萨斯<strong>vs</strong>logistic)描述</a></p><p>套用到体重也算一个亮点</p><p>代码：</p><p>求结果并画图</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function f= Weg()</span><br><span class="line">p0 = <span class="number">10</span>;% 初始重量</span><br><span class="line">k = <span class="number">10694</span>;% 理论上限</span><br><span class="line">r = <span class="number">20</span> ;%  增长率</span><br><span class="line">a=<span class="number">0.03744</span>;% 环境影响因子</span><br><span class="line">t=<span class="number">0</span>:<span class="number">0.1</span>:<span class="number">15</span><span class="string">';% 时间线</span></span><br><span class="line"><span class="string">%表示以0为起点,以15为终点,以0.1为步长的一维矩阵.'</span>表示转置,就是行矩阵变成列矩阵.</span><br><span class="line">p_u = a*k*p0*exp(a*r*t);% 重量分数分子</span><br><span class="line">p_l = a*k+p0*(exp(a*r*t)<span class="number">-1</span>); %重量分数分母</span><br><span class="line">p = p_u./p_l/a; %体重</span><br><span class="line">plot(t,p)</span><br><span class="line">xlabel(<span class="string">'time/year'</span>)</span><br><span class="line">ylabel(<span class="string">'w(t)/kg'</span>)</span><br><span class="line">title(<span class="string">'weight-time'</span>)</span><br><span class="line">f=p</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>解微分方程</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y=dsolve(<span class="string">'Dy=r*y*(a-y/maxx)'</span>,<span class="string">'y(0)=10'</span>,<span class="string">'t'</span>)</span><br></pre></td></tr></table></figure><h2 id="求龙的长度"><a href="#求龙的长度" class="headerlink" title="求龙的长度"></a>求龙的长度</h2><p>不过想到弯曲和等价一个圆柱体确实很妙</p><p>出处来源：<a href="https://wenku.baidu.com/view/379fb7a2284ac850ad024259.html" target="_blank" rel="noopener">https://wenku.baidu.com/view/379fb7a2284ac850ad024259.html</a></p><p>网上有许多材料，关键要想到</p><p>代码很简单，看一下原文就ok</p><h2 id="龙的日消耗量（不带喷火）"><a href="#龙的日消耗量（不带喷火）" class="headerlink" title="龙的日消耗量（不带喷火）"></a>龙的日消耗量（不带喷火）</h2><p>类比各个动物，采用重量比例，简单而有效，作图漂亮</p><h2 id="龙的火焰"><a href="#龙的火焰" class="headerlink" title="龙的火焰"></a>龙的火焰</h2><p>奥卡姆剃刀定律认为保持事物的简单化是对付复杂与烦琐的事情的最 有效的方式。</p><p>火焰闻到可以燃烧铁，得到铁的沸点，得到火焰温度，得到火焰组成的充分。</p><p>化学公式和能量消耗，都是根据查阅资料可知。</p><h2 id="龙-羊栖息地模型"><a href="#龙-羊栖息地模型" class="headerlink" title="龙-羊栖息地模型"></a>龙-羊栖息地模型</h2><p>同样是logistic人口模型，学习资料与第一个一样。</p><p>解常微分方程</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function [t,x] = qixidi(a,r,k,tspan)</span><br><span class="line">%UNTITLED2 此处显示有关此函数的摘要</span><br><span class="line">%   此处显示详细说明</span><br><span class="line">x0 = k;</span><br><span class="line">s = @(t,x) r*x.*(<span class="number">1</span>-x/k)-a;</span><br><span class="line">%@ 函数句柄 相当于创建了一个函数</span><br><span class="line">[t,x]=ode45(s,tspan,x0);</span><br><span class="line">%该函数表示在区间tspan=[t0，t1]上，用初始条件y0求解显式常微分方程y<span class="string">'=s。</span></span><br><span class="line"><span class="string">% ode45的使用：https://wenku.baidu.com/view/45a0a0b54b73f242326c5f7f.html</span></span><br><span class="line"><span class="string">plot(t,x)</span></span><br><span class="line"><span class="string">y=zeros(1,length(x));</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">hold on</span></span><br><span class="line"><span class="string">plot(t,y)</span></span><br><span class="line"><span class="string">hold off</span></span><br><span class="line"><span class="string">%hold on是启动图形保持功能，当前坐标轴和图形都将保持，从此绘制的图形都将添加在这个图形的基础上，并自动调整坐标轴的范围。</span></span><br><span class="line"><span class="string">%hold off使当前轴及图像不再具备被刷新的性质，新图出现时，取消原图。即关闭图形保持功能。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">end</span></span><br></pre></td></tr></table></figure><p>ppt 第八章 12页</p><p><img src="https://raw.githubusercontent.com/pxlsdz/MarkDown-images/master/2020-1-21/solver.png" alt=""></p><p>生态系统面积与环境承载量直接设为成正比，很大胆</p><p>生态系统的能量传递效率（高中知识）。</p><h2 id="三种区域龙的影响"><a href="#三种区域龙的影响" class="headerlink" title="三种区域龙的影响"></a>三种区域龙的影响</h2><p>三种区域龙的日能量摄入差异 ：对比人类的代谢率。</p><p>三种区域的自我恢复与对龙的供给能力  ：感觉在瞎扯</p><h2 id="灵敏度分析"><a href="#灵敏度分析" class="headerlink" title="灵敏度分析"></a>灵敏度分析</h2><p>有增长率、环境因子和环境温度的变化对模型影响，算一个验证</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>大部分模型网上均有参考资料，且几乎一模一样。</li><li>想法奇妙，有的想法很简单但可以有效的解决问题</li><li>有始有终，有结果出来</li><li>排版舒服，插图精美</li><li>美赛的启示：思维开放和排版</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Logistic回归 </tag>
            
            <tag> 论文分析 </tag>
            
            <tag> 美赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>吴恩达课后编程作业 Course 1 神经网络和深度学习 - 第三周作业 -  带有一个隐藏层的平面数据分类</title>
      <link href="/2020/01/17/%E5%90%B4%E6%81%A9%E8%BE%BE%E8%AF%BE%E5%90%8E%E7%BC%96%E7%A8%8B%E4%BD%9C%E4%B8%9A-Course-1-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%92%8C%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E4%B8%89%E5%91%A8%E4%BD%9C%E4%B8%9A-%E5%B8%A6%E6%9C%89%E4%B8%80%E4%B8%AA%E9%9A%90%E8%97%8F%E5%B1%82%E7%9A%84%E5%B9%B3%E9%9D%A2%E6%95%B0%E6%8D%AE%E5%88%86%E7%B1%BB/"/>
      <url>/2020/01/17/%E5%90%B4%E6%81%A9%E8%BE%BE%E8%AF%BE%E5%90%8E%E7%BC%96%E7%A8%8B%E4%BD%9C%E4%B8%9A-Course-1-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%92%8C%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E4%B8%89%E5%91%A8%E4%BD%9C%E4%B8%9A-%E5%B8%A6%E6%9C%89%E4%B8%80%E4%B8%AA%E9%9A%90%E8%97%8F%E5%B1%82%E7%9A%84%E5%B9%B3%E9%9D%A2%E6%95%B0%E6%8D%AE%E5%88%86%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="任务"><a href="#任务" class="headerlink" title="任务"></a><strong>任务</strong></h1><ul><li>构建具有单隐藏层的2类分类神经网络。</li><li>使用具有非线性激活功能激活函数，例如tanh。</li><li>计算交叉熵损失（损失函数）。</li><li>实现向前和向后传播。</li></ul><a id="more"></a><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h1><h2 id="准备软件包"><a href="#准备软件包" class="headerlink" title="准备软件包"></a>准备软件包</h2><p>我们需要准备一些软件包：</p><p>numpy：是用Python进行科学计算的基本软件包。<br>sklearn：为数据挖掘和数据分析提供的简单高效的工具。<br>matplotlib ：是一个用于在Python中绘制图表的库。<br>testCases：提供了一些测试示例来评估函数的正确性，参见下载的资料或者在底部查看它的代码。<br>planar_utils ：提供了在这个任务中使用的各种有用的功能，参见下载的资料或者在底部查看它的代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> testCases <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sklearn</span><br><span class="line"><span class="keyword">import</span> sklearn.datasets</span><br><span class="line"><span class="keyword">import</span> sklearn.linear_model</span><br><span class="line"><span class="keyword">from</span> planar_utils <span class="keyword">import</span> plot_decision_boundary, sigmoid, load_planar_dataset, load_extra_datasets</span><br><span class="line"></span><br><span class="line"><span class="comment">#%matplotlib inline #如果你使用用的是Jupyter Notebook的话请取消注释。</span></span><br><span class="line"></span><br><span class="line">np.random.seed(<span class="number">1</span>) <span class="comment">#设置一个固定的随机种子，以保证接下来的步骤中我们的结果是一致的。</span></span><br></pre></td></tr></table></figure><h2 id="加载和查看数据集"><a href="#加载和查看数据集" class="headerlink" title="加载和查看数据集"></a>加载和查看数据集</h2><p>首先，我们来看看我们将要使用的数据集， 下面的代码会将一个花的图案的2类数据集加载到变量X和Y中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X, Y = load_planar_dataset()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_planar_dataset</span><span class="params">()</span>:</span></span><br><span class="line">    np.random.seed(<span class="number">1</span>)</span><br><span class="line">    m = <span class="number">400</span>  <span class="comment"># 样本数量</span></span><br><span class="line">    N = int(m / <span class="number">2</span>)  <span class="comment"># 每个类别的样本量</span></span><br><span class="line">    D = <span class="number">2</span>  <span class="comment"># 维度数</span></span><br><span class="line">    X = np.zeros((m, D))  <span class="comment"># 初始化X</span></span><br><span class="line">    Y = np.zeros((m, <span class="number">1</span>), dtype=<span class="string">'uint8'</span>)  <span class="comment"># 初始化Y</span></span><br><span class="line">    a = <span class="number">4</span>  <span class="comment"># 花儿的最大长度</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">        ix = range(N * j, N * (j + <span class="number">1</span>))</span><br><span class="line">        t = np.linspace(j * <span class="number">3.12</span>, (j + <span class="number">1</span>) * <span class="number">3.12</span>, N) + np.random.randn(N) * <span class="number">0.2</span>  <span class="comment"># theta</span></span><br><span class="line">        r = a * np.sin(<span class="number">4</span> * t) + np.random.randn(N) * <span class="number">0.2</span>  <span class="comment"># radius</span></span><br><span class="line">        X[ix] = np.c_[r * np.sin(t), r * np.cos(t)]</span><br><span class="line">        Y[ix] = j</span><br><span class="line"></span><br><span class="line">    X = X.T</span><br><span class="line">    Y = Y.T</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> X, Y</span><br></pre></td></tr></table></figure><p>把数据集加载完成了，然后使用matplotlib可视化数据集，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">plt.scatter(X[<span class="number">0</span>, :], X[<span class="number">1</span>, :], c=Y, s=<span class="number">40</span>, cmap=plt.cm.Spectral) <span class="comment">#绘制散点图</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 上一语句如出现问题，请使用下面的语句：</span></span><br><span class="line">plt.scatter(X[<span class="number">0</span>, :], X[<span class="number">1</span>, :], c=np.squeeze(Y), s=<span class="number">40</span>, cmap=plt.cm.Spectral) <span class="comment">#绘制散点图</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/pxlsdz/MarkDown-images/master/2020-1-17/%E8%8A%B1.png" alt=""></p><p>数据看起来像一朵红色（y = 0）和一些蓝色（y = 1）的数据点的花朵的图案。 我们的目标是建立一个模型来适应这些数据。现在，我们已经有了以下的东西：</p><p>X：一个numpy的矩阵，包含了这些数据点的数值<br>Y：一个numpy的向量，对应着的是X的标签【0 | 1】（红色:0 ， 蓝色 :1）<br>我们继续来仔细地看数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">shape_X = X.shape</span><br><span class="line">shape_Y = Y.shape</span><br><span class="line">m = Y.shape[<span class="number">1</span>]  <span class="comment"># 训练集里面的数量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> (<span class="string">"X的维度为: "</span> + str(shape_X))</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"Y的维度为: "</span> + str(shape_Y))</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"数据集里面的数据有："</span> + str(m) + <span class="string">" 个"</span>)</span><br></pre></td></tr></table></figure><h2 id="查看简单的Logistic回归的分类效果"><a href="#查看简单的Logistic回归的分类效果" class="headerlink" title="查看简单的Logistic回归的分类效果"></a>查看简单的Logistic回归的分类效果</h2><p>  在构建完整的神经网络之前，先让我们看看逻辑回归在这个问题上的表现如何，我们可以使用sklearn的内置函数来做到这一点， 运行下面的代码来训练数据集上的逻辑回归分类器。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">clf = sklearn.linear_model.LogisticRegressionCV()<span class="comment">#逻辑回归（交叉验证来选择正则化系数C）</span></span><br><span class="line">clf.fit(X.T,Y.T)</span><br></pre></td></tr></table></figure><p>这里会打印出以下的信息（不同的机器提示大同小异）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">D:\Anaconda3\envs\pytorch\lib\site-packages\sklearn\utils\validation.py:760: DataConversionWarning: A column-vector y was passed when a 1d array was expected. Please change the shape of y to (n_samples, ), for example using ravel().</span><br><span class="line">  y &#x3D; column_or_1d(y, warn&#x3D;True)</span><br></pre></td></tr></table></figure><p>我们可以把逻辑回归分类器的分类绘制出来：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">plot_decision_boundary(<span class="keyword">lambda</span> x: clf.predict(x), np.squeeze(X), np.squeeze(Y)) <span class="comment">#绘制决策边界</span></span><br><span class="line">plt.title(<span class="string">"Logistic Regression"</span>) <span class="comment">#图标题</span></span><br><span class="line">LR_predictions  = clf.predict(X.T) <span class="comment">#预测结果</span></span><br><span class="line"><span class="keyword">print</span> (<span class="string">"逻辑回归的准确性： %d "</span> % float((np.dot(Y, LR_predictions) + </span><br><span class="line">np.dot(<span class="number">1</span> - Y,<span class="number">1</span> - LR_predictions)) / float(Y.size) * <span class="number">100</span>) +</span><br><span class="line">       <span class="string">"% "</span> + <span class="string">"(正确标记的数据点所占的百分比)"</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">逻辑回归的准确性： 47 % (正确标记的数据点所占的百分比)</span><br></pre></td></tr></table></figure><p><img src="" alt=""></p><p>准确性只有47%的原因是数据集不是线性可分的，所以逻辑回归表现不佳，现在我们正式开始构建神经网络。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_decision_boundary</span><span class="params">(model, X, y)</span>:</span></span><br><span class="line">    <span class="comment"># Set min and max values and give it some padding</span></span><br><span class="line">    x_min, x_max = X[<span class="number">0</span>, :].min() - <span class="number">1</span>, X[<span class="number">0</span>, :].max() + <span class="number">1</span></span><br><span class="line">    y_min, y_max = X[<span class="number">1</span>, :].min() - <span class="number">1</span>, X[<span class="number">1</span>, :].max() + <span class="number">1</span></span><br><span class="line">    h = <span class="number">0.01</span></span><br><span class="line">    <span class="comment"># Generate a grid of points with distance h between them</span></span><br><span class="line">    xx, yy = np.meshgrid(np.arange(x_min, x_max, h), np.arange(y_min, y_max, h))</span><br><span class="line">    <span class="comment"># Predict the function value for the whole grid</span></span><br><span class="line">    Z = model(np.c_[xx.ravel(), yy.ravel()])</span><br><span class="line">    Z = Z.reshape(xx.shape)</span><br><span class="line">    <span class="comment"># Plot the contour and training examples</span></span><br><span class="line">    plt.contourf(xx, yy, Z, cmap=plt.cm.Spectral)</span><br><span class="line">    plt.ylabel(<span class="string">'x2'</span>)</span><br><span class="line">    plt.xlabel(<span class="string">'x1'</span>)</span><br><span class="line">    plt.scatter(X[<span class="number">0</span>, :], X[<span class="number">1</span>, :], c=y, cmap=plt.cm.Spectral)</span><br></pre></td></tr></table></figure><hr><h2 id="搭建神经网络"><a href="#搭建神经网络" class="headerlink" title="搭建神经网络"></a>搭建神经网络</h2><p>我们要搭建的神经网络模型如下图：</p><p><img src="https://raw.githubusercontent.com/pxlsdz/MarkDown-images/master/2020-1-17/%E6%A8%A1%E5%9E%8B.png" alt=""></p><p>公式模型<br>$$<br>z^{[1] (i)} =  W^{[1]} x^{(i)} + b^{[1] (i)}\tag{1}<br>$$</p><p>$$<br>a^{[1] (i)} = \tanh(z^{[1] (i)})\tag{2}<br>$$</p><p>$$<br>z^{[2] (i)} = W^{[2]} a^{[1] (i)} + b^{[2] (i)}\tag{3}<br>$$</p><p>$$<br>\hat{y}^{(i)} = a^{[2] (i)} = \sigma(z^{ [2] (i)})\tag{4}<br>$$</p><p>$$<br>y^{(i)}_{prediction} = \begin{cases} 1 &amp; \mbox{if } a^{<a href="i">2</a>} &gt; 0.5 \ 0 &amp; \mbox{otherwise } \end{cases}\tag{5}<br>$$</p><p>给出所有示例的预测结果，可以按如下方式计算成本J：<br>$$<br>J = - \frac{1}{m} \sum\limits_{i = 0}^{m} \large\left(\small y^{(i)}\log\left(a^{[2] (i)}\right) + (1-y^{(i)})\log\left(1- a^{[2] (i)}\right)  \large  \right) \small \tag{6}<br>$$<br>构建神经网络的一般方法是：</p><ol><li>定义神经网络结构（输入单元的数量，隐藏单元的数量等）。</li><li>初始化模型的参数</li><li>循环：<ul><li>实施前向传播</li><li>计算损失</li><li>实现向后传播</li><li>更新参数（梯度下降）</li></ul></li></ol><p>我们要它们合并到一个nn_model() 函数中，当我们构建好了nn_model（）并学习了正确的参数，我们就可以预测新的数据。</p><h3 id="定义神经网络结构"><a href="#定义神经网络结构" class="headerlink" title="定义神经网络结构"></a>定义神经网络结构</h3><p>在构建之前，我们要先把神经网络的结构给定义好：</p><ul><li>n_x: 输入层的数量</li><li>n_h: 隐藏层的数量（这里设置为4）</li><li>n_y: 输出层的数量</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">layer_sizes</span><span class="params">(X , Y)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    参数：</span></span><br><span class="line"><span class="string">     X - 输入数据集,维度为（输入的数量，训练/测试的数量）</span></span><br><span class="line"><span class="string">     Y - 标签，维度为（输出的数量，训练/测试数量）</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    返回：</span></span><br><span class="line"><span class="string">     n_x - 输入层的数量</span></span><br><span class="line"><span class="string">     n_h - 隐藏层的数量</span></span><br><span class="line"><span class="string">     n_y - 输出层的数量</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    n_x = X.shape[<span class="number">0</span>] <span class="comment">#输入层</span></span><br><span class="line">    n_h = <span class="number">4</span> <span class="comment">#，隐藏层，硬编码为4</span></span><br><span class="line">    n_y = Y.shape[<span class="number">0</span>] <span class="comment">#输出层</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (n_x,n_h,n_y)</span><br></pre></td></tr></table></figure><p>测试一下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#测试layer_sizes</span></span><br><span class="line">print(<span class="string">"=========================测试layer_sizes========================="</span>)</span><br><span class="line">X_asses , Y_asses = layer_sizes_test_case()</span><br><span class="line">(n_x,n_h,n_y) =  layer_sizes(X_asses,Y_asses)</span><br><span class="line">print(<span class="string">"输入层的节点数量为: n_x = "</span> + str(n_x))</span><br><span class="line">print(<span class="string">"隐藏层的节点数量为: n_h = "</span> + str(n_h))</span><br><span class="line">print(<span class="string">"输出层的节点数量为: n_y = "</span> + str(n_y))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">layer_sizes_test_case</span><span class="params">()</span>:</span></span><br><span class="line">    np.random.seed(<span class="number">1</span>)</span><br><span class="line">    X_assess = np.random.randn(<span class="number">5</span>, <span class="number">3</span>)</span><br><span class="line">    Y_assess = np.random.randn(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">return</span> X_assess, Y_assess</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;测试layer_sizes&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">输入层的节点数量为: n_x &#x3D; 5</span><br><span class="line">隐藏层的节点数量为: n_h &#x3D; 4</span><br><span class="line">输出层的节点数量为: n_y &#x3D; 2</span><br></pre></td></tr></table></figure><h3 id="初始化模型的参数"><a href="#初始化模型的参数" class="headerlink" title="初始化模型的参数"></a>初始化模型的参数</h3><p>在这里，我们要实现函数initialize_parameters()。我们要确保我们的参数大小合适，如果需要的话，请参考上面的神经网络图。<br>我们将会用随机值初始化权重矩阵。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.random.randn(a，b)* <span class="number">0.01</span>来随机初始化一个维度为(a，b)的矩阵。</span><br></pre></td></tr></table></figure><p>将偏向量初始化为零。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.zeros((a，b))用零初始化矩阵（a，b）。</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">initialize_parameters</span><span class="params">( n_x , n_h ,n_y)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    参数：</span></span><br><span class="line"><span class="string">        n_x - 输入层节点的数量</span></span><br><span class="line"><span class="string">        n_h - 隐藏层节点的数量</span></span><br><span class="line"><span class="string">        n_y - 输出层节点的数量</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    返回：</span></span><br><span class="line"><span class="string">        parameters - 包含参数的字典：</span></span><br><span class="line"><span class="string">            W1 - 权重矩阵,维度为（n_h，n_x）</span></span><br><span class="line"><span class="string">            b1 - 偏向量，维度为（n_h，1）</span></span><br><span class="line"><span class="string">            W2 - 权重矩阵，维度为（n_y，n_h）</span></span><br><span class="line"><span class="string">            b2 - 偏向量，维度为（n_y，1）</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    np.random.seed(<span class="number">2</span>) <span class="comment">#指定一个随机种子，以便你的输出与我们的一样。</span></span><br><span class="line">    W1 = np.random.randn(n_h,n_x) * <span class="number">0.01</span></span><br><span class="line">    b1 = np.zeros(shape=(n_h, <span class="number">1</span>))</span><br><span class="line">    W2 = np.random.randn(n_y,n_h) * <span class="number">0.01</span></span><br><span class="line">    b2 = np.zeros(shape=(n_y, <span class="number">1</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#使用断言确保我的数据格式是正确的</span></span><br><span class="line">    <span class="keyword">assert</span>(W1.shape == ( n_h , n_x ))</span><br><span class="line">    <span class="keyword">assert</span>(b1.shape == ( n_h , <span class="number">1</span> ))</span><br><span class="line">    <span class="keyword">assert</span>(W2.shape == ( n_y , n_h ))</span><br><span class="line">    <span class="keyword">assert</span>(b2.shape == ( n_y , <span class="number">1</span> ))</span><br><span class="line">    </span><br><span class="line">    parameters = &#123;<span class="string">"W1"</span> : W1,</span><br><span class="line">              <span class="string">"b1"</span> : b1,</span><br><span class="line">              <span class="string">"W2"</span> : W2,</span><br><span class="line">              <span class="string">"b2"</span> : b2 &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> parameters</span><br></pre></td></tr></table></figure><p>测试一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#测试initialize_parameters</span></span><br><span class="line">print(<span class="string">"=========================测试initialize_parameters========================="</span>)    </span><br><span class="line">n_x , n_h , n_y = initialize_parameters_test_case()</span><br><span class="line">parameters = initialize_parameters(n_x , n_h , n_y)</span><br><span class="line">print(<span class="string">"W1 = "</span> + str(parameters[<span class="string">"W1"</span>]))</span><br><span class="line">print(<span class="string">"b1 = "</span> + str(parameters[<span class="string">"b1"</span>]))</span><br><span class="line">print(<span class="string">"W2 = "</span> + str(parameters[<span class="string">"W2"</span>]))</span><br><span class="line">print(<span class="string">"b2 = "</span> + str(parameters[<span class="string">"b2"</span>]))</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;测试initialize_parameters&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">W1 &#x3D; [[-0.00416758 -0.00056267]</span><br><span class="line"> [-0.02136196  0.01640271]</span><br><span class="line"> [-0.01793436 -0.00841747]</span><br><span class="line"> [ 0.00502881 -0.01245288]]</span><br><span class="line">b1 &#x3D; [[0.]</span><br><span class="line"> [0.]</span><br><span class="line"> [0.]</span><br><span class="line"> [0.]]</span><br><span class="line">W2 &#x3D; [[-0.01057952 -0.00909008  0.00551454  0.02292208]]</span><br><span class="line">b2 &#x3D; [[0.]]</span><br></pre></td></tr></table></figure><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><h4 id="前向传播"><a href="#前向传播" class="headerlink" title="前向传播"></a>前向传播</h4><p>我们现在要实现前向传播函数forward_propagation()。我们可以使用sigmoid()函数，也可以使用np.tanh()函数。<br>步骤如下：</p><ul><li><p>使用字典类型的parameters（它是initialize_parameters() 的输出）检索每个参数。</p></li><li><p>实现向前传播, 计算 $Z^{[1]}, A^{[1]}, Z^{[2]}$和 $A^{[2]}$（ 训练集里面所有例子的预测向量）。</p></li><li><p>反向传播所需的值存储在“cache”中，cache将作为反向传播函数的输入。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">forward_propagation</span><span class="params">( X , parameters )</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    参数：</span></span><br><span class="line"><span class="string">         X - 维度为（n_x，m）的输入数据。</span></span><br><span class="line"><span class="string">         parameters - 初始化函数（initialize_parameters）的输出</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    返回：</span></span><br><span class="line"><span class="string">         A2 - 使用sigmoid()函数计算的第二次激活后的数值</span></span><br><span class="line"><span class="string">         cache - 包含“Z1”，“A1”，“Z2”和“A2”的字典类型变量</span></span><br><span class="line"><span class="string">     """</span></span><br><span class="line">    W1 = parameters[<span class="string">"W1"</span>]</span><br><span class="line">    b1 = parameters[<span class="string">"b1"</span>]</span><br><span class="line">    W2 = parameters[<span class="string">"W2"</span>]</span><br><span class="line">    b2 = parameters[<span class="string">"b2"</span>]</span><br><span class="line">    <span class="comment">#前向传播计算A2</span></span><br><span class="line">    Z1 = np.dot(W1 , X) + b1</span><br><span class="line">    A1 = np.tanh(Z1)</span><br><span class="line">    Z2 = np.dot(W2 , A1) + b2</span><br><span class="line">    A2 = sigmoid(Z2)</span><br><span class="line">    <span class="comment">#使用断言确保我的数据格式是正确的</span></span><br><span class="line">    <span class="keyword">assert</span>(A2.shape == (<span class="number">1</span>,X.shape[<span class="number">1</span>]))</span><br><span class="line">    cache = &#123;<span class="string">"Z1"</span>: Z1,</span><br><span class="line">             <span class="string">"A1"</span>: A1,</span><br><span class="line">             <span class="string">"Z2"</span>: Z2,</span><br><span class="line">             <span class="string">"A2"</span>: A2&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (A2, cache)</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#测试forward_propagation</span></span><br><span class="line">print(<span class="string">"=========================测试forward_propagation========================="</span>) </span><br><span class="line">X_assess, parameters = forward_propagation_test_case()</span><br><span class="line">A2, cache = forward_propagation(X_assess, parameters)</span><br><span class="line">print(np.mean(cache[<span class="string">"Z1"</span>]), np.mean(cache[<span class="string">"A1"</span>]), np.mean(cache[<span class="string">"Z2"</span>]), np.mean(cache[<span class="string">"A2"</span>]))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;测试forward_propagation&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">-0.0004997557777419902 -0.000496963353231779 0.00043818745095914653 0.500109546852431</span><br></pre></td></tr></table></figure><p>现在我们已经计算了$A^{[2]},a^{<a href="i">2</a>}$包含了训练集里每个数值，现在我们就可以构建成本函数了。</p><h4 id="计算损失"><a href="#计算损失" class="headerlink" title="计算损失"></a>计算损失</h4><p>计算成本的公式如下：<br>$$<br>J = - \frac{1}{m} \sum\limits_{i = 0}^{m} \large{(} \small y^{(i)}\log\left(a^{[2] (i)}\right) + (1-y^{(i)})\log\left(1- a^{[2] (i)}\right) \large{)} \small\tag{7}<br>$$<br>有很多的方法都可以计算交叉熵损失，比如下面的这个公式，我们在python中可以这么实现</p><p>$-\sum \limits_ {i = 0} ^ {m} y ^ {（i）} \ log（a ^ {[2]（i）}）$：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">logprobs = np.multiply（np.log（A2），Y）</span><br><span class="line">cost =-np.sum（logprobs）＃无需使用<span class="keyword">for</span>循环！</span><br></pre></td></tr></table></figure><p>可以使用“ np.multiply（）”然后使用“ np.sum（）”，也可以直接使用“ np.dot（）”）。</p><p>现在我们正式开始构建计算成本的函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compute_cost</span><span class="params">(A2,Y,parameters)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    计算方程（6）中给出的交叉熵成本，</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    参数：</span></span><br><span class="line"><span class="string">         A2 - 使用sigmoid()函数计算的第二次激活后的数值</span></span><br><span class="line"><span class="string">         Y - "True"标签向量,维度为（1，数量）</span></span><br><span class="line"><span class="string">         parameters - 一个包含W1，B1，W2和B2的字典类型的变量</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    返回：</span></span><br><span class="line"><span class="string">         成本 - 交叉熵成本给出方程（7）</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    </span><br><span class="line">    m = Y.shape[<span class="number">1</span>]</span><br><span class="line">    W1 = parameters[<span class="string">"W1"</span>]</span><br><span class="line">    W2 = parameters[<span class="string">"W2"</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#计算成本</span></span><br><span class="line">    logprobs  = np.multiply(np.log(A2), Y) + np.multiply((<span class="number">1</span> - Y), np.log(<span class="number">1</span> - A2))</span><br><span class="line">    cost = - np.sum(logprobs) / m</span><br><span class="line">    cost = float(np.squeeze(cost))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">assert</span>(isinstance(cost,float))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> cost</span><br></pre></td></tr></table></figure><p>测试一下我们的成本函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#测试compute_cost</span></span><br><span class="line">print(<span class="string">"=========================测试compute_cost========================="</span>) </span><br><span class="line">A2 , Y_assess , parameters = compute_cost_test_case()</span><br><span class="line">print(<span class="string">"cost = "</span> + str(compute_cost(A2,Y_assess,parameters)))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">=========================测试compute_cost=========================</span><br><span class="line">cost = <span class="number">0.6929198937761266</span></span><br></pre></td></tr></table></figure><p>附：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compute_cost_test_case</span><span class="params">()</span>:</span></span><br><span class="line">    np.random.seed(<span class="number">1</span>)</span><br><span class="line">    Y_assess = np.random.randn(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">    parameters = &#123;<span class="string">'W1'</span>: np.array([[<span class="number">-0.00416758</span>, <span class="number">-0.00056267</span>],</span><br><span class="line">        [<span class="number">-0.02136196</span>,  <span class="number">0.01640271</span>],</span><br><span class="line">        [<span class="number">-0.01793436</span>, <span class="number">-0.00841747</span>],</span><br><span class="line">        [ <span class="number">0.00502881</span>, <span class="number">-0.01245288</span>]]),</span><br><span class="line">     <span class="string">'W2'</span>: np.array([[<span class="number">-0.01057952</span>, <span class="number">-0.00909008</span>,  <span class="number">0.00551454</span>,  <span class="number">0.02292208</span>]]),</span><br><span class="line">     <span class="string">'b1'</span>: np.array([[ <span class="number">0.</span>],</span><br><span class="line">        [ <span class="number">0.</span>],</span><br><span class="line">        [ <span class="number">0.</span>],</span><br><span class="line">        [ <span class="number">0.</span>]]),</span><br><span class="line">     <span class="string">'b2'</span>: np.array([[ <span class="number">0.</span>]])&#125;</span><br><span class="line"></span><br><span class="line">    a2 = (np.array([[ <span class="number">0.5002307</span> ,  <span class="number">0.49985831</span>,  <span class="number">0.50023963</span>]]))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> a2, Y_assess, parameters</span><br></pre></td></tr></table></figure><p>使用正向传播期间计算的cache，现在可以利用它实现反向传播。</p><p>现在我们要开始实现函数backward_propagation（）。</p><h4 id="向后传播"><a href="#向后传播" class="headerlink" title="向后传播"></a>向后传播</h4><p>  说明：反向传播通常是深度学习中最难（数学意义）部分，为了帮助你，这里有反向传播讲座的幻灯片， 由于我们正在构建向量化实现，因此我们将需要使用这下面的六个方程：</p><p><img src="https://raw.githubusercontent.com/pxlsdz/MarkDown-images/master/2020-1-17/grad_summary.png" alt=""></p><p>-要计算dZ1，您需要计算$g^{[1]’}(Z^{[1]})$。 由于$g ^ {[1]}(..)$是tanh激活函数，因此如果$a =g^{[1]}(z)$，则$g^{[1]’}（z）= 1- a ^ 2$。 所以你可以计算$g ^{ [[1]’ }(Z ^{[1]})$使用<code>（1- np.power（A1，2））</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backward_propagation</span><span class="params">(parameters,cache,X,Y)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    使用上述说明搭建反向传播函数。</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    参数：</span></span><br><span class="line"><span class="string">     parameters - 包含我们的参数的一个字典类型的变量。</span></span><br><span class="line"><span class="string">     cache - 包含“Z1”，“A1”，“Z2”和“A2”的字典类型的变量。</span></span><br><span class="line"><span class="string">     X - 输入数据，维度为（2，数量）</span></span><br><span class="line"><span class="string">     Y - “True”标签，维度为（1，数量）</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    返回：</span></span><br><span class="line"><span class="string">     grads - 包含W和b的导数一个字典类型的变量。</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    m = X.shape[<span class="number">1</span>]</span><br><span class="line">    </span><br><span class="line">    W1 = parameters[<span class="string">"W1"</span>]</span><br><span class="line">    W2 = parameters[<span class="string">"W2"</span>]</span><br><span class="line">    </span><br><span class="line">    A1 = cache[<span class="string">"A1"</span>]</span><br><span class="line">    A2 = cache[<span class="string">"A2"</span>]</span><br><span class="line">    </span><br><span class="line">    dZ2= A2 - Y</span><br><span class="line">    dW2 = (<span class="number">1</span> / m) * np.dot(dZ2, A1.T)</span><br><span class="line">    db2 = (<span class="number">1</span> / m) * np.sum(dZ2, axis=<span class="number">1</span>, keepdims=<span class="literal">True</span>)</span><br><span class="line">    dZ1 = np.multiply(np.dot(W2.T, dZ2), <span class="number">1</span> - np.power(A1, <span class="number">2</span>))</span><br><span class="line">    dW1 = (<span class="number">1</span> / m) * np.dot(dZ1, X.T)</span><br><span class="line">    db1 = (<span class="number">1</span> / m) * np.sum(dZ1, axis=<span class="number">1</span>, keepdims=<span class="literal">True</span>)</span><br><span class="line">    grads = &#123;<span class="string">"dW1"</span>: dW1,</span><br><span class="line">             <span class="string">"db1"</span>: db1,</span><br><span class="line">             <span class="string">"dW2"</span>: dW2,</span><br><span class="line">             <span class="string">"db2"</span>: db2 &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> grads</span><br></pre></td></tr></table></figure><p>测试一下反向传播函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#测试backward_propagation</span></span><br><span class="line">print(<span class="string">"=========================测试backward_propagation========================="</span>)</span><br><span class="line">parameters, cache, X_assess, Y_assess = backward_propagation_test_case()</span><br><span class="line"></span><br><span class="line">grads = backward_propagation(parameters, cache, X_assess, Y_assess)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"dW1 = "</span>+ str(grads[<span class="string">"dW1"</span>]))</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"db1 = "</span>+ str(grads[<span class="string">"db1"</span>]))</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"dW2 = "</span>+ str(grads[<span class="string">"dW2"</span>]))</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"db2 = "</span>+ str(grads[<span class="string">"db2"</span>]))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;测试backward_propagation&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">dW1 &#x3D; [[ 0.01018708 -0.00708701]</span><br><span class="line"> [ 0.00873447 -0.0060768 ]</span><br><span class="line"> [-0.00530847  0.00369379]</span><br><span class="line"> [-0.02206365  0.01535126]]</span><br><span class="line">db1 &#x3D; [[-0.00069728]</span><br><span class="line"> [-0.00060606]</span><br><span class="line"> [ 0.000364  ]</span><br><span class="line"> [ 0.00151207]]</span><br><span class="line">dW2 &#x3D; [[ 0.00363613  0.03153604  0.01162914 -0.01318316]]</span><br><span class="line">db2 &#x3D; [[0.06589489]]</span><br></pre></td></tr></table></figure><p>反向传播完成了，我们开始对参数进行更新</p><h4 id="更新参数"><a href="#更新参数" class="headerlink" title="更新参数"></a>更新参数</h4><p>我们需要使用(dW1, db1, dW2, db2)来更新(W1, b1, W2, b2)。<br><strong>问题</strong>：实施更新规则。 使用梯度下降。 您必须使用（dW1，db1，dW2，db2）进行更新（W1，b1，W2，b2）。</p><p><strong>一般梯度下降规则</strong>：$\theta =\theta-\alpha\frac{\partial J} {\partial\theta}$其中$\alpha$是学习率，而$\theta$代表一个参数。</p><p><strong>插图</strong>：具有良好的学习速率（收敛）和较差的学习速率（发散）的梯度下降算法。 图片由亚当·哈雷（Adam Harley）提供。</p><p><img src="https://raw.githubusercontent.com/pxlsdz/MarkDown-images/master/2020-1-17/sgd.gif" alt="good"></p><p><img src="https://raw.githubusercontent.com/pxlsdz/MarkDown-images/master/2020-1-17/sgd_bad.gif" alt=""></p><p>上面两个图分别代表了具有良好学习速率（收敛）和不良学习速率（发散）的梯度下降算法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update_parameters</span><span class="params">(parameters,grads,learning_rate=<span class="number">1.2</span>)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    使用上面给出的梯度下降更新规则更新参数</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    参数：</span></span><br><span class="line"><span class="string">     parameters - 包含参数的字典类型的变量。</span></span><br><span class="line"><span class="string">     grads - 包含导数值的字典类型的变量。</span></span><br><span class="line"><span class="string">     learning_rate - 学习速率</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    返回：</span></span><br><span class="line"><span class="string">     parameters - 包含更新参数的字典类型的变量。</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    W1,W2 = parameters[<span class="string">"W1"</span>],parameters[<span class="string">"W2"</span>]</span><br><span class="line">    b1,b2 = parameters[<span class="string">"b1"</span>],parameters[<span class="string">"b2"</span>]</span><br><span class="line">    </span><br><span class="line">    dW1,dW2 = grads[<span class="string">"dW1"</span>],grads[<span class="string">"dW2"</span>]</span><br><span class="line">    db1,db2 = grads[<span class="string">"db1"</span>],grads[<span class="string">"db2"</span>]</span><br><span class="line">    </span><br><span class="line">    W1 = W1 - learning_rate * dW1</span><br><span class="line">    b1 = b1 - learning_rate * db1</span><br><span class="line">    W2 = W2 - learning_rate * dW2</span><br><span class="line">    b2 = b2 - learning_rate * db2</span><br><span class="line">    </span><br><span class="line">    parameters = &#123;<span class="string">"W1"</span>: W1,</span><br><span class="line">                  <span class="string">"b1"</span>: b1,</span><br><span class="line">                  <span class="string">"W2"</span>: W2,</span><br><span class="line">                  <span class="string">"b2"</span>: b2&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> parameters</span><br></pre></td></tr></table></figure><p>测试:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#测试update_parameters</span></span><br><span class="line">print(<span class="string">"=========================测试update_parameters========================="</span>)</span><br><span class="line">parameters, grads = update_parameters_test_case()</span><br><span class="line">parameters = update_parameters(parameters, grads)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"W1 = "</span> + str(parameters[<span class="string">"W1"</span>]))</span><br><span class="line">print(<span class="string">"b1 = "</span> + str(parameters[<span class="string">"b1"</span>]))</span><br><span class="line">print(<span class="string">"W2 = "</span> + str(parameters[<span class="string">"W2"</span>]))</span><br><span class="line">print(<span class="string">"b2 = "</span> + str(parameters[<span class="string">"b2"</span>]))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;测试update_parameters&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">W1 &#x3D; [[-0.00643025  0.01936718]</span><br><span class="line"> [-0.02410458  0.03978052]</span><br><span class="line"> [-0.01653973 -0.02096177]</span><br><span class="line"> [ 0.01046864 -0.05990141]]</span><br><span class="line">b1 &#x3D; [[-1.02420756e-06]</span><br><span class="line"> [ 1.27373948e-05]</span><br><span class="line"> [ 8.32996807e-07]</span><br><span class="line"> [-3.20136836e-06]]</span><br><span class="line">W2 &#x3D; [[-0.01041081 -0.04463285  0.01758031  0.04747113]]</span><br><span class="line">b2 &#x3D; [[0.00010457]]</span><br></pre></td></tr></table></figure><h3 id="整合"><a href="#整合" class="headerlink" title="整合"></a>整合</h3><p>我们现在把上面的东西整合到nn_model()中，神经网络模型必须以正确的顺序使用先前的功能。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nn_model</span><span class="params">(X,Y,n_h,num_iterations,print_cost=False)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    参数：</span></span><br><span class="line"><span class="string">        X - 数据集,维度为（2，示例数）</span></span><br><span class="line"><span class="string">        Y - 标签，维度为（1，示例数）</span></span><br><span class="line"><span class="string">        n_h - 隐藏层的数量</span></span><br><span class="line"><span class="string">        num_iterations - 梯度下降循环中的迭代次数</span></span><br><span class="line"><span class="string">        print_cost - 如果为True，则每1000次迭代打印一次成本数值</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    返回：</span></span><br><span class="line"><span class="string">        parameters - 模型学习的参数，它们可以用来进行预测。</span></span><br><span class="line"><span class="string">     """</span></span><br><span class="line">     </span><br><span class="line">    np.random.seed(<span class="number">3</span>) <span class="comment">#指定随机种子</span></span><br><span class="line">    n_x = layer_sizes(X, Y)[<span class="number">0</span>]</span><br><span class="line">    n_y = layer_sizes(X, Y)[<span class="number">2</span>]</span><br><span class="line">    </span><br><span class="line">    parameters = initialize_parameters(n_x,n_h,n_y)</span><br><span class="line">    W1 = parameters[<span class="string">"W1"</span>]</span><br><span class="line">    b1 = parameters[<span class="string">"b1"</span>]</span><br><span class="line">    W2 = parameters[<span class="string">"W2"</span>]</span><br><span class="line">    b2 = parameters[<span class="string">"b2"</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(num_iterations):</span><br><span class="line">        A2 , cache = forward_propagation(X,parameters)</span><br><span class="line">        cost = compute_cost(A2,Y,parameters)</span><br><span class="line">        grads = backward_propagation(parameters,cache,X,Y)</span><br><span class="line">        parameters = update_parameters(parameters,grads,learning_rate = <span class="number">0.5</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> print_cost:</span><br><span class="line">            <span class="keyword">if</span> i%<span class="number">1000</span> == <span class="number">0</span>:</span><br><span class="line">                print(<span class="string">"第 "</span>,i,<span class="string">" 次循环，成本为："</span>+str(cost))</span><br><span class="line">    <span class="keyword">return</span> parameters</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#测试nn_model</span></span><br><span class="line">print(<span class="string">"=========================测试nn_model========================="</span>)</span><br><span class="line">X_assess, Y_assess = nn_model_test_case()</span><br><span class="line"></span><br><span class="line">parameters = nn_model(X_assess, Y_assess, <span class="number">4</span>, num_iterations=<span class="number">10000</span>, print_cost=<span class="literal">False</span>)</span><br><span class="line">print(<span class="string">"W1 = "</span> + str(parameters[<span class="string">"W1"</span>]))</span><br><span class="line">print(<span class="string">"b1 = "</span> + str(parameters[<span class="string">"b1"</span>]))</span><br><span class="line">print(<span class="string">"W2 = "</span> + str(parameters[<span class="string">"W2"</span>]))</span><br><span class="line">print(<span class="string">"b2 = "</span> + str(parameters[<span class="string">"b2"</span>]))</span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">=========================测试nn_model=========================</span><br><span class="line">W1 = [[<span class="number">-4.18494482</span>  <span class="number">5.33220319</span>]</span><br><span class="line"> [<span class="number">-7.52989354</span>  <span class="number">1.24306197</span>]</span><br><span class="line"> [<span class="number">-4.19295428</span>  <span class="number">5.32631786</span>]</span><br><span class="line"> [ <span class="number">7.52983748</span> <span class="number">-1.24309404</span>]]</span><br><span class="line">b1 = [[ <span class="number">2.32926815</span>]</span><br><span class="line"> [ <span class="number">3.7945905</span> ]</span><br><span class="line"> [ <span class="number">2.33002544</span>]</span><br><span class="line"> [<span class="number">-3.79468791</span>]]</span><br><span class="line">W2 = [[<span class="number">-6033.83672179</span> <span class="number">-6008.12981272</span> <span class="number">-6033.10095329</span>  <span class="number">6008.06636901</span>]]</span><br><span class="line">b2 = [[<span class="number">-52.66607704</span>]]</span><br></pre></td></tr></table></figure><p>参数更新完了,我们就可以来进行预测了。</p><h3 id="预测"><a href="#预测" class="headerlink" title="预测"></a>预测</h3><p><strong>问题</strong>：使用您的模型通过构建prepare（）进行预测。使用正向传播来预测结果。</p><p><strong>提醒</strong><br>$$<br>y_{prediction} = \mathbb 1 \textfalse = \begin{cases}<br>      1 &amp; \text{if}\ activation &gt; 0.5 \<br>      0 &amp; \text{otherwise}<br>    \end{cases}<br>$$</p><p>例如，如果您想基于阈值将矩阵X的条目设置为0和1，则可以执行以下操作：<code>X_new =（X&gt; threshold）</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(parameters,X)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    使用学习的参数，为X中的每个示例预测一个类</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    参数：</span></span><br><span class="line"><span class="string">parameters - 包含参数的字典类型的变量。</span></span><br><span class="line"><span class="string">    X - 输入数据（n_x，m）</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    返回</span></span><br><span class="line"><span class="string">predictions - 我们模型预测的向量（红色：0 /蓝色：1）</span></span><br><span class="line"><span class="string">     </span></span><br><span class="line"><span class="string">     """</span></span><br><span class="line">    A2 , cache = forward_propagation(X,parameters)</span><br><span class="line">    predictions = np.round(A2)<span class="comment">#四舍五入</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> predictions</span><br></pre></td></tr></table></figure><p>test:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#测试predict</span></span><br><span class="line">print(<span class="string">"=========================测试predict========================="</span>)</span><br><span class="line"></span><br><span class="line">parameters, X_assess = predict_test_case()</span><br><span class="line"></span><br><span class="line">predictions = predict(parameters, X_assess)</span><br><span class="line">print(<span class="string">"预测的平均值 = "</span> + str(np.mean(predictions)))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;测试predict&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">预测的平均值 &#x3D; 0.6666666666666666</span><br></pre></td></tr></table></figure><hr><h2 id="正式运行"><a href="#正式运行" class="headerlink" title="正式运行"></a>正式运行</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">parameters = nn_model(X, Y, n_h = <span class="number">4</span>, num_iterations=<span class="number">10000</span>, print_cost=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#绘制边界</span></span><br><span class="line">plot_decision_boundary(<span class="keyword">lambda</span> x: predict(parameters, x.T), np.squeeze(X), np.squeeze(Y))</span><br><span class="line">plt.title(<span class="string">"Decision Boundary for hidden layer size "</span> + str(<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">predictions = predict(parameters, X)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">'准确率: %d'</span> % float((np.dot(Y, predictions.T) + np.dot(<span class="number">1</span> - Y, <span class="number">1</span> - predictions.T)) / float(Y.size) * <span class="number">100</span>) + <span class="string">'%'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">第  0  次循环，成本为：0.6930480201239823</span><br><span class="line">第  1000  次循环，成本为：0.3098018601352803</span><br><span class="line">第  2000  次循环，成本为：0.2924326333792646</span><br><span class="line">第  3000  次循环，成本为：0.2833492852647412</span><br><span class="line">第  4000  次循环，成本为：0.27678077562979253</span><br><span class="line">第  5000  次循环，成本为：0.26347155088593144</span><br><span class="line">第  6000  次循环，成本为：0.24204413129940763</span><br><span class="line">第  7000  次循环，成本为：0.23552486626608762</span><br><span class="line">第  8000  次循环，成本为：0.23140964509854278</span><br><span class="line">第  9000  次循环，成本为：0.22846408048352365</span><br><span class="line">准确率: 90%</span><br></pre></td></tr></table></figure><p><img src="https://raw.github.com/pxlsdz/MarkDown-images/master/2020-1-17/%E8%8A%B13.png" alt=""></p><hr><h2 id="更改隐藏层节点数量"><a href="#更改隐藏层节点数量" class="headerlink" title="更改隐藏层节点数量"></a>更改隐藏层节点数量</h2><p>我们上面的实验把隐藏层定为4个节点，现在我们更改隐藏层里面的节点数量，看一看节点数量是否会对结果造成影响。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">plt.figure(figsize=(<span class="number">16</span>, <span class="number">32</span>))</span><br><span class="line">hidden_layer_sizes = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">20</span>, <span class="number">50</span>] <span class="comment">#隐藏层数量</span></span><br><span class="line"><span class="keyword">for</span> i, n_h <span class="keyword">in</span> enumerate(hidden_layer_sizes):</span><br><span class="line">    plt.subplot(<span class="number">5</span>, <span class="number">2</span>, i + <span class="number">1</span>)</span><br><span class="line">    plt.title(<span class="string">'Hidden Layer of size %d'</span> % n_h)</span><br><span class="line">    parameters = nn_model(X, Y, n_h, num_iterations=<span class="number">5000</span>)</span><br><span class="line">    plot_decision_boundary(<span class="keyword">lambda</span> x: predict(parameters, x.T), np.squeeze(X),np.squeeze(Y))</span><br><span class="line">    predictions = predict(parameters, X)</span><br><span class="line">    accuracy = float((np.dot(Y, predictions.T) + np.dot(<span class="number">1</span> - Y, <span class="number">1</span> - predictions.T)) / float(Y.size) * <span class="number">100</span>)</span><br><span class="line">    <span class="keyword">print</span> (<span class="string">"隐藏层的节点数量： &#123;&#125;  ，准确率: &#123;&#125; %"</span>.format(n_h, accuracy))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">隐藏层的节点数量： 1  ，准确率: 67.25 %</span><br><span class="line">隐藏层的节点数量： 2  ，准确率: 66.5 %</span><br><span class="line">隐藏层的节点数量： 3  ，准确率: 89.25 %</span><br><span class="line">隐藏层的节点数量： 4  ，准确率: 90.0 %</span><br><span class="line">隐藏层的节点数量： 5  ，准确率: 89.75 %</span><br><span class="line">隐藏层的节点数量： 20  ，准确率: 90.0 %</span><br><span class="line">隐藏层的节点数量： 50  ，准确率: 89.75 %</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/pxlsdz/MarkDown-images/master/2020-1-17/%E5%9B%9B%E4%B8%AA.png" alt=""></p><p><img src="https://raw.githubusercontent.com/pxlsdz/MarkDown-images/master/2020-1-17/%E4%B8%89%E4%B8%AA.png" alt=""></p><p>较大的模型（具有更多隐藏单元）能够更好地适应训练集，直到最终的最大模型过度拟合数据。<br>最好的隐藏层大小似乎在n_h = 5附近。实际上，这里的值似乎很适合数据，而且不会引起过度拟合。<br>我们还将在后面学习有关正则化的知识，它允许我们使用非常大的模型（如n_h = 50），而不会出现太多过度拟合。</p><h2 id="可选-探索"><a href="#可选-探索" class="headerlink" title="[可选]探索"></a>[可选]探索</h2><ul><li>当改变sigmoid激活或ReLU激活的tanh激活时会发生什么？</li><li>改变learning_rate的数值会发生什么</li><li>如果我们改变数据集呢？</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数据集</span></span><br><span class="line">noisy_circles, noisy_moons, blobs, gaussian_quantiles, no_structure = load_extra_datasets()</span><br><span class="line"></span><br><span class="line">datasets = &#123;<span class="string">"noisy_circles"</span>: noisy_circles,</span><br><span class="line">            <span class="string">"noisy_moons"</span>: noisy_moons,</span><br><span class="line">            <span class="string">"blobs"</span>: blobs,</span><br><span class="line">            <span class="string">"gaussian_quantiles"</span>: gaussian_quantiles&#125;</span><br><span class="line"></span><br><span class="line">dataset = <span class="string">"noisy_moons"</span></span><br><span class="line"></span><br><span class="line">X, Y = datasets[dataset]</span><br><span class="line">X, Y = X.T, Y.reshape(<span class="number">1</span>, Y.shape[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> dataset == <span class="string">"blobs"</span>:</span><br><span class="line">    Y = Y % <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#plt.scatter(X[0, :], X[1, :], c=Y, s=40, cmap=plt.cm.Spectral)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#上一语句如出现问题请使用下面的语句：</span></span><br><span class="line">plt.scatter(X[<span class="number">0</span>, :], X[<span class="number">1</span>, :], c=np.squeeze(Y), s=<span class="number">40</span>, cmap=plt.cm.Spectral)</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/pxlsdz/MarkDown-images/master/2020-1-17/end.png" alt=""></p><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><h2 id="主代码"><a href="#主代码" class="headerlink" title="主代码"></a>主代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">本文博客地址：https://blog.csdn.net/u013733326/article/details/79702148</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">@author: Oscar</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> testCases <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sklearn</span><br><span class="line"><span class="keyword">import</span> sklearn.datasets</span><br><span class="line"><span class="keyword">import</span> sklearn.linear_model</span><br><span class="line"><span class="keyword">from</span> planar_utils <span class="keyword">import</span> plot_decision_boundary, sigmoid, load_planar_dataset, load_extra_datasets</span><br><span class="line"></span><br><span class="line"><span class="comment">#%matplotlib inline #如果你使用用的是Jupyter Notebook的话请取消注释。</span></span><br><span class="line"></span><br><span class="line">np.random.seed(<span class="number">1</span>) <span class="comment">#设置一个固定的随机种子，以保证接下来的步骤中我们的结果是一致的。</span></span><br><span class="line"></span><br><span class="line">X, Y = load_planar_dataset()</span><br><span class="line"><span class="comment">#plt.scatter(X[0, :], X[1, :], c=Y, s=40, cmap=plt.cm.Spectral) #绘制散点图</span></span><br><span class="line">shape_X = X.shape</span><br><span class="line">shape_Y = Y.shape</span><br><span class="line">m = Y.shape[<span class="number">1</span>]  <span class="comment"># 训练集里面的数量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> (<span class="string">"X的维度为: "</span> + str(shape_X))</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"Y的维度为: "</span> + str(shape_Y))</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"数据集里面的数据有："</span> + str(m) + <span class="string">" 个"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">layer_sizes</span><span class="params">(X , Y)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    参数：</span></span><br><span class="line"><span class="string">     X - 输入数据集,维度为（输入的数量，训练/测试的数量）</span></span><br><span class="line"><span class="string">     Y - 标签，维度为（输出的数量，训练/测试数量）</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    返回：</span></span><br><span class="line"><span class="string">     n_x - 输入层的数量</span></span><br><span class="line"><span class="string">     n_h - 隐藏层的数量</span></span><br><span class="line"><span class="string">     n_y - 输出层的数量</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    n_x = X.shape[<span class="number">0</span>] <span class="comment">#输入层</span></span><br><span class="line">    n_h = <span class="number">4</span> <span class="comment">#，隐藏层，硬编码为4</span></span><br><span class="line">    n_y = Y.shape[<span class="number">0</span>] <span class="comment">#输出层</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (n_x,n_h,n_y)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">initialize_parameters</span><span class="params">( n_x , n_h ,n_y)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    参数：</span></span><br><span class="line"><span class="string">        n_x - 输入节点的数量</span></span><br><span class="line"><span class="string">        n_h - 隐藏层节点的数量</span></span><br><span class="line"><span class="string">        n_y - 输出层节点的数量</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    返回：</span></span><br><span class="line"><span class="string">        parameters - 包含参数的字典：</span></span><br><span class="line"><span class="string">            W1 - 权重矩阵,维度为（n_h，n_x）</span></span><br><span class="line"><span class="string">            b1 - 偏向量，维度为（n_h，1）</span></span><br><span class="line"><span class="string">            W2 - 权重矩阵，维度为（n_y，n_h）</span></span><br><span class="line"><span class="string">            b2 - 偏向量，维度为（n_y，1）</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    np.random.seed(<span class="number">2</span>) <span class="comment">#指定一个随机种子，以便你的输出与我们的一样。</span></span><br><span class="line">    W1 = np.random.randn(n_h,n_x) * <span class="number">0.01</span></span><br><span class="line">    b1 = np.zeros(shape=(n_h, <span class="number">1</span>))</span><br><span class="line">    W2 = np.random.randn(n_y,n_h) * <span class="number">0.01</span></span><br><span class="line">    b2 = np.zeros(shape=(n_y, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">#使用断言确保我的数据格式是正确的</span></span><br><span class="line">    <span class="keyword">assert</span>(W1.shape == ( n_h , n_x ))</span><br><span class="line">    <span class="keyword">assert</span>(b1.shape == ( n_h , <span class="number">1</span> ))</span><br><span class="line">    <span class="keyword">assert</span>(W2.shape == ( n_y , n_h ))</span><br><span class="line">    <span class="keyword">assert</span>(b2.shape == ( n_y , <span class="number">1</span> ))</span><br><span class="line"></span><br><span class="line">    parameters = &#123;<span class="string">"W1"</span> : W1,</span><br><span class="line">                  <span class="string">"b1"</span> : b1,</span><br><span class="line">                  <span class="string">"W2"</span> : W2,</span><br><span class="line">                  <span class="string">"b2"</span> : b2 &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> parameters</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">forward_propagation</span><span class="params">( X , parameters )</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    参数：</span></span><br><span class="line"><span class="string">         X - 维度为（n_x，m）的输入数据。</span></span><br><span class="line"><span class="string">         parameters - 初始化函数（initialize_parameters）的输出</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    返回：</span></span><br><span class="line"><span class="string">         A2 - 使用sigmoid()函数计算的第二次激活后的数值</span></span><br><span class="line"><span class="string">         cache - 包含“Z1”，“A1”，“Z2”和“A2”的字典类型变量</span></span><br><span class="line"><span class="string">     """</span></span><br><span class="line">    W1 = parameters[<span class="string">"W1"</span>]</span><br><span class="line">    b1 = parameters[<span class="string">"b1"</span>]</span><br><span class="line">    W2 = parameters[<span class="string">"W2"</span>]</span><br><span class="line">    b2 = parameters[<span class="string">"b2"</span>]</span><br><span class="line">    <span class="comment">#前向传播计算A2</span></span><br><span class="line">    Z1 = np.dot(W1 , X) + b1</span><br><span class="line">    A1 = np.tanh(Z1)</span><br><span class="line">    Z2 = np.dot(W2 , A1) + b2</span><br><span class="line">    A2 = sigmoid(Z2)</span><br><span class="line">    <span class="comment">#使用断言确保我的数据格式是正确的</span></span><br><span class="line">    <span class="keyword">assert</span>(A2.shape == (<span class="number">1</span>,X.shape[<span class="number">1</span>]))</span><br><span class="line">    cache = &#123;<span class="string">"Z1"</span>: Z1,</span><br><span class="line">             <span class="string">"A1"</span>: A1,</span><br><span class="line">             <span class="string">"Z2"</span>: Z2,</span><br><span class="line">             <span class="string">"A2"</span>: A2&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (A2, cache)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compute_cost</span><span class="params">(A2,Y,parameters)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    计算方程（6）中给出的交叉熵成本，</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    参数：</span></span><br><span class="line"><span class="string">         A2 - 使用sigmoid()函数计算的第二次激活后的数值</span></span><br><span class="line"><span class="string">         Y - "True"标签向量,维度为（1，数量）</span></span><br><span class="line"><span class="string">         parameters - 一个包含W1，B1，W2和B2的字典类型的变量</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    返回：</span></span><br><span class="line"><span class="string">         成本 - 交叉熵成本给出方程（13）</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    m = Y.shape[<span class="number">1</span>]</span><br><span class="line">    W1 = parameters[<span class="string">"W1"</span>]</span><br><span class="line">    W2 = parameters[<span class="string">"W2"</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment">#计算成本</span></span><br><span class="line">    logprobs = logprobs = np.multiply(np.log(A2), Y) + np.multiply((<span class="number">1</span> - Y), np.log(<span class="number">1</span> - A2))</span><br><span class="line">    cost = - np.sum(logprobs) / m</span><br><span class="line">    cost = float(np.squeeze(cost))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">assert</span>(isinstance(cost,float))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cost</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backward_propagation</span><span class="params">(parameters,cache,X,Y)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    使用上述说明搭建反向传播函数。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    参数：</span></span><br><span class="line"><span class="string">     parameters - 包含我们的参数的一个字典类型的变量。</span></span><br><span class="line"><span class="string">     cache - 包含“Z1”，“A1”，“Z2”和“A2”的字典类型的变量。</span></span><br><span class="line"><span class="string">     X - 输入数据，维度为（2，数量）</span></span><br><span class="line"><span class="string">     Y - “True”标签，维度为（1，数量）</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    返回：</span></span><br><span class="line"><span class="string">     grads - 包含W和b的导数一个字典类型的变量。</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    m = X.shape[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    W1 = parameters[<span class="string">"W1"</span>]</span><br><span class="line">    W2 = parameters[<span class="string">"W2"</span>]</span><br><span class="line"></span><br><span class="line">    A1 = cache[<span class="string">"A1"</span>]</span><br><span class="line">    A2 = cache[<span class="string">"A2"</span>]</span><br><span class="line"></span><br><span class="line">    dZ2= A2 - Y</span><br><span class="line">    dW2 = (<span class="number">1</span> / m) * np.dot(dZ2, A1.T)</span><br><span class="line">    db2 = (<span class="number">1</span> / m) * np.sum(dZ2, axis=<span class="number">1</span>, keepdims=<span class="literal">True</span>)</span><br><span class="line">    dZ1 = np.multiply(np.dot(W2.T, dZ2), <span class="number">1</span> - np.power(A1, <span class="number">2</span>))</span><br><span class="line">    dW1 = (<span class="number">1</span> / m) * np.dot(dZ1, X.T)</span><br><span class="line">    db1 = (<span class="number">1</span> / m) * np.sum(dZ1, axis=<span class="number">1</span>, keepdims=<span class="literal">True</span>)</span><br><span class="line">    grads = &#123;<span class="string">"dW1"</span>: dW1,</span><br><span class="line">             <span class="string">"db1"</span>: db1,</span><br><span class="line">             <span class="string">"dW2"</span>: dW2,</span><br><span class="line">             <span class="string">"db2"</span>: db2 &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> grads</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update_parameters</span><span class="params">(parameters,grads,learning_rate=<span class="number">1.2</span>)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    使用上面给出的梯度下降更新规则更新参数</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    参数：</span></span><br><span class="line"><span class="string">     parameters - 包含参数的字典类型的变量。</span></span><br><span class="line"><span class="string">     grads - 包含导数值的字典类型的变量。</span></span><br><span class="line"><span class="string">     learning_rate - 学习速率</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    返回：</span></span><br><span class="line"><span class="string">     parameters - 包含更新参数的字典类型的变量。</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    W1,W2 = parameters[<span class="string">"W1"</span>],parameters[<span class="string">"W2"</span>]</span><br><span class="line">    b1,b2 = parameters[<span class="string">"b1"</span>],parameters[<span class="string">"b2"</span>]</span><br><span class="line"></span><br><span class="line">    dW1,dW2 = grads[<span class="string">"dW1"</span>],grads[<span class="string">"dW2"</span>]</span><br><span class="line">    db1,db2 = grads[<span class="string">"db1"</span>],grads[<span class="string">"db2"</span>]</span><br><span class="line"></span><br><span class="line">    W1 = W1 - learning_rate * dW1</span><br><span class="line">    b1 = b1 - learning_rate * db1</span><br><span class="line">    W2 = W2 - learning_rate * dW2</span><br><span class="line">    b2 = b2 - learning_rate * db2</span><br><span class="line"></span><br><span class="line">    parameters = &#123;<span class="string">"W1"</span>: W1,</span><br><span class="line">                  <span class="string">"b1"</span>: b1,</span><br><span class="line">                  <span class="string">"W2"</span>: W2,</span><br><span class="line">                  <span class="string">"b2"</span>: b2&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> parameters</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nn_model</span><span class="params">(X,Y,n_h,num_iterations,print_cost=False)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    参数：</span></span><br><span class="line"><span class="string">        X - 数据集,维度为（2，示例数）</span></span><br><span class="line"><span class="string">        Y - 标签，维度为（1，示例数）</span></span><br><span class="line"><span class="string">        n_h - 隐藏层的数量</span></span><br><span class="line"><span class="string">        num_iterations - 梯度下降循环中的迭代次数</span></span><br><span class="line"><span class="string">        print_cost - 如果为True，则每1000次迭代打印一次成本数值</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    返回：</span></span><br><span class="line"><span class="string">        parameters - 模型学习的参数，它们可以用来进行预测。</span></span><br><span class="line"><span class="string">     """</span></span><br><span class="line"></span><br><span class="line">    np.random.seed(<span class="number">3</span>) <span class="comment">#指定随机种子</span></span><br><span class="line">    n_x = layer_sizes(X, Y)[<span class="number">0</span>]</span><br><span class="line">    n_y = layer_sizes(X, Y)[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">    parameters = initialize_parameters(n_x,n_h,n_y)</span><br><span class="line">    W1 = parameters[<span class="string">"W1"</span>]</span><br><span class="line">    b1 = parameters[<span class="string">"b1"</span>]</span><br><span class="line">    W2 = parameters[<span class="string">"W2"</span>]</span><br><span class="line">    b2 = parameters[<span class="string">"b2"</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(num_iterations):</span><br><span class="line">        A2 , cache = forward_propagation(X,parameters)</span><br><span class="line">        cost = compute_cost(A2,Y,parameters)</span><br><span class="line">        grads = backward_propagation(parameters,cache,X,Y)</span><br><span class="line">        parameters = update_parameters(parameters,grads,learning_rate = <span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> print_cost:</span><br><span class="line">            <span class="keyword">if</span> i%<span class="number">1000</span> == <span class="number">0</span>:</span><br><span class="line">                print(<span class="string">"第 "</span>,i,<span class="string">" 次循环，成本为："</span>+str(cost))</span><br><span class="line">    <span class="keyword">return</span> parameters</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(parameters,X)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    使用学习的参数，为X中的每个示例预测一个类</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    参数：</span></span><br><span class="line"><span class="string">        parameters - 包含参数的字典类型的变量。</span></span><br><span class="line"><span class="string">        X - 输入数据（n_x，m）</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    返回</span></span><br><span class="line"><span class="string">        predictions - 我们模型预测的向量（红色：0 /蓝色：1）</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">     """</span></span><br><span class="line">    A2 , cache = forward_propagation(X,parameters)</span><br><span class="line">    predictions = np.round(A2)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> predictions</span><br><span class="line"></span><br><span class="line">parameters = nn_model(X, Y, n_h = <span class="number">4</span>, num_iterations=<span class="number">10000</span>, print_cost=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#绘制边界</span></span><br><span class="line">plot_decision_boundary(<span class="keyword">lambda</span> x: predict(parameters, x.T), X, Y)</span><br><span class="line">plt.title(<span class="string">"Decision Boundary for hidden layer size "</span> + str(<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">predictions = predict(parameters, X)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">'准确率: %d'</span> % float((np.dot(Y, predictions.T) + np.dot(<span class="number">1</span> - Y, <span class="number">1</span> - predictions.T)) / float(Y.size) * <span class="number">100</span>) + <span class="string">'%'</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">plt.figure(figsize=(16, 32))</span></span><br><span class="line"><span class="string">hidden_layer_sizes = [1, 2, 3, 4, 5, 20, 50] #隐藏层数量</span></span><br><span class="line"><span class="string">for i, n_h in enumerate(hidden_layer_sizes):</span></span><br><span class="line"><span class="string">    plt.subplot(5, 2, i + 1)</span></span><br><span class="line"><span class="string">    plt.title('Hidden Layer of size %d' % n_h)</span></span><br><span class="line"><span class="string">    parameters = nn_model(X, Y, n_h, num_iterations=5000)</span></span><br><span class="line"><span class="string">    plot_decision_boundary(lambda x: predict(parameters, x.T), X, Y)</span></span><br><span class="line"><span class="string">    predictions = predict(parameters, X)</span></span><br><span class="line"><span class="string">    accuracy = float((np.dot(Y, predictions.T) + np.dot(1 - Y, 1 - predictions.T)) / float(Y.size) * 100)</span></span><br><span class="line"><span class="string">    print ("隐藏层的节点数量： &#123;&#125;  ，准确率: &#123;&#125; %".format(n_h, accuracy))</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><h2 id="testCases-py"><a href="#testCases-py" class="headerlink" title="testCases.py"></a>testCases.py</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#-*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string"># WANGZHE12</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">layer_sizes_test_case</span><span class="params">()</span>:</span></span><br><span class="line">    np.random.seed(<span class="number">1</span>)</span><br><span class="line">    X_assess = np.random.randn(<span class="number">5</span>, <span class="number">3</span>)</span><br><span class="line">    Y_assess = np.random.randn(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">return</span> X_assess, Y_assess</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">initialize_parameters_test_case</span><span class="params">()</span>:</span></span><br><span class="line">    n_x, n_h, n_y = <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> n_x, n_h, n_y</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">forward_propagation_test_case</span><span class="params">()</span>:</span></span><br><span class="line">    np.random.seed(<span class="number">1</span>)</span><br><span class="line">    X_assess = np.random.randn(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    parameters = &#123;<span class="string">'W1'</span>: np.array([[<span class="number">-0.00416758</span>, <span class="number">-0.00056267</span>],</span><br><span class="line">        [<span class="number">-0.02136196</span>,  <span class="number">0.01640271</span>],</span><br><span class="line">        [<span class="number">-0.01793436</span>, <span class="number">-0.00841747</span>],</span><br><span class="line">        [ <span class="number">0.00502881</span>, <span class="number">-0.01245288</span>]]),</span><br><span class="line">     <span class="string">'W2'</span>: np.array([[<span class="number">-0.01057952</span>, <span class="number">-0.00909008</span>,  <span class="number">0.00551454</span>,  <span class="number">0.02292208</span>]]),</span><br><span class="line">     <span class="string">'b1'</span>: np.array([[ <span class="number">0.</span>],</span><br><span class="line">        [ <span class="number">0.</span>],</span><br><span class="line">        [ <span class="number">0.</span>],</span><br><span class="line">        [ <span class="number">0.</span>]]),</span><br><span class="line">     <span class="string">'b2'</span>: np.array([[ <span class="number">0.</span>]])&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> X_assess, parameters</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compute_cost_test_case</span><span class="params">()</span>:</span></span><br><span class="line">    np.random.seed(<span class="number">1</span>)</span><br><span class="line">    Y_assess = np.random.randn(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">    parameters = &#123;<span class="string">'W1'</span>: np.array([[<span class="number">-0.00416758</span>, <span class="number">-0.00056267</span>],</span><br><span class="line">        [<span class="number">-0.02136196</span>,  <span class="number">0.01640271</span>],</span><br><span class="line">        [<span class="number">-0.01793436</span>, <span class="number">-0.00841747</span>],</span><br><span class="line">        [ <span class="number">0.00502881</span>, <span class="number">-0.01245288</span>]]),</span><br><span class="line">     <span class="string">'W2'</span>: np.array([[<span class="number">-0.01057952</span>, <span class="number">-0.00909008</span>,  <span class="number">0.00551454</span>,  <span class="number">0.02292208</span>]]),</span><br><span class="line">     <span class="string">'b1'</span>: np.array([[ <span class="number">0.</span>],</span><br><span class="line">        [ <span class="number">0.</span>],</span><br><span class="line">        [ <span class="number">0.</span>],</span><br><span class="line">        [ <span class="number">0.</span>]]),</span><br><span class="line">     <span class="string">'b2'</span>: np.array([[ <span class="number">0.</span>]])&#125;</span><br><span class="line"></span><br><span class="line">    a2 = (np.array([[ <span class="number">0.5002307</span> ,  <span class="number">0.49985831</span>,  <span class="number">0.50023963</span>]]))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a2, Y_assess, parameters</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backward_propagation_test_case</span><span class="params">()</span>:</span></span><br><span class="line">    np.random.seed(<span class="number">1</span>)</span><br><span class="line">    X_assess = np.random.randn(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">    Y_assess = np.random.randn(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">    parameters = &#123;<span class="string">'W1'</span>: np.array([[<span class="number">-0.00416758</span>, <span class="number">-0.00056267</span>],</span><br><span class="line">        [<span class="number">-0.02136196</span>,  <span class="number">0.01640271</span>],</span><br><span class="line">        [<span class="number">-0.01793436</span>, <span class="number">-0.00841747</span>],</span><br><span class="line">        [ <span class="number">0.00502881</span>, <span class="number">-0.01245288</span>]]),</span><br><span class="line">     <span class="string">'W2'</span>: np.array([[<span class="number">-0.01057952</span>, <span class="number">-0.00909008</span>,  <span class="number">0.00551454</span>,  <span class="number">0.02292208</span>]]),</span><br><span class="line">     <span class="string">'b1'</span>: np.array([[ <span class="number">0.</span>],</span><br><span class="line">        [ <span class="number">0.</span>],</span><br><span class="line">        [ <span class="number">0.</span>],</span><br><span class="line">        [ <span class="number">0.</span>]]),</span><br><span class="line">     <span class="string">'b2'</span>: np.array([[ <span class="number">0.</span>]])&#125;</span><br><span class="line"></span><br><span class="line">    cache = &#123;<span class="string">'A1'</span>: np.array([[<span class="number">-0.00616578</span>,  <span class="number">0.0020626</span> ,  <span class="number">0.00349619</span>],</span><br><span class="line">         [<span class="number">-0.05225116</span>,  <span class="number">0.02725659</span>, <span class="number">-0.02646251</span>],</span><br><span class="line">         [<span class="number">-0.02009721</span>,  <span class="number">0.0036869</span> ,  <span class="number">0.02883756</span>],</span><br><span class="line">         [ <span class="number">0.02152675</span>, <span class="number">-0.01385234</span>,  <span class="number">0.02599885</span>]]),</span><br><span class="line">  <span class="string">'A2'</span>: np.array([[ <span class="number">0.5002307</span> ,  <span class="number">0.49985831</span>,  <span class="number">0.50023963</span>]]),</span><br><span class="line">  <span class="string">'Z1'</span>: np.array([[<span class="number">-0.00616586</span>,  <span class="number">0.0020626</span> ,  <span class="number">0.0034962</span> ],</span><br><span class="line">         [<span class="number">-0.05229879</span>,  <span class="number">0.02726335</span>, <span class="number">-0.02646869</span>],</span><br><span class="line">         [<span class="number">-0.02009991</span>,  <span class="number">0.00368692</span>,  <span class="number">0.02884556</span>],</span><br><span class="line">         [ <span class="number">0.02153007</span>, <span class="number">-0.01385322</span>,  <span class="number">0.02600471</span>]]),</span><br><span class="line">  <span class="string">'Z2'</span>: np.array([[ <span class="number">0.00092281</span>, <span class="number">-0.00056678</span>,  <span class="number">0.00095853</span>]])&#125;</span><br><span class="line">    <span class="keyword">return</span> parameters, cache, X_assess, Y_assess</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update_parameters_test_case</span><span class="params">()</span>:</span></span><br><span class="line">    parameters = &#123;<span class="string">'W1'</span>: np.array([[<span class="number">-0.00615039</span>,  <span class="number">0.0169021</span> ],</span><br><span class="line">        [<span class="number">-0.02311792</span>,  <span class="number">0.03137121</span>],</span><br><span class="line">        [<span class="number">-0.0169217</span> , <span class="number">-0.01752545</span>],</span><br><span class="line">        [ <span class="number">0.00935436</span>, <span class="number">-0.05018221</span>]]),</span><br><span class="line"> <span class="string">'W2'</span>: np.array([[<span class="number">-0.0104319</span> , <span class="number">-0.04019007</span>,  <span class="number">0.01607211</span>,  <span class="number">0.04440255</span>]]),</span><br><span class="line"> <span class="string">'b1'</span>: np.array([[ <span class="number">-8.97523455e-07</span>],</span><br><span class="line">        [  <span class="number">8.15562092e-06</span>],</span><br><span class="line">        [  <span class="number">6.04810633e-07</span>],</span><br><span class="line">        [ <span class="number">-2.54560700e-06</span>]]),</span><br><span class="line"> <span class="string">'b2'</span>: np.array([[  <span class="number">9.14954378e-05</span>]])&#125;</span><br><span class="line"></span><br><span class="line">    grads = &#123;<span class="string">'dW1'</span>: np.array([[ <span class="number">0.00023322</span>, <span class="number">-0.00205423</span>],</span><br><span class="line">        [ <span class="number">0.00082222</span>, <span class="number">-0.00700776</span>],</span><br><span class="line">        [<span class="number">-0.00031831</span>,  <span class="number">0.0028636</span> ],</span><br><span class="line">        [<span class="number">-0.00092857</span>,  <span class="number">0.00809933</span>]]),</span><br><span class="line"> <span class="string">'dW2'</span>: np.array([[ <span class="number">-1.75740039e-05</span>,   <span class="number">3.70231337e-03</span>,  <span class="number">-1.25683095e-03</span>,</span><br><span class="line">          <span class="number">-2.55715317e-03</span>]]),</span><br><span class="line"> <span class="string">'db1'</span>: np.array([[  <span class="number">1.05570087e-07</span>],</span><br><span class="line">        [ <span class="number">-3.81814487e-06</span>],</span><br><span class="line">        [ <span class="number">-1.90155145e-07</span>],</span><br><span class="line">        [  <span class="number">5.46467802e-07</span>]]),</span><br><span class="line"> <span class="string">'db2'</span>: np.array([[ <span class="number">-1.08923140e-05</span>]])&#125;</span><br><span class="line">    <span class="keyword">return</span> parameters, grads</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nn_model_test_case</span><span class="params">()</span>:</span></span><br><span class="line">    np.random.seed(<span class="number">1</span>)</span><br><span class="line">    X_assess = np.random.randn(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">    Y_assess = np.random.randn(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">return</span> X_assess, Y_assess</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict_test_case</span><span class="params">()</span>:</span></span><br><span class="line">    np.random.seed(<span class="number">1</span>)</span><br><span class="line">    X_assess = np.random.randn(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">    parameters = &#123;<span class="string">'W1'</span>: np.array([[<span class="number">-0.00615039</span>,  <span class="number">0.0169021</span> ],</span><br><span class="line">        [<span class="number">-0.02311792</span>,  <span class="number">0.03137121</span>],</span><br><span class="line">        [<span class="number">-0.0169217</span> , <span class="number">-0.01752545</span>],</span><br><span class="line">        [ <span class="number">0.00935436</span>, <span class="number">-0.05018221</span>]]),</span><br><span class="line">     <span class="string">'W2'</span>: np.array([[<span class="number">-0.0104319</span> , <span class="number">-0.04019007</span>,  <span class="number">0.01607211</span>,  <span class="number">0.04440255</span>]]),</span><br><span class="line">     <span class="string">'b1'</span>: np.array([[ <span class="number">-8.97523455e-07</span>],</span><br><span class="line">        [  <span class="number">8.15562092e-06</span>],</span><br><span class="line">        [  <span class="number">6.04810633e-07</span>],</span><br><span class="line">        [ <span class="number">-2.54560700e-06</span>]]),</span><br><span class="line">     <span class="string">'b2'</span>: np.array([[  <span class="number">9.14954378e-05</span>]])&#125;</span><br><span class="line">    <span class="keyword">return</span> parameters, X_assess</span><br></pre></td></tr></table></figure><h2 id="planar-utils-py"><a href="#planar-utils-py" class="headerlink" title="planar_utils.py"></a>planar_utils.py</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> sklearn</span><br><span class="line"><span class="keyword">import</span> sklearn.datasets</span><br><span class="line"><span class="keyword">import</span> sklearn.linear_model</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_decision_boundary</span><span class="params">(model, X, y)</span>:</span></span><br><span class="line">    <span class="comment"># Set min and max values and give it some padding</span></span><br><span class="line">    x_min, x_max = X[<span class="number">0</span>, :].min() - <span class="number">1</span>, X[<span class="number">0</span>, :].max() + <span class="number">1</span></span><br><span class="line">    y_min, y_max = X[<span class="number">1</span>, :].min() - <span class="number">1</span>, X[<span class="number">1</span>, :].max() + <span class="number">1</span></span><br><span class="line">    h = <span class="number">0.01</span></span><br><span class="line">    <span class="comment"># Generate a grid of points with distance h between them</span></span><br><span class="line">    xx, yy = np.meshgrid(np.arange(x_min, x_max, h), np.arange(y_min, y_max, h))</span><br><span class="line">    <span class="comment"># Predict the function value for the whole grid</span></span><br><span class="line">    Z = model(np.c_[xx.ravel(), yy.ravel()])</span><br><span class="line">    Z = Z.reshape(xx.shape)</span><br><span class="line">    <span class="comment"># Plot the contour and training examples</span></span><br><span class="line">    plt.contourf(xx, yy, Z, cmap=plt.cm.Spectral)</span><br><span class="line">    plt.ylabel(<span class="string">'x2'</span>)</span><br><span class="line">    plt.xlabel(<span class="string">'x1'</span>)</span><br><span class="line">    plt.scatter(X[<span class="number">0</span>, :], X[<span class="number">1</span>, :], c=y, cmap=plt.cm.Spectral)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sigmoid</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Compute the sigmoid of x</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Arguments:</span></span><br><span class="line"><span class="string">    x -- A scalar or numpy array of any size.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Return:</span></span><br><span class="line"><span class="string">    s -- sigmoid(x)</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    s = <span class="number">1</span>/(<span class="number">1</span>+np.exp(-x))</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_planar_dataset</span><span class="params">()</span>:</span></span><br><span class="line">    np.random.seed(<span class="number">1</span>)</span><br><span class="line">    m = <span class="number">400</span> <span class="comment"># number of examples</span></span><br><span class="line">    N = int(m/<span class="number">2</span>) <span class="comment"># number of points per class</span></span><br><span class="line">    D = <span class="number">2</span> <span class="comment"># dimensionality</span></span><br><span class="line">    X = np.zeros((m,D)) <span class="comment"># data matrix where each row is a single example</span></span><br><span class="line">    Y = np.zeros((m,<span class="number">1</span>), dtype=<span class="string">'uint8'</span>) <span class="comment"># labels vector (0 for red, 1 for blue)</span></span><br><span class="line">    a = <span class="number">4</span> <span class="comment"># maximum ray of the flower</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">        ix = range(N*j,N*(j+<span class="number">1</span>))</span><br><span class="line">        t = np.linspace(j*<span class="number">3.12</span>,(j+<span class="number">1</span>)*<span class="number">3.12</span>,N) + np.random.randn(N)*<span class="number">0.2</span> <span class="comment"># theta</span></span><br><span class="line">        r = a*np.sin(<span class="number">4</span>*t) + np.random.randn(N)*<span class="number">0.2</span> <span class="comment"># radius</span></span><br><span class="line">        X[ix] = np.c_[r*np.sin(t), r*np.cos(t)]</span><br><span class="line">        Y[ix] = j</span><br><span class="line">        </span><br><span class="line">    X = X.T</span><br><span class="line">    Y = Y.T</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> X, Y</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_extra_datasets</span><span class="params">()</span>:</span>  </span><br><span class="line">    N = <span class="number">200</span></span><br><span class="line">    noisy_circles = sklearn.datasets.make_circles(n_samples=N, factor=<span class="number">.5</span>, noise=<span class="number">.3</span>)</span><br><span class="line">    noisy_moons = sklearn.datasets.make_moons(n_samples=N, noise=<span class="number">.2</span>)</span><br><span class="line">    blobs = sklearn.datasets.make_blobs(n_samples=N, random_state=<span class="number">5</span>, n_features=<span class="number">2</span>, centers=<span class="number">6</span>)</span><br><span class="line">    gaussian_quantiles = sklearn.datasets.make_gaussian_quantiles(mean=<span class="literal">None</span>, cov=<span class="number">0.5</span>, n_samples=N, n_features=<span class="number">2</span>, n_classes=<span class="number">2</span>, shuffle=<span class="literal">True</span>, random_state=<span class="literal">None</span>)</span><br><span class="line">    no_structure = np.random.rand(N, <span class="number">2</span>), np.random.rand(N, <span class="number">2</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> noisy_circles, noisy_moons, blobs, gaussian_quantiles, no_structure</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 神经网络 </tag>
            
            <tag> 浅层神经网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python基础与Numpy 吴恩达深度学习</title>
      <link href="/2020/01/15/Python%E5%9F%BA%E7%A1%80%E4%B8%8ENumpy-%E5%90%B4%E6%81%A9%E8%BE%BE%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
      <url>/2020/01/15/Python%E5%9F%BA%E7%A1%80%E4%B8%8ENumpy-%E5%90%B4%E6%81%A9%E8%BE%BE%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="使用numpy函数和numpy矩阵-向量运算"><a href="#使用numpy函数和numpy矩阵-向量运算" class="headerlink" title="使用numpy函数和numpy矩阵/向量运算"></a><strong>使用numpy函数和numpy矩阵/向量运算</strong></h2><a id="more"></a><h3 id="sigmoid-函数-np-exp"><a href="#sigmoid-函数-np-exp" class="headerlink" title="sigmoid 函数, np.exp()"></a><strong>sigmoid 函数, np.exp()</strong></h3><p>In fact, if “$x = (x_1, x_2, …, x_n)$”  is a row vector then $np.exp(x)$ will apply the exponential function to every element of x. The output will thus be:<br>$$<br>np.exp(x) = (e^{x_1}, e^{x_2}, …, e^{x_n})<br>$$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">print(np.exp(x))<span class="comment">#结果是(exp(1), exp(2), exp(3))</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[  2.71828183   7.3890561   20.08553692]</span><br></pre></td></tr></table></figure><hr><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 向量化的例子</span></span><br><span class="line">x = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="keyword">print</span> (x + <span class="number">3</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[4 5 6]</span><br></pre></td></tr></table></figure><hr><p>x现在可以是<strong>实数，向量或矩阵</strong>。 我们在numpy中使用的表示这些形状（矢量，矩阵等）的数据结构称为numpy数组。<br>$$<br>\text{For } x \in \mathbb{R}^n \text{,} sigmoid(x) = sigmoid\begin{pmatrix}<br>    x_1  \<br>    x_2  \<br>    …  \<br>    x_n  \<br>\end{pmatrix} = \begin{pmatrix}<br>    \frac{1}{1+e^{-x_1}}  \<br>    \frac{1}{1+e^{-x_2}}  \<br>    …  \<br>    \frac{1}{1+e^{-x_n}}  \<br>\end{pmatrix}\tag{1}<br>$$</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sigmoid</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Compute the sigmoid of x</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Arguments:</span></span><br><span class="line"><span class="string">    x -- A scalar or numpy array of any size</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Return:</span></span><br><span class="line"><span class="string">    s -- sigmoid(x)</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">### START CODE HERE ### (≈ 1 line of code)</span></span><br><span class="line">    s = <span class="number">1</span> / (<span class="number">1</span> + np.exp(-x))</span><br><span class="line">    <span class="comment">### END CODE HERE ###</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">sigmoid(x) <span class="comment">#x为列表的化就会报错</span></span><br><span class="line"><span class="comment">#array([0.73105858, 0.88079708, 0.95257413])</span></span><br></pre></td></tr></table></figure><hr><h3 id="Sigmoid-梯度"><a href="#Sigmoid-梯度" class="headerlink" title="Sigmoid 梯度"></a><strong>Sigmoid 梯度</strong></h3><p>需要计算梯度以使用反向传播来优化损耗函数</p><p>您将需要计算梯度以使用反向传播来优化损耗函数。公式为：<br>$$<br>sigmoid_derivative(x) = \sigma’(x) = \sigma(x) (1 - \sigma(x))\tag{2}<br>$$<br>两步编写此函数的代码：</p><ol><li>将s设置为x的sigmoid形。 您可能会发现sigmoid（x）函数很有用。</li><li>计算𝜎’（𝑥）=𝑠（1-𝑠）</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># GRADED FUNCTION: sigmoid_derivative</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sigmoid_derivative</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    计算sigmoid型函数相对于其输入x的梯度（也称为斜率或导数）。</span></span><br><span class="line"><span class="string">  您可以将sigmoid型函数的输出存储到变量中，然后使用它来计算梯度。</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">     参数：</span></span><br><span class="line"><span class="string">     x-标量或numpy数组</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">     返回：</span></span><br><span class="line"><span class="string">     ds-您计算出的梯度。</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">### START CODE HERE ### (≈ 2 lines of code)</span></span><br><span class="line">    s = sigmoid(x)</span><br><span class="line">    ds = s * (<span class="number">1</span> - s)</span><br><span class="line">    <span class="comment">### END CODE HERE ###</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ds</span><br></pre></td></tr></table></figure><p>求导</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"sigmoid_derivative(x) = "</span> + str(sigmoid_derivative(x)))</span><br><span class="line"><span class="comment">#结果：sigmoid_derivative(x) = [0.19661193 0.10499359 0.04517666]</span></span><br></pre></td></tr></table></figure><h3 id="Reshaping-arrays"><a href="#Reshaping-arrays" class="headerlink" title="Reshaping arrays"></a><strong>Reshaping arrays</strong></h3><p>深度学习中使用的两个常见的numpy函数是np.shape和np.reshape（）。</p><ul><li>X.shape用于获取矩阵/向量X的形状（尺寸）。</li><li>X.reshape（…）用于将X重塑为其他尺寸。</li></ul><p>例如，在计算机科学中，图像由形状为（𝑙𝑒𝑛𝑔𝑡ℎ，ℎ𝑒𝑖𝑔ℎ𝑡，𝑑𝑒𝑝𝑡ℎ= 3）的3D数组表示。 但是，当您读取图像作为算法的输入时，会将其转换为形状为（𝑙𝑒𝑛𝑔𝑡ℎ∗ℎ𝑒𝑖𝑔ℎ𝑡∗ 3,1）的向量。 换句话说，您将3D阵列“展开”或重塑为1D向量。</p><p><img src="http://q45jvnp3f.bkt.clouddn.com/image2vector_kiank.png" alt="t图像转化向量"></p><p><img src="https://raw.githubusercontent.com/pxlsdz/MarkDown-images/master/image2vector_kiank.png" alt="图片"></p><p>练习：实现image2vector（），它接受形状（长度，高度，depth=3）的输入，并返回形状（长度*高度* 3，1）的向量。 例如，如果要将形状为（a，b，c）的数组v整形为形状为（a * b，c）的向量，则可以执行以下操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v = v.reshape((v.shape[<span class="number">0</span>]*v.shape[<span class="number">1</span>], v.shape[<span class="number">2</span>])) </span><br><span class="line"><span class="comment"># v.shape[0] = a ; v.shape[1] = b ; v.shape[2] = c</span></span><br></pre></td></tr></table></figure><p>请不要将图像的尺寸硬编码为常数。 而是使用image.shape [0]等查找所需的数量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">image2vector</span><span class="params">(image)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Argument:</span></span><br><span class="line"><span class="string">    image -- a numpy array of shape (length, height, depth)</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">    v -- a vector of shape (length*height*depth, 1)</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">### START CODE HERE ### (≈ 1 line of code)</span></span><br><span class="line">    v = image.reshape(image.shape[<span class="number">0</span>] * image.shape[<span class="number">1</span>] * image.shape[<span class="number">2</span>], <span class="number">1</span>)</span><br><span class="line">    <span class="comment">### END CODE HERE ###</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> v</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">image = np.array([[[ <span class="number">0.67826139</span>,  <span class="number">0.29380381</span>],</span><br><span class="line">        [ <span class="number">0.90714982</span>,  <span class="number">0.52835647</span>],</span><br><span class="line">        [ <span class="number">0.4215251</span> ,  <span class="number">0.45017551</span>]],</span><br><span class="line"></span><br><span class="line">       [[ <span class="number">0.92814219</span>,  <span class="number">0.96677647</span>],</span><br><span class="line">        [ <span class="number">0.85304703</span>,  <span class="number">0.52351845</span>],</span><br><span class="line">        [ <span class="number">0.19981397</span>,  <span class="number">0.27417313</span>]],</span><br><span class="line"></span><br><span class="line">       [[ <span class="number">0.60659855</span>,  <span class="number">0.00533165</span>],</span><br><span class="line">        [ <span class="number">0.10820313</span>,  <span class="number">0.49978937</span>],</span><br><span class="line">        [ <span class="number">0.34144279</span>,  <span class="number">0.94630077</span>]]])</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> (<span class="string">"image2vector(image) = "</span> + str(image2vector(image)))</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">image2vector(image) &#x3D; [[0.67826139]</span><br><span class="line"> [0.29380381]</span><br><span class="line"> [0.90714982]</span><br><span class="line"> [0.52835647]</span><br><span class="line"> [0.4215251 ]</span><br><span class="line"> [0.45017551]</span><br><span class="line"> [0.92814219]</span><br><span class="line"> [0.96677647]</span><br><span class="line"> [0.85304703]</span><br><span class="line"> [0.52351845]</span><br><span class="line"> [0.19981397]</span><br><span class="line"> [0.27417313]</span><br><span class="line"> [0.60659855]</span><br><span class="line"> [0.00533165]</span><br><span class="line"> [0.10820313]</span><br><span class="line"> [0.49978937]</span><br><span class="line"> [0.34144279]</span><br><span class="line"> [0.94630077]]</span><br></pre></td></tr></table></figure><h3 id="标准化行"><a href="#标准化行" class="headerlink" title="标准化行"></a><strong>标准化行</strong></h3><p>我们在机器学习和深度学习中使用的另一种常用技术是对数据进行规范化。 通常会导致更好的性能，因为归一化后梯度下降的收敛速度更快。 在这里，通过归一化，我们的意思是将x更改为$ \frac{x}{| x|} $（将x的每个行向量除以其范数）</p><p>如果<br>$$<br>x =<br>\begin{bmatrix}<br>    0 &amp; 3 &amp; 4 \<br>    2 &amp; 6 &amp; 4 \<br>\end{bmatrix}\tag{3}<br>$$</p><p> 然后<br>$$<br>| x| = np.linalg.norm(x, axis = 1, keepdims = True) = \begin{bmatrix}<br>    5 \<br>    \sqrt{56} \<br>\end{bmatrix}\tag{4}<br>$$</p><p>接着        </p><p>$$<br>x_normalized = \frac{x}{| x|} = \begin{bmatrix}<br>    0 &amp; \frac{3}{5} &amp; \frac{4}{5} \<br>    \frac{2}{\sqrt{56}} &amp; \frac{6}{\sqrt{56}} &amp; \frac{4}{\sqrt{56}} \<br>\end{bmatrix}\tag{5}<br>$$</p><p>请注意，可以划分不同大小的矩阵，并且效果很好：这称为广播，下面会学习它。</p><p>练习：实现normalizeRows（）来规范化矩阵的行。 在将此函数应用于输入矩阵x之后，x的每一行应为单位长度（即长度1）的向量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">normalizeRows</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Implement a function that normalizes each row of the matrix x (to have unit length).</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Argument:</span></span><br><span class="line"><span class="string">    x -- A numpy matrix of shape (n, m)</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">    x -- The normalized (by row) numpy matrix. You are allowed to modify x.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">### START CODE HERE ### (≈ 2 lines of code)</span></span><br><span class="line">    <span class="comment"># Compute x_norm as the norm 2 of x. Use np.linalg.norm(..., ord = 2, axis = ..., keepdims = True)</span></span><br><span class="line">    x_norm = np.linalg.norm(x, axis = <span class="number">1</span>, keepdims = <span class="literal">True</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Divide x by its norm.</span></span><br><span class="line">    x = x / x_norm</span><br><span class="line">    <span class="comment">### END CODE HERE ###</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = np.array([</span><br><span class="line">    [<span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">    [<span class="number">1</span>, <span class="number">6</span>, <span class="number">4</span>]])</span><br><span class="line">print(<span class="string">"normalizeRows(x) = "</span> + str(normalizeRows(x)))</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">normalizeRows(x) = [[<span class="number">0.</span>         <span class="number">0.6</span>        <span class="number">0.8</span>       ]</span><br><span class="line"> [<span class="number">0.13736056</span> <span class="number">0.82416338</span> <span class="number">0.54944226</span>]]</span><br></pre></td></tr></table></figure><p>在normalizeRows（）中，可以尝试打印x_norm和x的形状，然后重新运行评估。 会发现它们具有不同的形状。 鉴于x_norm采用x每行的范数，这是正常的。 因此，x_norm具有相同的行数，但只有1列。 那么，当将x除以x_norm时，它是如何工作的？ 这就是所谓的广播！</p><h2 id="广播"><a href="#广播" class="headerlink" title="广播"></a><strong>广播</strong></h2><p>在numpy中要理解的一个非常重要的概念是“广播”。 这对于在不同形状的数组之间执行数学运算非常有用。 </p><p>练习：使用numpy实现softmax函数。 可以将softmax视为算法需要对两个或多个类进行分类时使用的规范化函数。 </p><ul><li><p>$ \text{对于 } x \in \mathbb{R}^{1\times n} \text{,     } softmax(x) = softmax(\begin{bmatrix}<br>  x_1  &amp;&amp;<br>  x_2 &amp;&amp;<br>  …  &amp;&amp;<br>  x_n<br>\end{bmatrix}) = \begin{bmatrix}<br>   \frac{e^{x_1}}{\sum_{j}e^{x_j}}  &amp;&amp;<br>  \frac{e^{x_2}}{\sum_{j}e^{x_j}}  &amp;&amp;<br>  …  &amp;&amp;<br>  \frac{e^{x_n}}{\sum_{j}e^{x_j}}<br>\end{bmatrix} $ </p></li><li><p>$\text{对于每一个矩阵 } x \in \mathbb{R}^{m \times n} \text{,  $x_{ij}$ maps to the element in the $i^{th}$ row and $j^{th}$ column of $x$, thus we have: }$  </p></li><li><p>$$<br>  softmax(x) = softmax\begin{bmatrix}<br>  x_{11} &amp; x_{12} &amp; x_{13} &amp; \dots  &amp; x_{1n} \<br>  x_{21} &amp; x_{22} &amp; x_{23} &amp; \dots  &amp; x_{2n} \<br>  \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \<br>x_{m1} &amp; x_{m2} &amp; x_{m3} &amp; \dots  &amp; x_{mn}<br>  \end{bmatrix} = \begin{bmatrix}<br>  \frac{e^{x_{11}}}{\sum_{j}e^{x_{1j}}} &amp; \frac{e^{x_{12}}}{\sum_{j}e^{x_{1j}}} &amp; \frac{e^{x_{13}}}{\sum_{j}e^{x_{1j}}} &amp; \dots  &amp; \frac{e^{x_{1n}}}{\sum_{j}e^{x_{1j}}} \<br>  \frac{e^{x_{21}}}{\sum_{j}e^{x_{2j}}} &amp; \frac{e^{x_{22}}}{\sum_{j}e^{x_{2j}}} &amp; \frac{e^{x_{23}}}{\sum_{j}e^{x_{2j}}} &amp; \dots  &amp; \frac{e^{x_{2n}}}{\sum_{j}e^{x_{2j}}} \<br>  \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \<br>\frac{e^{x_{m1}}}{\sum_{j}e^{x_{mj}}} &amp; \frac{e^{x_{m2}}}{\sum_{j}e^{x_{mj}}} &amp; \frac{e^{x_{m3}}}{\sum_{j}e^{x_{mj}}} &amp; \dots  &amp; \frac{e^{x_{mn}}}{\sum_{j}e^{x_{mj}}}<br>  \end{bmatrix} = \begin{pmatrix}<br>  softmax\text{(first row of x)}  \<br>  softmax\text{(second row of x)} \<br>  …  \<br>softmax\text{(last row of x)} \<br>  \end{pmatrix}<br>  $$</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">softmax</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="string">"""Calculates the softmax for each row of the input x.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Your code should work for a row vector and also for matrices of shape (n, m).</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Argument:</span></span><br><span class="line"><span class="string">    x -- A numpy matrix of shape (n,m)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">    s -- A numpy matrix equal to the softmax of x, of shape (n,m)</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">### START CODE HERE ### (≈ 3 lines of code)</span></span><br><span class="line">    <span class="comment"># Apply exp() element-wise to x. Use np.exp(...).</span></span><br><span class="line">    x_exp = np.exp(x)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建向量x_sum，该向量求和x_exp的每一行。 使用np.sum（...，axis = 1，keepdims = True）</span></span><br><span class="line">    x_sum = np.sum(x_exp, axis = <span class="number">1</span>, keepdims = <span class="literal">True</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Compute softmax(x) by dividing x_exp by x_sum. It should automatically use numpy broadcasting.</span></span><br><span class="line">    s = x_exp / x_sum</span><br><span class="line"></span><br><span class="line">    <span class="comment">### END CODE HERE ###</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = np.array([</span><br><span class="line">    [<span class="number">9</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [<span class="number">7</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span> ,<span class="number">0</span>]])</span><br><span class="line">print(<span class="string">"softmax(x) = "</span> + str(softmax(x)))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">softmax(x) &#x3D; [[9.80897665e-01 8.94462891e-04 1.79657674e-02 1.21052389e-04</span><br><span class="line">  1.21052389e-04]</span><br><span class="line"> [8.78679856e-01 1.18916387e-01 8.01252314e-04 8.01252314e-04</span><br><span class="line">  8.01252314e-04]]</span><br></pre></td></tr></table></figure><p>如果在上面打印x_exp，x_sum和s的形状并重新运行评估单元，您将看到x_sum的形状为（2,1），而x_exp和s的形状为（2,5）。 x_exp / x_sum由于python广播而起作用。</p><h2 id="向量化代码"><a href="#向量化代码" class="headerlink" title="向量化代码"></a><strong>向量化代码</strong></h2><p>在深度学习中，您处理非常大的数据集。 因此，非计算最佳函数可能会成为算法中的巨大瓶颈，并可能导致模型运行一段时间。 为了确保代码在计算上高效，您将使用向量化。 例如，尝试说明点/外部/元素乘积的以下实现之间的区别。</p><p>普通实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x1 = [<span class="number">9</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">x2 = [<span class="number">9</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">0</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tic = time.process_time()</span><br><span class="line">dot = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(x1)):</span><br><span class="line">    dot+= x1[i]*x2[i]</span><br><span class="line">toc = time.process_time()</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"dot = "</span> + str(dot) + <span class="string">"\n ----- Computation time = "</span> + str(<span class="number">1000</span>*(toc - tic)) + <span class="string">"ms"</span>)</span><br><span class="line"></span><br><span class="line">tic = time.process_time()</span><br><span class="line">outer = np.zeros((len(x1),len(x2))) <span class="comment"># we create a len(x1)*len(x2) matrix with only zeros</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(x1)):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(len(x2)):</span><br><span class="line">        outer[i,j] = x1[i]*x2[j]</span><br><span class="line">toc = time.process_time()</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"outer = "</span> + str(outer) + <span class="string">"\n ----- Computation time = "</span> + str(<span class="number">1000</span>*(toc - tic)) + <span class="string">"ms"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tic = time.process_time()</span><br><span class="line">mul = np.zeros(len(x1))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(x1)):</span><br><span class="line">    mul[i] = x1[i]*x2[i]</span><br><span class="line">toc = time.process_time()</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"elementwise multiplication = "</span> + str(mul) + <span class="string">"\n ----- Computation time = "</span> + str(<span class="number">1000</span>*(toc - tic)) + <span class="string">"ms"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">W = np.random.rand(<span class="number">3</span>,len(x1)) <span class="comment"># Random 3*len(x1) numpy array</span></span><br><span class="line">tic = time.process_time()</span><br><span class="line">gdot = np.zeros(W.shape[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(W.shape[<span class="number">0</span>]):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(len(x1)):</span><br><span class="line">        gdot[i] += W[i,j]*x1[j]</span><br><span class="line">toc = time.process_time()</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"gdot = "</span> + str(gdot) + <span class="string">"\n ----- Computation time = "</span> + str(<span class="number">1000</span>*(toc - tic)) + <span class="string">"ms"</span>)</span><br></pre></td></tr></table></figure><p>（1）：np.dot()</p><p>如果碰到的是秩为1的数组，那么执行的是对应位置的元素相乘再相加;</p><p>如果遇到的是秩不为1的数组，那么执行的是矩阵相乘。但是需要注意的是矩阵与矩阵相乘是秩为2，矩阵和向量相乘秩为1。</p><p>（2)：np.multiply()表示的是数组和矩阵对应位置相乘，输出和输出的结果shape一致。</p><p>（3）：np.outer()(外积）</p><p>表示的是两个向量相乘，拿第一个向量的元素分别与第二个向量所有元素相乘得到结果的一行。</p><p>假设向量 a = [a0,  a1,  … , aM], b = [b0, b1, …, bN],   则 a<em>b =[[a0</em>b0, a0<em>b1, … ,a0</em>bM], [a1<em>b0, a1</em>b1, … , a1<em>bN], …. , [aM</em>b0, aM<em>b1, … , aM</em>bN]]; 注意：若 a，b 不为一维数组，则先将其变成一维数组，即可得 a(M,)和 b(N,) 这种形式。</p><p>（4）：*对数组执行的是对应位置相乘，对矩阵执行的是矩阵相乘。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">x1 = [<span class="number">9</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">x2 = [<span class="number">9</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">0</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">tic = time.process_time()</span><br><span class="line">dot = np.dot(x1,x2)</span><br><span class="line">toc = time.process_time()</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"dot = "</span> + str(dot) + <span class="string">"\n ----- Computation time = "</span> + str(<span class="number">1000</span>*(toc - tic)) + <span class="string">"ms"</span>)</span><br><span class="line"></span><br><span class="line">tic = time.process_time()</span><br><span class="line">outer = np.outer(x1,x2)</span><br><span class="line">toc = time.process_time()</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"outer = "</span> + str(outer) + <span class="string">"\n ----- Computation time = "</span> + str(<span class="number">1000</span>*(toc - tic)) + <span class="string">"ms"</span>)</span><br><span class="line"></span><br><span class="line">tic = time.process_time()</span><br><span class="line">mul = np.multiply(x1,x2)</span><br><span class="line">toc = time.process_time()</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"elementwise multiplication = "</span> + str(mul) + <span class="string">"\n ----- Computation time = "</span> + str(<span class="number">1000</span>*(toc - tic)) + <span class="string">"ms"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tic = time.process_time()</span><br><span class="line">dot = np.dot(W,x1)</span><br><span class="line">toc = time.process_time()</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"gdot = "</span> + str(dot) + <span class="string">"\n ----- Computation time = "</span> + str(<span class="number">1000</span>*(toc - tic)) + <span class="string">"ms"</span>)</span><br></pre></td></tr></table></figure><p>两个输出结果是一样的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> ----- Computation time = <span class="number">0.0</span>ms</span><br><span class="line">outer = [[<span class="number">81</span> <span class="number">18</span> <span class="number">18</span> <span class="number">81</span>  <span class="number">0</span> <span class="number">81</span> <span class="number">18</span> <span class="number">45</span>  <span class="number">0</span>  <span class="number">0</span> <span class="number">81</span> <span class="number">18</span> <span class="number">45</span>  <span class="number">0</span>  <span class="number">0</span>]</span><br><span class="line"> [<span class="number">18</span>  <span class="number">4</span>  <span class="number">4</span> <span class="number">18</span>  <span class="number">0</span> <span class="number">18</span>  <span class="number">4</span> <span class="number">10</span>  <span class="number">0</span>  <span class="number">0</span> <span class="number">18</span>  <span class="number">4</span> <span class="number">10</span>  <span class="number">0</span>  <span class="number">0</span>]</span><br><span class="line"> [<span class="number">45</span> <span class="number">10</span> <span class="number">10</span> <span class="number">45</span>  <span class="number">0</span> <span class="number">45</span> <span class="number">10</span> <span class="number">25</span>  <span class="number">0</span>  <span class="number">0</span> <span class="number">45</span> <span class="number">10</span> <span class="number">25</span>  <span class="number">0</span>  <span class="number">0</span>]</span><br><span class="line"> [ <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>]</span><br><span class="line"> [ <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>]</span><br><span class="line"> [<span class="number">63</span> <span class="number">14</span> <span class="number">14</span> <span class="number">63</span>  <span class="number">0</span> <span class="number">63</span> <span class="number">14</span> <span class="number">35</span>  <span class="number">0</span>  <span class="number">0</span> <span class="number">63</span> <span class="number">14</span> <span class="number">35</span>  <span class="number">0</span>  <span class="number">0</span>]</span><br><span class="line"> [<span class="number">45</span> <span class="number">10</span> <span class="number">10</span> <span class="number">45</span>  <span class="number">0</span> <span class="number">45</span> <span class="number">10</span> <span class="number">25</span>  <span class="number">0</span>  <span class="number">0</span> <span class="number">45</span> <span class="number">10</span> <span class="number">25</span>  <span class="number">0</span>  <span class="number">0</span>]</span><br><span class="line"> [ <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>]</span><br><span class="line"> [ <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>]</span><br><span class="line"> [ <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>]</span><br><span class="line"> [<span class="number">81</span> <span class="number">18</span> <span class="number">18</span> <span class="number">81</span>  <span class="number">0</span> <span class="number">81</span> <span class="number">18</span> <span class="number">45</span>  <span class="number">0</span>  <span class="number">0</span> <span class="number">81</span> <span class="number">18</span> <span class="number">45</span>  <span class="number">0</span>  <span class="number">0</span>]</span><br><span class="line"> [<span class="number">18</span>  <span class="number">4</span>  <span class="number">4</span> <span class="number">18</span>  <span class="number">0</span> <span class="number">18</span>  <span class="number">4</span> <span class="number">10</span>  <span class="number">0</span>  <span class="number">0</span> <span class="number">18</span>  <span class="number">4</span> <span class="number">10</span>  <span class="number">0</span>  <span class="number">0</span>]</span><br><span class="line"> [<span class="number">45</span> <span class="number">10</span> <span class="number">10</span> <span class="number">45</span>  <span class="number">0</span> <span class="number">45</span> <span class="number">10</span> <span class="number">25</span>  <span class="number">0</span>  <span class="number">0</span> <span class="number">45</span> <span class="number">10</span> <span class="number">25</span>  <span class="number">0</span>  <span class="number">0</span>]</span><br><span class="line"> [ <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>]</span><br><span class="line"> [ <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>]]</span><br><span class="line"> ----- Computation time = <span class="number">0.0</span>ms</span><br><span class="line">elementwise multiplication = [<span class="number">81</span>  <span class="number">4</span> <span class="number">10</span>  <span class="number">0</span>  <span class="number">0</span> <span class="number">63</span> <span class="number">10</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span> <span class="number">81</span>  <span class="number">4</span> <span class="number">25</span>  <span class="number">0</span>  <span class="number">0</span>]</span><br><span class="line"> ----- Computation time = <span class="number">0.0</span>ms</span><br><span class="line">gdot = [<span class="number">20.19795192</span> <span class="number">23.62425978</span> <span class="number">18.27514239</span>]</span><br><span class="line"> ----- Computation time = <span class="number">0.0</span>ms</span><br></pre></td></tr></table></figure><p>向量化的实现更加简洁高效。 对于更大的向量/矩阵，运行时间的差异变得更大。</p><p><strong>请注意</strong> np.dot（）执行矩阵矩阵或矩阵向量乘法。 这与np.multiply（）和<em>操作符（在Matlab / Octave中等效于。</em>）不同，后者执行逐元素乘法。</p><h3 id="实现L1和L2损失功能"><a href="#实现L1和L2损失功能" class="headerlink" title="实现L1和L2损失功能"></a><strong>实现L1和L2损失功能</strong></h3><p><strong>练习</strong>：实施L1损失的Numpy向量化版本。 您可能会发现函数abs（x）（x的绝对值）很有用。</p><p><strong>提醒</strong>：<br>-损失用于评估模型的性能。 损失越大，您的预测（$\hat{y}$）与真实值（$y$）的差异就越大。 在深度学习中，您可以使用诸如Gradient Descent之类的优化算法来训练模型并最大程度地降低成本。<br>-L1损失定义为：<br>$$<br>\begin{align<em>} &amp; L_1(\hat{y}, y) = \sum_{i=0}^m|y^{(i)} - \hat{y}^{(i)}| \end{align</em>}\tag{6}<br>$$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">L1</span><span class="params">(yhat, y)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Arguments:</span></span><br><span class="line"><span class="string">    yhat -- vector of size m (predicted labels)</span></span><br><span class="line"><span class="string">    y -- vector of size m (true labels)</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">    loss -- the value of the L1 loss function defined above</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">### START CODE HERE ### (≈ 1 line of code)</span></span><br><span class="line">    loss = np.sum(np.abs(y - yhat))</span><br><span class="line">    <span class="comment">### END CODE HERE ###</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> loss</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yhat = np.array([<span class="number">.9</span>, <span class="number">0.2</span>, <span class="number">0.1</span>, <span class="number">.4</span>, <span class="number">.9</span>])</span><br><span class="line">y = np.array([<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>])</span><br><span class="line">print(<span class="string">"L1 = "</span> + str(L1(yhat,y)))<span class="comment">#L1 = 1.1</span></span><br></pre></td></tr></table></figure><hr><p><strong>练习</strong>：实施L2损失的Numpy矢量化版本。 有两种方法可以实现L2损失，但您可能会发现np.dot（）函数很有用。 提醒一下，如果$ x = [x_1，x_2，…，x_n] $，则<code>np.dot（x，x）</code>= $ \ sum_ {j = 0} ^ n x_j ^ {2} $。<br>$$<br>\begin{align<em>} &amp; L_2(\hat{y},y) = \sum_{i=0}^m(y^{(i)}  -\hat{y}^{(i)})^2\end{align</em>}\tag{7}<br>$$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">L2</span><span class="params">(yhat, y)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Arguments:</span></span><br><span class="line"><span class="string">    yhat -- vector of size m (predicted labels)</span></span><br><span class="line"><span class="string">    y -- vector of size m (true labels)</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">    loss -- the value of the L2 loss function defined above</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">### START CODE HERE ### (≈ 1 line of code)</span></span><br><span class="line">    loss = np.dot((y - yhat),(y - yhat).T)</span><br><span class="line">    <span class="comment">### END CODE HERE ###</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> loss</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yhat = np.array([<span class="number">.9</span>, <span class="number">0.2</span>, <span class="number">0.1</span>, <span class="number">.4</span>, <span class="number">.9</span>])</span><br><span class="line">y = np.array([<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>])</span><br><span class="line">print(<span class="string">"L2 = "</span> + str(L2(yhat,y)))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">L2 &#x3D; 0.43</span><br></pre></td></tr></table></figure><p><strong>注意事项：</strong>-向量化在深度学习中非常重要。 它提供了计算效率和清晰度。 -已查看L1和L2损失。 -您熟悉许多numpy函数，例如np.sum，np.dot，np.multiply，np.maximum等。</p>]]></content>
      
      
      <categories>
          
          <category> python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> numpy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MFC-QQ</title>
      <link href="/2020/01/14/MFC-QQ%E5%AE%9E%E7%8E%B0/"/>
      <url>/2020/01/14/MFC-QQ%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="MFC-QQ"><a href="#MFC-QQ" class="headerlink" title="MFC-QQ"></a>MFC-QQ</h1><p>采用MFC和套接字实现简单QQ</p><a id="more"></a><p><u>图片未来得及修改，GitHub可以正常观看</u></p><p>github源码地址：<a href="https://github.com/pxlsdz/MFC-QQ" target="_blank" rel="noopener">https://github.com/pxlsdz/MFC-QQ</a></p><p>合作者：WentongXu,dengdeng337(github账号）</p><table><thead><tr><th>网络编程课程设计报告 二О二О年 一月 十四日</th></tr></thead><tbody><tr><td></td></tr><tr><td></td></tr></tbody></table><p><strong>课程设计的目的及要求</strong></p><p>主要目的是巩固网络编程技术基本知识，加深对相关概念和原理的理解，提高综合应用所学知识开发较为实用的网络应用程序的能力。通过一个较为综合的网络应用程序的开发训练，加深学生对网络通信程序开发的基本方法、基本技术和基本概念以及相关原理的理解，同时进一步提高学生编写较为复杂应用程序的能力，为学生将来从事实际应用开发打下坚实的理论和实践基础。</p><p>要求第17周一周时间内集中在网络中心的指定机房内完成，逾期实在不能完成的可延期一周利用业余时间完成。结束后在规定时间前需提交：</p><p>1、课程设计报告。</p><p>2、所开发程序的源代码，要求程序能编译运行，且功能符合基本要求。</p><p><strong>课程设计内容</strong></p><p>利用所学的网络编程技术，独立完成一个较为复杂的实用型的网络应用程序的设计开发。可从以下各题中选择一个完成：</p><p>1、编写一个图形界面的网络嗅探软件，界面模仿WireShark，协议分析层次包括网络层、传输层、应用层（能识别出DNS、FTP和WEB等几种常见应用则可）。</p><p>2、模仿QQ完成一套即时通信软件。要求：①包含一个客户软件和一个服务器软件；服务器软件负责客户的注册、登陆、在线客户管理等；客户软件包含注册、登录、根据服务器返回的在线客户信息与在线的其他客户进行聊天等功能；②客户软件工作在P2P模式，所有客户均试运行同一个软件的不同副本，两个客户软件的聊天信息是直接发送给对方的，不能经由服务器转发；③客户软件和服务器软件均采用图形界面。</p><p>3、自选题目，满足：基于WinSock编程、功能实用且程序较为复杂。</p><h1 id="课程设计题目的选择"><a href="#课程设计题目的选择" class="headerlink" title="课程设计题目的选择"></a>课程设计题目的选择</h1><p>根据题目的要求以及实习时间，结合了三个人的个人能力，决定各取所需，发挥个人的优势，我们选择了比较有挑战性的题目：模仿<br>QQ 完成一套即时通信软件作为我们本次课设的目标。</p><h1 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h1><h2 id="2-1设计的背景"><a href="#2-1设计的背景" class="headerlink" title="2.1设计的背景"></a>2.1设计的背景</h2><p>计算机网络技术发展至今已经大大超越了人们当初的预想，无论是人们日常的工作还是学习，我们都越来越多的依靠到互联网。各种实时性的聊天娱乐软件也同时诞生，而且为我们的即时通讯带来了众多的方便，比如说大家所熟知的腾讯QQ、微软的MSN、移动的Fetion等，都是做的比较成功的实时聊天工具。随着网络的日益普及，各种聊天工具也层出不穷，但当我们学习了《windows网络编程》这门课程之后，我们便会觉得，其实要实现简单的网络通讯其实并不难。接下来的课程设计就是针对一个简单的网络聊天程序，利用MFC为开发工具，实现基本的通讯功能。</p><h2 id="2-2设计的原理"><a href="#2-2设计的原理" class="headerlink" title="2.2设计的原理"></a>2.2设计的原理</h2><p>此程序主要分为两部分：服务器端和客户端。服务器端用于提供一个网络端口，等待客户端发出请求，登录到此服务端，然后进行网络通讯和消息的转发；客户端可通过服务器端的IP地址发送连接请求，然后登陆聊天室。在服务器端的成员列表栏中会显示在线的所有人名单，有人退出聊天室，成员列表会自动除名。服务器端同时也提供了成员之间的私聊功能，此时服务器端作为一个转发站，进行消息的转发。</p><h2 id="2-3设计思路"><a href="#2-3设计思路" class="headerlink" title="2.3设计思路"></a>2.3设计思路</h2><p>服务端利用TCP保持服务器连接，UDP模拟QQ的P2P通信，</p><p>一些开始时候的准备工作：</p><p>我们用的是select模型中FD_sock管理这些套接字</p><p>我们的用户信息是在一个user.txt中存储的，所以一开始需要导入进来</p><p>之后我们就又设计的客户端，进行登陆、注册、聊天等功能。</p><h2 id="2-4设计的功能要求"><a href="#2-4设计的功能要求" class="headerlink" title="2.4设计的功能要求"></a>2.4设计的功能要求</h2><p>客户端：</p><blockquote><p>  QQ登陆页面主要包含：登陆账号、登陆密码、注册、设置</p></blockquote><blockquote><p>  注册页面：注册的账号、密码（账号不允许重复）</p></blockquote><p>服务端：</p><blockquote><p>  用TCP保持服务器连接，UDP模拟QQ的P2P通信</p></blockquote><h2 id="2-5运行环境"><a href="#2-5运行环境" class="headerlink" title="2.5运行环境"></a>2.5运行环境</h2><p>本系统运正常行的硬件环境需求如下：</p><p>标准Windows10 系统PC一台;</p><p>软件支持：Visual Studio 2017</p><h1 id="概要设计"><a href="#概要设计" class="headerlink" title="概要设计"></a>概要设计</h1><h2 id="3-1系统结构"><a href="#3-1系统结构" class="headerlink" title="3.1系统结构"></a>3.1系统结构</h2><ol><li>服务端</li></ol><blockquote><p>  通过套接字、TCP、UDP等，完成的字符界面的服务器，连接服务器端与客户端。</p></blockquote><ol><li>客户端</li></ol><blockquote><p>  基于MFC窗口的客户端，具有登录、注册、聊天等功能。</p></blockquote><h2 id="3-2程序流程图"><a href="#3-2程序流程图" class="headerlink" title="3.2程序流程图"></a>3.2程序流程图</h2><p><img src="media/706e44330d6639f153235948840f98f8.png" alt="未命名文件(G:/项目/MFCQQ最终版 - 副本/MFC-QQ/media/706e44330d6639f153235948840f98f8.png)"></p><h1 id="4详细设计与实现"><a href="#4详细设计与实现" class="headerlink" title="4详细设计与实现"></a>4详细设计与实现</h1><h2 id="4-1TCP作用"><a href="#4-1TCP作用" class="headerlink" title="4.1TCP作用"></a>4.1TCP作用</h2><p>TCP是用来在服务器和客户端之间通信的</p><p>链接会保持，客户端的登陆退出，注册和请求另一个人的IP都是通过TCP套接字</p><h2 id="4-2UDP的作用"><a href="#4-2UDP的作用" class="headerlink" title="4.2UDP的作用"></a>4.2UDP的作用</h2><p>UDP是用来模拟实现P2P客户端与客户端之间通讯的，中间服务器起任何作用。</p><h2 id="4-3传递的消息类型"><a href="#4-3传递的消息类型" class="headerlink" title="4.3传递的消息类型"></a>4.3传递的消息类型</h2><h3 id="4-3-1客户端与服务器之间传递的消息"><a href="#4-3-1客户端与服务器之间传递的消息" class="headerlink" title="4.3.1客户端与服务器之间传递的消息"></a>4.3.1客户端与服务器之间传递的消息</h3><p>struct UserInfo</p><p>{</p><p>int op;</p><p>char name[maxn], pwd[maxn];</p><p>char ip[maxn];</p><p>char online[50][maxn];</p><p>char remsg[maxn];</p><p>int listlen;</p><p>void getonline()</p><p>{</p><p>memset(online, ‘\0’, sizeof(online));</p><p>for (int i = 0; i &lt; userip.size(); i++)</p><p>{</p><p>strcpy(online[i], onlinelist[i]);</p><p>}</p><p>}</p><p>};</p><h4 id="4-3-1-1Op"><a href="#4-3-1-1Op" class="headerlink" title="4.3.1.1Op"></a>4.3.1.1Op</h4><p>Op的作用是区分当前的消息是什么类型的消息或者是这个消息要传递到什么地方的</p><h4 id="4-3-1-2Name-pwd"><a href="#4-3-1-2Name-pwd" class="headerlink" title="4.3.1.2Name pwd"></a>4.3.1.2Name pwd</h4><p>登陆或者是注册时候的账号和密码信息</p><h4 id="4-3-1-3Ip"><a href="#4-3-1-3Ip" class="headerlink" title="4.3.1.3Ip"></a>4.3.1.3Ip</h4><p>客户端请求其他客户端ip地址时 返回的ip</p><h4 id="4-3-1-4Onlinelist-listlen"><a href="#4-3-1-4Onlinelist-listlen" class="headerlink" title="4.3.1.4Onlinelist listlen"></a>4.3.1.4Onlinelist listlen</h4><p>在线用户的列表 和 在线用户的数量</p><h4 id="4-3-1-5Remsg"><a href="#4-3-1-5Remsg" class="headerlink" title="4.3.1.5Remsg"></a>4.3.1.5Remsg</h4><p>结构体携带的消息</p><h4 id="4-3-1-6Void-getonline（）"><a href="#4-3-1-6Void-getonline（）" class="headerlink" title="4.3.1.6Void getonline（）"></a>4.3.1.6Void getonline（）</h4><p>在服务器端获取在线的用户</p><h3 id="4-3-2客户端与客户端之间传递的消息"><a href="#4-3-2客户端与客户端之间传递的消息" class="headerlink" title="4.3.2客户端与客户端之间传递的消息"></a>4.3.2客户端与客户端之间传递的消息</h3><p>struct ChatMsg</p><p>{</p><p>int op;</p><p>short port;</p><p>char username[100];</p><p>char msg[1000];</p><p>};</p><h4 id="①Op"><a href="#①Op" class="headerlink" title="①Op"></a>①Op</h4><p>当前消息的作用（后续会提到）</p><h4 id="②Port"><a href="#②Port" class="headerlink" title="②Port"></a>②Port</h4><p>对方的端口号</p><h4 id="③Username-msg"><a href="#③Username-msg" class="headerlink" title="③Username msg"></a>③Username msg</h4><p>自己的用户名和自己要发给对方的消息</p><h2 id="4-4注册消息模块"><a href="#4-4注册消息模块" class="headerlink" title="4.4注册消息模块"></a>4.4注册消息模块</h2><h3 id="4-4-1注册消息模块"><a href="#4-4-1注册消息模块" class="headerlink" title="4.4.1注册消息模块"></a>4.4.1注册消息模块</h3><h4 id="①Ip地址问题"><a href="#①Ip地址问题" class="headerlink" title="①Ip地址问题"></a>①Ip地址问题</h4><p>当我们在登陆页面上写好了IP地址时候，那么这个IP地址会传递到注册页面上面，</p><h4 id="②注册时候"><a href="#②注册时候" class="headerlink" title="②注册时候"></a>②注册时候</h4><p>发送一个op为2的消息到服务器端，服务器端会根据当前保存的用户列表中是否存在相同的用户名来确定是否返回的消息<br>‘注册成功’ or ‘注册失败’.</p><p>消息发送给服务器端的监听套接字</p><h3 id="4-4-2登陆模块"><a href="#4-4-2登陆模块" class="headerlink" title="4.4.2登陆模块"></a>4.4.2登陆模块</h3><h4 id="4-4-2-1IP地址和端口号"><a href="#4-4-2-1IP地址和端口号" class="headerlink" title="4.4.2.1IP地址和端口号"></a>4.4.2.1IP地址和端口号</h4><p>Ip地址需要自己填写服务器的IP地址，因为我们每次登陆校园网或者是其他局域网络时都会改变</p><p>端口号是不需要填写的，因为我们已经制定好了</p><h4 id="4-4-2-2发送登陆和返回的消息"><a href="#4-4-2-2发送登陆和返回的消息" class="headerlink" title="4.4.2.2发送登陆和返回的消息"></a>4.4.2.2发送登陆和返回的消息</h4><h6 id="①发送登陆消息时候-op-1"><a href="#①发送登陆消息时候-op-1" class="headerlink" title="①发送登陆消息时候 op=1"></a>①发送登陆消息时候 op=1</h6><p>服务器端会判断是不是密码正确返回登陆成功or失败</p><h6 id="②服务器端返回的消息op-1"><a href="#②服务器端返回的消息op-1" class="headerlink" title="②服务器端返回的消息op=1"></a>②服务器端返回的消息op=1</h6><p>如果登陆成功会打开我们的list主列表模块并将与服务器端保持通讯的套接字传递过去</p><p>关键代码如下：if (userop == 1) //当前是登陆信息</p><p>{</p><p>string name = userinfo.name, pwd = userinfo.pwd;</p><p>UserInfo reinfo;</p><p>strcpy(reinfo.name , userinfo.name);</p><p>reinfo.op = 1;</p><p>memset(reinfo.remsg, 0, sizeof(reinfo.remsg));</p><p>if (userlog[name] == pwd)</p><p>{</p><p>char yes[10] = “yes”;</p><p>cout &lt;&lt; “用户：” &lt;&lt; name &lt;&lt; “ 登陆成功！” &lt;&lt; endl;</p><p>strcpy(reinfo.remsg, yes);</p><p>cout &lt;&lt; “回复消息：”&lt;&lt;reinfo.remsg &lt;&lt; endl;</p><p>userip[name] = inet_ntoa(client_addr.sin_addr);</p><p>/*****************************************************/</p><p>struct sockaddr_in sa;</p><p>if (!getpeername(newsock, (struct sockaddr *)&amp;sa, &amp;len))</p><p>{</p><p>printf(“对方IP：%s “, inet_ntoa(sa.sin_addr));</p><p>printf(“对方PORT：%d “, ntohs(sa.sin_port));</p><p>}</p><p>/******************************************************/</p><p>onlineupdate();</p><p>showuserlist();</p><p>reinfo.getonline();</p><p>// ***************************发送登陆成功信息</p><p>if ((size = send(newsock, (char *)&amp;reinfo, sizeof(reinfo), 0)) &lt; 0)</p><p>cout &lt;&lt; “发送信息失败！错误代码:” &lt;&lt; WSAGetLastError() &lt;&lt; endl;</p><p>else if (size == 0)</p><p>cout &lt;&lt; “对方已关闭连接！\n”;</p><p>//******************************************</p><p>cout &lt;&lt; “fd size:” &lt;&lt; fdsock.fd_count &lt;&lt; endl;</p><p>reinfo.op = 4;//回复消息;</p><p>for (int j = 0; j &lt; fdsock.fd_count; j++)</p><p>{</p><p>if (fdsock.fd_array[j] != sock_server &amp;&amp; j != i)</p><p>send(fdsock.fd_array[j], (char *)&amp;reinfo, sizeof(reinfo), 0);</p><p>}</p><p>FD_SET(newsock, &amp;fdsock);</p><p>}</p><p>else</p><p>{</p><p>strcpy(reinfo.remsg, “no”);</p><p>if ((size = send(newsock, (char *)&amp;reinfo, sizeof(reinfo), 0)) &lt; 0)</p><p>cout &lt;&lt; “发送信息失败！错误代码:” &lt;&lt; WSAGetLastError() &lt;&lt; endl;</p><p>else if (size == 0)</p><p>cout &lt;&lt; “对方已关闭连接！\n”;</p><p>closesocket(newsock);</p><p>}</p><p>}</p><h2 id="4-5List主列表模块"><a href="#4-5List主列表模块" class="headerlink" title="4.5List主列表模块"></a>4.5List主列表模块</h2><p>这个模块中有我们的在线用户的列表</p><p>关键代码：</p><p>void onlineupdate()</p><p>{</p><p>int i = 0;</p><p>iter = userip.begin();</p><p>len = 0;</p><p>while (iter != userip.end()) {</p><p>if (iter-&gt;second == “”)</p><p>{</p><p>iter++;</p><p>continue;</p><p>}</p><p>len++;</p><p>strcpy(onlinelist[i],zhuan(iter-&gt;first.data()));</p><p>cout &lt;&lt; “用户名：” &lt;&lt; iter-&gt;first &lt;&lt;“ IP地址：”&lt;&lt;iter-&gt;second&lt;&lt;<br>endl;</p><p>iter++;</p><p>i++;</p><p>}</p><p>cout &lt;&lt; “在线用户列表更新完成！” &lt;&lt; endl;</p><p>}</p><p><strong>①开启list时</strong></p><p>当我们登陆成功时，我们会打开list模块</p><p>这时，在一开始的oninit函数中会创建 用于监听有客户端想与我通信的消息</p><p>还会一开始导入一个onlinelist在线用户的列表（后续会更新）</p><p>![](G:/项目/MFCQQ最终版 - 副本/MFC-QQ/media/c253923683036556da2d3e495fefcafc.png)</p><p><strong>②List的维护</strong></p><p>主要是维护在线的列表。</p><p>有这样几个维护的时机 用户登陆，用户退出</p><p><strong>③用户登陆</strong></p><p>如果有某个用户登陆的时候<br>服务器发送一个op=4的消息给我们的TCP套接字，用来刷新在线的用户。</p><p><strong>④用户退出</strong></p><p>点击退出按钮的时候会先发送一个op=3的消息给服务器端，</p><p>这时候服务器端维护在线用户列表</p><p>当某个客户端的发送的消息size=0的时候说明链接已经断开，那么这时候我么广播一下这个用户列表</p><p>在FD_sock中删除</p><h2 id="4-6在线用户列表的操作"><a href="#4-6在线用户列表的操作" class="headerlink" title="4.6在线用户列表的操作"></a>4.6在线用户列表的操作</h2><p><strong>①双击某个用户</strong></p><p>当我们双击某个用户的时候这时候就会执行双击事件，执行的代码是我们想服务器端发送一个op=4的消息用于请求用户名对应的IP地址</p><p>先创建一个chat模块用户和对面通信，在打开的时候我们会申请一个端口号用于创建一个回话UDP套接字与对面通讯</p><p>然后发送一个消息给我们请求到的IP地址，这时候UDP套接字起到作用，其中一开始的用于监听的UDP套接字的端口号是固定的</p><p><strong>②List中的UDP套接字的作用</strong></p><p>当我们收到一个消息的时候，首先我们可以确定这个消息是有人想和我们通讯，</p><p>这时候我们打开一个chat模块，用于和用户通讯，chat模块可以多次打开</p><p>当我们打开一个chat模块的时候，会创建一个UDP套接字，对应的端口号会放在一个vector中，用一个find函数来找到我们还没有用过的端口号，</p><p>准备好了自身的端口号之后立刻向对方发送一个op=0的消息，</p><p>此时对方也就指的是他给我发送消息的端口号和IP地址</p><p>告诉对面我的端口号是XXX 之后我们就可以自由的通信了</p><h2 id="4-7Chat模块"><a href="#4-7Chat模块" class="headerlink" title="4.7Chat模块"></a>4.7Chat模块</h2><p>此时我们基本上已经把所有的p2p的准备工作做完，直接开始通信即可</p><h2 id="4-8服务器端"><a href="#4-8服务器端" class="headerlink" title="4.8服务器端"></a>4.8服务器端</h2><h3 id="①一些开始时候的准备工作"><a href="#①一些开始时候的准备工作" class="headerlink" title="①一些开始时候的准备工作"></a>①一些开始时候的准备工作</h3><p>我们用的是select模型中FD_sock管理这些套接字</p><p>我们的用户信息是在一个user.txt中存储的，所以一开始需要导入进来</p><p>![](G:/项目/MFCQQ最终版 - 副本/MFC-QQ/media/57d2e8b6db347d8d7479f8d8b5441a4c.png)</p><p>当我们导入完成的时候，就可以开始创建监听套接字并开始我们的工作了</p><p>关键代码如下：</p><p>void jieshu()</p><p>{</p><p>char name[maxn], pwd[maxn];</p><p>ofstream writeFile(“D://user.txt”);</p><p>iter = userlog.begin();</p><p>while (iter != userlog.end()) {</p><p>//cout &lt;&lt; iter-&gt;first &lt;&lt; “ : “ &lt;&lt; iter-&gt;second &lt;&lt; endl;</p><p>strcpy(name ,zhuan(iter-&gt;first)), strcpy(pwd ,zhuan(iter-&gt;second));</p><p>writeFile &lt;&lt; name &lt;&lt; “ “ &lt;&lt; pwd &lt;&lt; endl;</p><p>iter++;</p><p>}</p><p>cout &lt;&lt; “用户数据保存成功！” &lt;&lt; endl;</p><p>}</p><p>void init()</p><p>{</p><p>ifstream readFile(“D://user.txt”);</p><p>char temp[1024] = { 0 };</p><p>char name[maxn], pwd[maxn];</p><p>//char a[10000], b[10000];</p><p>while (readFile &gt;&gt;name &gt;&gt; pwd)</p><p>{</p><p>userlog[name] = pwd;</p><p>cout &lt;&lt; name &lt;&lt; “ “ &lt;&lt; pwd &lt;&lt; endl;</p><p>}</p><p>cout &lt;&lt; “用户数据导入成功！” &lt;&lt; endl;</p><p>}</p><h3 id="②op-1-接收登陆信息"><a href="#②op-1-接收登陆信息" class="headerlink" title="②op =1 接收登陆信息"></a>②op =1 接收登陆信息</h3><p>接受到登陆信息的时候我们判断user列表里面的用户名和密码是不是对得上</p><p>如果可以就发送一个yes的op=1的消息回去告诉客户端</p><p>并添加这个用户到onlinelist中</p><p>并转发op=4的消息广播到其他用户让他们更新在线列表</p><p>此时套接字发送完毕套接字保存在FD_sock 中</p><h3 id="③op-2-接收注册信息"><a href="#③op-2-接收注册信息" class="headerlink" title="③op =2 接收注册信息"></a>③op =2 接收注册信息</h3><p>判断是不是用户名重复不重复就是注册成功</p><p>更新user列表，并调用写会user.txt函数保存下来</p><p>返回一个op=2的消息，告诉客户端是不是注册成功</p><p>此时套接字发送完毕直接断开连接</p><h3 id="④op-3-接收注销信息"><a href="#④op-3-接收注销信息" class="headerlink" title="④op =3 接收注销信息"></a>④op =3 接收注销信息</h3><p>此时我们在onlinelist中去除掉携带的username 套接字不会在现在断开</p><h3 id="⑤op-4-接收用户请求ip信息"><a href="#⑤op-4-接收用户请求ip信息" class="headerlink" title="⑤op =4 接收用户请求ip信息"></a>⑤op =4 接收用户请求ip信息</h3><p>返回一个op=5的消息告诉他请求的那个用户的IP地址</p><h3 id="⑥接收到size-lt-0的消息"><a href="#⑥接收到size-lt-0的消息" class="headerlink" title="⑥接收到size&lt;=0的消息"></a>⑥接收到size&lt;=0的消息</h3><p>说明有用户退出了，这时候我们的在线用户列表在上次通讯的时候挤一挤创新完成，</p><p>这时候我们只需要先广播一个op=4的消息，并吧当前套接字在FD_sock中去除就可以了</p><h1 id="5-系统整体说明书"><a href="#5-系统整体说明书" class="headerlink" title="5.系统整体说明书"></a>5.系统整体说明书</h1><h2 id="5-1登陆界面"><a href="#5-1登陆界面" class="headerlink" title="5.1登陆界面"></a>5.1登陆界面</h2><p>我们仿照了QQ的登陆页面，有隐藏设置的选项，隐藏设置的端口号以及服务器端IP。</p><p>这里我们采用的默认IP地址127.0.0.1以及默认的端口号。</p><p>![](G:/项目/MFCQQ最终版 - 副本/MFC-QQ/media/d40df7ecce44210a71ac918a4ffd5548.png)</p><p>![](G:/项目/MFCQQ最终版 - 副本/MFC-QQ/media/d7e8fff8c25ca40ed75205550068bda9.png)</p><p>服务器端：</p><p>![](G:/项目/MFCQQ最终版 - 副本/MFC-QQ/media/c253923683036556da2d3e495fefcafc.png)</p><h2 id="5-2注册界面"><a href="#5-2注册界面" class="headerlink" title="5.2注册界面"></a>5.2注册界面</h2><p>![](G:/项目/MFCQQ最终版 - 副本/MFC-QQ/media/709afca1b7ea30403a667bdac2a4e59c.png)</p><p>服务器端：</p><p>![](G:/项目/MFCQQ最终版 - 副本/MFC-QQ/media/cae1561faf6c5e848f0c04e6d3707b7f.png)</p><h2 id="5-3好友列表界面"><a href="#5-3好友列表界面" class="headerlink" title="5.3好友列表界面"></a>5.3好友列表界面</h2><p>可以显示用户名以及在线好友列表，最小化、退出的功能。每个用户登陆时，都会更新好友列表。</p><p>![](G:/项目/MFCQQ最终版 - 副本/MFC-QQ/media/30d2968defb23d517618b9f18d17e850.png)</p><p>服务器端：</p><p>![](G:/项目/MFCQQ最终版 - 副本/MFC-QQ/media/c253923683036556da2d3e495fefcafc.png)</p><h2 id="5-4聊天界面"><a href="#5-4聊天界面" class="headerlink" title="5.4聊天界面"></a>5.4聊天界面</h2><p>两个在线好友之间可以实现端到端的通信。</p><p>![](G:/项目/MFCQQ最终版 - 副本/MFC-QQ/media/bf78f7c0df4f695e662c746a599c8c6a.png)</p><p>![](G:/项目/MFCQQ最终版 - 副本/MFC-QQ/media/6b1c30a284a883b95401e3b4743395a2.png)</p><p>服务器端：</p><p>![](G:/项目/MFCQQ最终版 - 副本/MFC-QQ/media/380cf96a89cb3cc6ef46dac5229cddd1.png)</p><h1 id="6-总结"><a href="#6-总结" class="headerlink" title="6.总结"></a>6.总结</h1><h2 id="6-1遇到的问题及不足"><a href="#6-1遇到的问题及不足" class="headerlink" title="6.1遇到的问题及不足"></a>6.1遇到的问题及不足</h2><h3 id="6-1-1遇到的问题"><a href="#6-1-1遇到的问题" class="headerlink" title="6.1.1遇到的问题"></a>6.1.1遇到的问题</h3><p>①问题：登陆的时候，在自己的电脑登陆成功，将代码完全拷贝到别人的电脑上，但登陆不成功，但在服务器端显示均为登陆成功？</p><p>问题分析与解决：在调试代码的时候，调用MessageBox()函数的时候在功能函数代码顶部加上莫名的登陆成功，后来，经指导教师指导，得知可能客户端还没来得及接受的服务器发来的消息，就执行if判断，导致客户端登陆不成功，调用Sleep()函数完美解决。</p><p>②问题：实现端对端的通信的时候，一开始图省事，想就用一个套接字解决端的端通信，即使用朋友列表对话框的套接字接受到消息，然后根据消息的用户名来放到相应的聊天对话框当中，不符实际（效率低下）且实现困难。</p><p>解决：实现苦难的原因，domodel（）函数不了解，使用过后会注销这个窗口，所有有消息来得到时候，我们调用ListBox函数控件的addString（）函数是不起作用的。我们改用CreatWindow()函数，但不知道为什么某名的出现闪现，于是，我们推翻了思路，重现采用一个聊天窗口一个套接字的思想，实现了可以多个窗口同时聊天的通信功能。</p><p>③问题：控件中的内容不能及时显示？</p><p>解决：及时调用UpdateData(TRUE)和UpdateData(FALSE)</p><h3 id="6-1-2不足"><a href="#6-1-2不足" class="headerlink" title="6.1.2不足"></a>6.1.2不足</h3><p>①因时间原因，我们只实现了部分的功能，还有很多可以尝试的功能未实现，例如：头像、聊天时的文件传输、发送表情或者图片，登陆时的记住密码、忘记密码以及自动登录的功能。</p><p>②界面设计较为仓促，没能较为精致的设计界面，服务器端也直接采用了字符型界面，未完成、采用MFC界面设计。</p><p>③因异步消息或者越界原因，本项目存在着一个问题，但是因为时间以及技术问题，还未能解决。在多个处理中，经常会弹出此页面。</p><p>![](G:/项目/MFCQQ最终版 - 副本/MFC-QQ/media/5239b821389e72f85868c63b5f713ab5.png)</p><p>④当出现问题时，比如注册失败出现异常，程序会陷入漫长的没有反应的状况。没有加异常处理。</p><p>⑤成员列表在非正常退出时，服务器端得不到及时而有效地更新；</p><p>⑥用户登录前必须先知道服务器端的IP，这样操作显然比较麻烦；</p><p>⑦聊天记录和好友列表的缓存机制待实现</p><p>⑧只采用了较简单的select()模型（服务器端）和异步套接字模型（客户端），在实际运用中存在效率问题。</p><h2 id="6-2个人总结"><a href="#6-2个人总结" class="headerlink" title="6.2个人总结"></a>6.2个人总结</h2><p>本次课程设计选了一个相对自己来说较难的，从霖开始一步步实现，确实有点费劲，有许多是自己考虑不到，比如，上面的不足的③和那个sleep()函数的添加，当时是卡了自己很久的错误。做这个的同时也体会到他是很有意思的，平常经常使用的QQ是有很多很多道道的，我们的项目比较简单只采用了较简单的select()模型（服务器端）和异步套接字模型（客户端），在实际运用中有这么多客户连接，同时发送和接受，腾讯是如何做到的效率很高的。还有就是其中的缓存机制，QQ好友列表的缓存机制是如何做到本体和服务器同步，尤其对消息对的缓存机制，QQ的服务器看来还是很强大的。本次实现的最大的困难就是实现多个对话窗口的聊天，端口如何高效的分配，这个应该和算法相关，我初步设想的是给定一个特定区间[l,r]的数，然后模拟并查集+字典就可实现删除和查找第一个可用的数即可，但这个算法的问题是不利于回收。还用明白了为啥要三次握手。总之，一步步实现对自己的收获还是很大的，以后需要多做项目，才能深刻的理解知识点和编程技巧，有机会还需要继续完善这个项目。</p><h1 id="7-附录"><a href="#7-附录" class="headerlink" title="7.附录"></a>7.附录</h1><h2 id="7-1ping程序原理"><a href="#7-1ping程序原理" class="headerlink" title="7.1ping程序原理"></a>7.1ping程序原理</h2><p>ping是通过ICMP协议实现的。Ping程序发送ICMP回送请求消息给目的主机，ICMP协议规定，目的主机必须返回ICMP回送应答消息给源主机。如果源主机在一定时间内收到应答，则认为主机可达。PING利用ICMP协议包来侦测另一个主机是否可达。原理是构造并发送多个类型码为8的ICMP回送请求包，其中用发送时的时间来填写时间戳字段，使用原始套接字发送给目的机器，收到ICMP回送请求包的目的主机则将收到的ICMP包用类型码改为0，重新计算校验和并替换后再封装到IP分组中发送回去作为回应。ping程序接收目的机器会送回来的ICMP回送响应包，并以此计算发送和接收之间的时间间隔，同时统计有多少个包被送达。用户依此就可以判断网络大致的情况。利用原始套接字编程可实现ping的功能，实现时需要定义好IP数据报、ICMP包等相关的数据结构。</p><h2 id="7-2ping程序设计大体流程"><a href="#7-2ping程序设计大体流程" class="headerlink" title="7.2ping程序设计大体流程"></a>7.2ping程序设计大体流程</h2><p>(1)从传给main函数的参数中读取目的地址</p><p>(2)设置套接字接收超时时间</p><p>(3)构造ICMP包</p><p>(4)计算校验和</p><p>(5)解析ICMP包</p><h2 id="7-3代码示例"><a href="#7-3代码示例" class="headerlink" title="7.3代码示例"></a>7.3代码示例</h2><p>// Ping.cpp : 定义控制台应用程序的入口点。</p><p>//</p><p>#include &lt;iostream&gt;</p><p>#include &lt;winsock2.h&gt;</p><p>#pragma comment(lib, “WS2_32”)</p><p>#define DATALEN 1012</p><p>#define PACKAGENUM 10 //发送ICMP会从请求报文的个数</p><p>using namespace std;</p><p>/***定义ICMP包结构***/</p><p>typedef struct icmp_hdr</p><p>{</p><p>unsigned char icmp_type; // ICMP包类型</p><p>unsigned char icmp_code; // 代码</p><p>unsigned short icmp_checksum; // 校验和</p><p>unsigned short icmp_id; // 惟一确定此请求的标识，通常设置为进程ID</p><p>unsigned short icmp_sequence; // 序列号</p><p>unsigned long icmp_timestamp; // 时间戳</p><p>} IcmpHeader;</p><p>unsigned short checksum(unsigned short* buff, int size); //校验和计算函数的声明</p><p>int main(int argc, char *argv[])</p><p>{</p><p>/***加载Winsock2.2***/</p><p>WSADATA wsaData;</p><p>int ret;</p><p>if ((ret = WSAStartup(MAKEWORD(1, 0), &amp;wsaData)) != 0)</p><p>{</p><p>cout &lt;&lt; “初始化WinSock2.2出错!”;</p><p>exit(0);</p><p>}</p><p>char szDestIp[256] = { 0 };//存放要Ping的IP地址或域名</p><p>//检查ping命令的使用格式是否正确，程序调试时可用后面的代码替换</p><p>/*if (argc &lt; 2)</p><p>{</p><p>cout&lt;&lt;“\n用法: ping IP地址|域名\n”;</p><p>return -1;</p><p>}</p><p>strcpy(szDestIp,argv[1]);*/</p><p>/***输入对方IP地址，调试程序时使用***/</p><p>cout &lt;&lt; “请输入你要Ping的IP地址…\n”;</p><p>cin.getline(szDestIp, sizeof(szDestIp));</p><p>/***将点分十进制IP地址转换为32位二进制表示的IP地址***/</p><p>unsigned long ulDestIP = inet_addr(szDestIp);</p><p>/****转换不成功时按域名解析****/</p><p>if (ulDestIP == INADDR_NONE)</p><p>{</p><p>hostent* pHostent = gethostbyname(szDestIp);</p><p>if (pHostent != NULL)</p><p>ulDestIP = (*(in_addr*)pHostent-&gt;h_addr).s_addr;</p><p>else //解析主机名失败</p><p>{</p><p>cout &lt;&lt; “域名解析失败：” &lt;&lt; argv[1] &lt;&lt; “错误码:” &lt;&lt; WSAGetLastError()<br>&lt;&lt; endl;</p><p>WSACleanup();</p><p>return -1;</p><p>}</p><p>}</p><p>/**** 创建收发ICMP包的原始套接字***/</p><p>SOCKET sRaw = socket(AF_INET, SOCK_RAW, IPPROTO_ICMP);</p><p>/***设置接收超时时间***/</p><p>int nTime = 1000;</p><p>ret = setsockopt(sRaw, SOL_SOCKET, SO_RCVTIMEO, (char*)&amp;nTime, sizeof(nTime));</p><p>if (ret == SOCKET_ERROR)</p><p>{</p><p>cout &lt;&lt; “套接字选项设置出错!错误码:” &lt;&lt; WSAGetLastError() &lt;&lt; endl;</p><p>return -1;;</p><p>}</p><p>/***设置ICMP包发送的目的地址***/</p><p>SOCKADDR_IN dest;</p><p>dest.sin_family = AF_INET;</p><p>dest.sin_port = htons(0);</p><p>dest.sin_addr.S_un.S_addr = ulDestIP;</p><p>/***创建ICMP包***/</p><p>char buff[sizeof(IcmpHeader) + DATALEN];</p><p>IcmpHeader* pIcmp = (IcmpHeader*)buff;</p><p>/***填写ICMP包数据***/</p><p>pIcmp-&gt;icmp_type = 8; // ICMP回送请求</p><p>pIcmp-&gt;icmp_code = 0;</p><p>pIcmp-&gt;icmp_id = (unsigned short)GetCurrentProcessId();//获取进程号作为ID</p><p>pIcmp-&gt;icmp_timestamp = 0; //时间戳暂设置为0，具体值发送时再填</p><p>pIcmp-&gt;icmp_checksum = 0; //校验和在计算前应先设置为0</p><p>pIcmp-&gt;icmp_sequence = 0; //初始序列号</p><p>/***填充数据部分，可以为任意***/</p><p>memset(&amp;buff[sizeof(IcmpHeader)], ‘A’, DATALEN);</p><p>/***调用connect()函数为原始套接字指定通信对端地址***/</p><p>connect(sRaw, (SOCKADDR *)&amp;dest, sizeof(dest));</p><p>/***收发ICMP报文***/</p><p>int n = 0;</p><p>bool bTimeout;</p><p>unsigned short nSeq = 0;//发送的ICMP报文的序号</p><p>char recvBuf[32 + DATALEN];//定义接收缓冲区</p><p>SOCKADDR_IN from; //保存收到的数据的源地址</p><p>int nLen = sizeof(from); //地址长度</p><p>IcmpHeader* pRecvIcmp; //指向ICMP报文首部的指针</p><p>while (TRUE)</p><p>{</p><p>static int nCount = 0;</p><p>int nRet;</p><p>if (nCount++ == PACKAGENUM)</p><p>break;</p><p>/***填写发送前才能填写的一些字段并发送ICMP包***/</p><p>pIcmp-&gt;icmp_checksum = 0;</p><p>pIcmp-&gt;icmp_timestamp = GetTickCount();//时间戳</p><p>pIcmp-&gt;icmp_sequence = nSeq++; //包序号</p><p>pIcmp-&gt;icmp_checksum = checksum((unsigned short*)buff, sizeof(IcmpHeader) +<br>DATALEN);</p><p>nRet = send(sRaw, buff, sizeof(IcmpHeader) + DATALEN, 0);</p><p>if (nRet == SOCKET_ERROR)</p><p>{</p><p>cout &lt;&lt; “发送失败!错误码:” &lt;&lt; WSAGetLastError() &lt;&lt; endl;</p><p>closesocket(sRaw);</p><p>WSACleanup();</p><p>return -1;</p><p>}</p><p>//接收对方返回的ICMP应答</p><p>bTimeout = FALSE;</p><p>n = 0;</p><p>do {</p><p>n++;//接收预期ICMP应答报文的尝试次数加1</p><p>memset((void *)recvBuf, 0, sizeof(recvBuf));</p><p>nRet = recvfrom(sRaw, recvBuf, sizeof(recvBuf), 0, (sockaddr*)&amp;from, &amp;nLen);</p><p>if (nRet == SOCKET_ERROR)</p><p>{</p><p>if (WSAGetLastError() == WSAETIMEDOUT)</p><p>{</p><p>cout &lt;&lt; “ timed out!\n”;</p><p>bTimeout = TRUE; //接收时间超时</p><p>break;</p><p>}</p><p>cout &lt;&lt; “接收失败!错误码:” &lt;&lt; WSAGetLastError() &lt;&lt; endl;</p><p>return -1;</p><p>}</p><p>pRecvIcmp = (IcmpHeader*)(recvBuf + 20);</p><p>//收到的数据包含20个字节的IP首部，加20才是ICMP首部位置</p><p>if (pRecvIcmp-&gt;icmp_id != GetCurrentProcessId())</p><p>//收到报文是否为本程序发送的请求报文的应答报文</p><p>{</p><p>//不是则重新接收</p><p>cout &lt;&lt; “ 收到一个非预期的ICMP报文，忽略！\n”;</p><p>}</p><p>else //是则退出循环</p><p>break;</p><p>} while (n &lt; 10);//重新接收次数不超过10则继续重试</p><p>if (n &gt; 10)// 收到太多非预期的ICMP报文则退出</p><p>{</p><p>cout &lt;&lt; “对方机器向本机发送了太多的ICMP报文.\n”;</p><p>closesocket(sRaw);</p><p>WSACleanup();</p><p>return -1;</p><p>}</p><p>if (bTimeout)continue; //接收超时则发送下一个ICPM报文</p><p>/****解析接收到的ICMP包****/</p><p>int nTick = GetTickCount();</p><p>if (nRet &lt; 20 + sizeof(IcmpHeader)) //收到的报文长度不足则不予解析</p><p>{</p><p>cout &lt;&lt; “Too few bytes from” &lt;&lt; inet_ntoa(from.sin_addr) &lt;&lt; endl;</p><p>continue;</p><p>}</p><p>else</p><p>{</p><p>//解析收到报文</p><p>cout &lt;&lt; nRet &lt;&lt; “ bytes from :” &lt;&lt; inet_ntoa(from.sin_addr);</p><p>cout &lt;&lt; “ icmp_seq = “ &lt;&lt; pRecvIcmp-&gt;icmp_sequence;</p><p>cout &lt;&lt; “ time:” &lt;&lt; nTick - pRecvIcmp-&gt;icmp_timestamp &lt;&lt; “ ms \n”;</p><p>Sleep(1000); //延时1秒再发送下一个数据包</p><p>}</p><p>}</p><p>closesocket(sRaw);</p><p>WSACleanup();</p><p>return 0;</p><p>}</p><p>/*************计算校验和的函数***************/</p><p>unsigned short checksum(unsigned short* buff, int size)</p><p>{</p><p>unsigned long cksum = 0;</p><p>while (size &gt; 1)</p><p>{</p><p>cksum += *buff++;</p><p>size -= sizeof(unsigned short);</p><p>}</p><p>if (size)// 是奇数</p><p>cksum += *(char*)buff;</p><p>//将32位的chsum高16位和低16位相加然后取反</p><p>cksum = (cksum &gt;&gt; 16) + (cksum &amp; 0xffff);</p><p>cksum += (cksum &gt;&gt; 16);</p><p>return (unsigned short)(~cksum);</p><p>}</p>]]></content>
      
      
      <categories>
          
          <category> 网络编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>吴恩达课后编程作业 Course 1 神经网络和深度学习 - 第二周作业 - 具有神经网络思维的Logistic回归</title>
      <link href="/2020/01/14/%E5%90%B4%E6%81%A9%E8%BE%BE%E8%AF%BE%E5%90%8E%E7%BC%96%E7%A8%8B%E4%BD%9C%E4%B8%9A-Course-1-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%92%8C%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E4%BA%8C%E5%91%A8%E4%BD%9C%E4%B8%9A-%E5%85%B7%E6%9C%89%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%80%9D%E7%BB%B4%E7%9A%84Logistic%E5%9B%9E%E5%BD%92/"/>
      <url>/2020/01/14/%E5%90%B4%E6%81%A9%E8%BE%BE%E8%AF%BE%E5%90%8E%E7%BC%96%E7%A8%8B%E4%BD%9C%E4%B8%9A-Course-1-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%92%8C%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E4%BA%8C%E5%91%A8%E4%BD%9C%E4%B8%9A-%E5%85%B7%E6%9C%89%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%80%9D%E7%BB%B4%E7%9A%84Logistic%E5%9B%9E%E5%BD%92/</url>
      
        <content type="html"><![CDATA[<h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a><strong>任务</strong></h2><p>搭建一个能够<strong>【识别猫】</strong> 的简单的神经网络。</p><a id="more"></a><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><p>在开始之前，我们有需要引入的库：</p><ul><li>numpy ：是用Python进行科学计算的基本软件包。</li></ul><ul><li>h5py：是与H5文件中存储的数据集进行交互的常用软件包。</li></ul><ul><li><p>matplotlib：是一个著名的库，用于在Python中绘制图表。</p></li><li><p>lr_utils ：在本文的资料包里，一个加载资料包里面的数据的简单功能的库。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> h5py</span><br><span class="line"><span class="keyword">from</span> lr_utils <span class="keyword">import</span> load_dataset</span><br></pre></td></tr></table></figure><p><code>lr_utils.py</code>代码如下，自行打开它查看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> h5py</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_dataset</span><span class="params">()</span>:</span></span><br><span class="line">    train_dataset = h5py.File(<span class="string">'datasets/train_catvnoncat.h5'</span>, <span class="string">"r"</span>)</span><br><span class="line">    train_set_x_orig = np.array(train_dataset[<span class="string">"train_set_x"</span>][:]) <span class="comment"># your train set features</span></span><br><span class="line">    train_set_y_orig = np.array(train_dataset[<span class="string">"train_set_y"</span>][:]) <span class="comment"># your train set labels</span></span><br><span class="line"></span><br><span class="line">    test_dataset = h5py.File(<span class="string">'datasets/test_catvnoncat.h5'</span>, <span class="string">"r"</span>)</span><br><span class="line">    test_set_x_orig = np.array(test_dataset[<span class="string">"test_set_x"</span>][:]) <span class="comment"># your test set features</span></span><br><span class="line">    test_set_y_orig = np.array(test_dataset[<span class="string">"test_set_y"</span>][:]) <span class="comment"># your test set labels</span></span><br><span class="line"></span><br><span class="line">    classes = np.array(test_dataset[<span class="string">"list_classes"</span>][:]) <span class="comment"># the list of classes</span></span><br><span class="line">    </span><br><span class="line">    train_set_y_orig = train_set_y_orig.reshape((<span class="number">1</span>, train_set_y_orig.shape[<span class="number">0</span>]))</span><br><span class="line">    test_set_y_orig = test_set_y_orig.reshape((<span class="number">1</span>, test_set_y_orig.shape[<span class="number">0</span>]))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> train_set_x_orig, train_set_y_orig, test_set_x_orig, test_set_y_orig, classes</span><br></pre></td></tr></table></figure><p>解释以下上面的load_dataset() 返回的值的含义：</p><ul><li>train_set_x_orig ：保存的是训练集里面的图像数据（本训练集有209张64x64的图像）。</li><li>train_set_y_orig ：保存的是训练集的图像对应的分类值（【0 | 1】，0表示不是猫，1表示是猫）。</li><li>test_set_x_orig ：保存的是测试集里面的图像数据（本训练集有50张64x64的图像）。</li><li>test_set_y_orig ： 保存的是测试集的图像对应的分类值（【0 | 1】，0表示不是猫，1表示是猫）。</li><li>classes ： 保存的是以bytes类型保存的两个字符串数据，数据为：[b’non-cat’    b’cat’]。</li></ul><hr><p>现在我们就要把这些数据加载到主程序里面：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">train_set_x_orig , train_set_y , test_set_x_orig , test_set_y , classes = load_dataset()</span><br></pre></td></tr></table></figure><p>查看</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">index = <span class="number">26</span></span><br><span class="line">plt.imshow(train_set_x_orig[index])</span><br><span class="line">print(<span class="string">"train_set_y"</span>+str(train_set_y))<span class="comment">#训练集标签</span></span><br></pre></td></tr></table></figure><p>图片</p><p><img src="https://raw.githubusercontent.com/pxlsdz/MarkDown-images/master/2020-1-16/download.png" alt=""></p><p><em>注释：squeeze的用法</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#np.squeeze的用法</span></span><br><span class="line">x = np.array([[[<span class="number">0</span>], [<span class="number">1</span>], [<span class="number">2</span>]]])</span><br><span class="line">print(x)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">x=</span></span><br><span class="line"><span class="string">[[[0]</span></span><br><span class="line"><span class="string">  [1]</span></span><br><span class="line"><span class="string">  [2]]]</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">print(x.shape)  <span class="comment"># (1, 3, 1)</span></span><br><span class="line">x1 = np.squeeze(x)  <span class="comment"># 从数组的形状中删除单维条目，即把shape中为1的维度去掉</span></span><br><span class="line">print(x1)  <span class="comment"># [0 1 2]</span></span><br><span class="line">print(x1.shape)  <span class="comment"># (3,)</span></span><br></pre></td></tr></table></figure><p>训练集里面的数据来看一下加载了一些什么东西</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#打印出当前的训练标签值</span></span><br><span class="line"><span class="comment">#使用np.squeeze的目的是压缩维度，</span></span><br><span class="line"><span class="comment">#【未压缩】train_set_y[:,index]的值为[1] ,</span></span><br><span class="line"><span class="comment">#【压缩后】np.squeeze(train_set_y[:,index])的值为1</span></span><br><span class="line"><span class="comment">#print("【使用np.squeeze：" + str(np.squeeze(train_set_y[:,index])) + "，不使用np.squeeze： " + str(train_set_y[:,index]) + "】")</span></span><br><span class="line"><span class="comment">#只有压缩后的值才能进行解码操作</span></span><br><span class="line">print(<span class="string">"y="</span> + str(train_set_y[:,index]) + <span class="string">", it's a "</span> + classes[np.squeeze(train_set_y[:,index])].decode(<span class="string">"utf-8"</span>) + <span class="string">"' picture"</span>)</span><br><span class="line"><span class="comment"># X[:,1] 就是取所有行的第1个数据</span></span><br><span class="line"><span class="comment">#X[1,:]即取第一维中下标为1的元素的所有值</span></span><br></pre></td></tr></table></figure><p>打印出的结果是：<strong>y=[1], it’s a cat’ picture</strong>，</p><p>加载的图像数据集具体情况,对以下参数做出解释：</p><ul><li>m_train ：训练集里图片的数量。</li><li>m_test ：测试集里图片的数量。</li><li>num_px ： 训练、测试集里面的图片的宽度和高度（均为64x64）。</li></ul><p>train_set_x_orig 是一个维度为(m_train，num_px，num_px，3）的数组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">m_train = train_set_y.shape[<span class="number">1</span>] <span class="comment">#训练集里图片的数量。</span></span><br><span class="line">m_test = test_set_y.shape[<span class="number">1</span>] <span class="comment">#测试集里图片的数量。</span></span><br><span class="line">num_px = train_set_x_orig.shape[<span class="number">1</span>] <span class="comment">#训练、测试集里面的图片的宽度和高度（均为64x64）。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#现在看一看我们加载的东西的具体情况</span></span><br><span class="line"><span class="keyword">print</span> (<span class="string">"训练集的数量: m_train = "</span> + str(m_train))</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"测试集的数量 : m_test = "</span> + str(m_test))</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"每张图片的宽/高 : num_px = "</span> + str(num_px))</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"每张图片的大小 : ("</span> + str(num_px) + <span class="string">", "</span> + str(num_px) + <span class="string">", 3)"</span>)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"训练集_图片的维数 : "</span> + str(train_set_x_orig.shape))</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"训练集_标签的维数 : "</span> + str(train_set_y.shape))</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"测试集_图片的维数: "</span> + str(test_set_x_orig.shape))</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"测试集_标签的维数: "</span> + str(test_set_y.shape))</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">训练集的数量: m_train = <span class="number">209</span></span><br><span class="line">测试集的数量 : m_test = <span class="number">50</span></span><br><span class="line">每张图片的宽/高 : num_px = <span class="number">64</span></span><br><span class="line">每张图片的大小 : (<span class="number">64</span>, <span class="number">64</span>, <span class="number">3</span>)</span><br><span class="line">训练集_图片的维数 : (<span class="number">209</span>, <span class="number">64</span>, <span class="number">64</span>, <span class="number">3</span>)</span><br><span class="line">训练集_标签的维数 : (<span class="number">1</span>, <span class="number">209</span>)</span><br><span class="line">测试集_图片的维数: (<span class="number">50</span>, <span class="number">64</span>, <span class="number">64</span>, <span class="number">3</span>)</span><br><span class="line">测试集_标签的维数: (<span class="number">1</span>, <span class="number">50</span>)</span><br></pre></td></tr></table></figure><p>为了方便，我们要把维度为（64，64，3）的numpy数组重新构造为（64 x 64 x 3，1）的数组，要乘以3的原因是每张图片是由64x64像素构成的，而每个像素点由（R，G，B）三原色构成的，所以要乘以3。在此之后，我们的训练和测试数据集是一个numpy数组，【每列代表一个平坦的图像】 ，应该有m_train和m_test列。</p><p>想将形状（a，b，c，d）的矩阵X平铺成形状（b * c * d，a）的矩阵X_flatten时，可以使用以下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#X_flatten = X.reshape(X.shape [0]，-1).T ＃X.T是X的转置</span></span><br><span class="line"><span class="comment">#将训练集的维度降低并转置。</span></span><br><span class="line">train_set_x_flatten  = train_set_x_orig.reshape(train_set_x_orig.shape[<span class="number">0</span>],<span class="number">-1</span>).T</span><br><span class="line"><span class="comment">#将测试集的维度降低并转置。</span></span><br><span class="line">test_set_x_flatten = test_set_x_orig.reshape(test_set_x_orig.shape[<span class="number">0</span>], <span class="number">-1</span>).T</span><br></pre></td></tr></table></figure><p>把数组变为209行的矩阵（因为训练集里有209张图片），-1告诉程序自己算多少列，最后程序算出来时12288列，最后用一个T表示转置，这就变成了12288行，209列。测试集亦如此。</p><p>降维之后的结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> (<span class="string">"训练集降维最后的维度： "</span> + str(train_set_x_flatten.shape))</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"训练集_标签的维数 : "</span> + str(train_set_y.shape))</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"测试集降维之后的维度: "</span> + str(test_set_x_flatten.shape))</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"测试集_标签的维数 : "</span> + str(test_set_y.shape))</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">训练集降维最后的维度： (<span class="number">12288</span>, <span class="number">209</span>)</span><br><span class="line">训练集_标签的维数 : (<span class="number">1</span>, <span class="number">209</span>)</span><br><span class="line">测试集降维之后的维度: (<span class="number">12288</span>, <span class="number">50</span>)</span><br><span class="line">测试集_标签的维数 : (<span class="number">1</span>, <span class="number">50</span>)</span><br></pre></td></tr></table></figure><hr><p>为了表示彩色图像，必须为每个像素指定红色，绿色和蓝色通道（RGB），因此像素值实际上是从0到255范围内的三个数字的向量。机器学习中一个常见的预处理步骤是对数据集进行居中和标准化，这意味着可以减去每个示例中整个numpy数组的平均值，然后将每个示例除以整个numpy数组的标准偏差。但对于图片数据集，它更简单，更方便，几乎可以将数据集的每一行除以255（像素通道的最大值），因为在RGB中不存在比255大的数据，所以我们可以放心的除以255，让标准化的数据位于[0,1]之间，现在标准化我们的数据集：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">train_set_x = train_set_x_flatten / <span class="number">255</span></span><br><span class="line">test_set_x = test_set_x_flatten / <span class="number">255</span></span><br></pre></td></tr></table></figure><p>模型图解：</p><p><img src="https://raw.githubusercontent.com/pxlsdz/MarkDown-images/master/LogReg_kiank.png" alt=""></p><hr><p>加载的数据弄完了，我们现在开始构建神经网络</p><p>数学公式：<br>$$<br>z^{(i)} = W^Tx^{(i)} + b\tag{1}<br>$$</p><p>$$<br>\hat{y}^{(i)} = a^{(i)} = sigmoid(z^{(i)})\tag{2}<br>$$</p><p>$$<br>\mathcal{L}(a^{(i)},y^{(i)}) = -y^{(i)}log(a^{(i)})-(1-y^{(i)})log(1-a^{(i)})\tag{3}<br>$$</p><p>通过对所有训练样例求和来计算成本:<br>$$<br>J = \frac{1}{m} \sum_{i=1}^mL(a^{(i)},y^{(i)})\tag{4}<br>$$<br>建立神经网络的主要步骤是：</p><ol><li><p>定义模型结构（例如输入特征的数量）</p></li><li><p>初始化模型的参数</p></li><li><p>循环：</p><p>3.1 计算当前损失（正向传播）</p><p>3.2 计算当前梯度（反向传播）</p><p>3.3 更新参数（梯度下降）</p></li></ol><p>现在构建<code>sigmoid()</code>，需要使用 <code>sigmoid（w ^ T x + b）</code> 计算来做出预测。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sigmoid</span><span class="params">(z)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    参数：</span></span><br><span class="line"><span class="string">        z  - 任何大小的标量或numpy数组。</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    返回：</span></span><br><span class="line"><span class="string">        s  -  sigmoid（z）</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    s = <span class="number">1</span> / (<span class="number">1</span> + np.exp(-z))</span><br><span class="line">    <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#测试sigmoid()</span></span><br><span class="line">print(<span class="string">"====================测试sigmoid===================="</span>)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"sigmoid(0) = "</span> + str(sigmoid(<span class="number">0</span>)))</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"sigmoid(9.2) = "</span> + str(sigmoid(<span class="number">9.2</span>)))</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"sigmoid([0, 2]) = "</span> + str(sigmoid(np.array([<span class="number">0</span>,<span class="number">2</span>]))))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;测试sigmoid&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">sigmoid(0) &#x3D; 0.5</span><br><span class="line">sigmoid(9.2) &#x3D; 0.9998989708060922</span><br><span class="line">sigmoid([0, 2]) &#x3D; [ 0.5         0.88079708]</span><br></pre></td></tr></table></figure><p>既然sigmoid测试好了，我们现在就可以初始化我们需要的参数w和b了。</p><p>​        </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">initialize_with_zeros</span><span class="params">(dim)</span>:</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">        此函数为w创建一个维度为（dim，1）的0向量，并将b初始化为0。</span></span><br><span class="line"><span class="string">    参数：</span></span><br><span class="line"><span class="string">        dim  - 我们想要的w矢量的大小（或者这种情况下的参数数量）</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    返回：</span></span><br><span class="line"><span class="string">        w  - 维度为（dim，1）的初始化向量。</span></span><br><span class="line"><span class="string">        b  - 初始化的标量（对应于偏差）</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">w = np.zeros(shape = (dim,<span class="number">1</span>))</span><br><span class="line">b = <span class="number">0</span></span><br><span class="line"><span class="comment">#使用断言来确保我要的数据是正确的</span></span><br><span class="line"><span class="keyword">assert</span>(w.shape == (dim, <span class="number">1</span>)) <span class="comment">#w的维度是(dim,1)</span></span><br><span class="line"><span class="keyword">assert</span>(isinstance(b, float) <span class="keyword">or</span> isinstance(b, int)) <span class="comment">#b的类型是float或者是int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (w , b)</span><br></pre></td></tr></table></figure><p>初始化参数的函数已经构建好了，现在就可以执行“前向”和“后向”传播步骤来学习参数。</p><p>我们现在要实现一个计算成本函数及其渐变的函数propagate（）。</p><p>看一下求导过程：</p><p>假设样本只有两个特征${x}<em>{1}$和${x}</em>{2}$，为了计算$z$，我们需要输入参数${w}<em>{1}$、${w}</em>{2}$ 和$b$，除此之外还有特征值${x}<em>{1}$和${x}</em>{2}$。因此$z$的计算公式为：<br>$z={w}<em>{1}{x}</em>{1}+{w}<em>{2}{x}</em>{2}+b$<br>回想一下逻辑回归的公式定义如下：<br>$\hat{y}=a=\sigma (z)$<br>其中$z={w}^{T}x+b$<br>$\sigma \left( z \right)=\frac{1}{1+{e}^{-z}}$<br>损失函数：<br>$\hat{y}^{(i)} = a^{(i)} = sigmoid(z^{(i)})$</p><p>代价函数：</p><p>$ \mathcal{L}(a^{(i)}, y^{(i)}) =  - y^{(i)}  \log(a^{(i)}) - (1-y^{(i)} )  \log(1-a^{(i)})$</p><p>假设现在只考虑单个样本的情况，单个样本的代价函数定义如下：<br>$L(a,y)=-(y\log (a)+(1-y)\log (1-a))$<br>其中$a$是逻辑回归的输出，$y$是样本的标签值。</p><p>通过微积分得到：<br>$\frac{dL(a,y)}{da}=-y/a+(1-y)/(1-a)$<br>因为$\frac{dL(a,y)}{dz}=\frac{dL}{dz}=(\frac{dL}{da})\cdot (\frac{da}{dz})$，<br>并且$\frac{da}{dz}=a\cdot (1-a)$，<br>而 $\frac{dL}{da}=(-\frac{y}{a}+\frac{(1-y)}{(1-a)})$，因此将这两项相乘，得到：</p><p>$ \frac{dL}{dz} = \left( \frac{dL}{da} \right) \cdot \left(\frac{da}{dz} \right) = ( - \frac{y}{a} + \frac{(1 - y)}{(1 - a)})\cdot a(1 - a) = a - y$</p><p>因此</p><p>$d{w}= \frac{dL}{dz}\frac{dz}{dw}=\frac{1}{m} \sum\limits_{i}^{m} x^{(i)}({a}^{(i)}-{y}^{(i)})$ </p><p>或者：$\frac{\partial J}{\partial w} = \frac{1}{m}X(A-Y)^T$</p><p>$db=dz=\frac{1}{m}\sum \limits_{i=1}^{m}(a^{(i)}-y^{(i)})$</p><p>目标是通过最小化成本函数 J来学习 w和b 。对于参数 $\theta$，更新规则是 $ \theta = \theta - \alpha \text{ } d\theta$，其中 α 是学习率。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">propagate</span><span class="params">(w, b, X, Y)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    实现前向和后向传播的成本函数及其梯度。</span></span><br><span class="line"><span class="string">    参数：</span></span><br><span class="line"><span class="string">        w  - 权重，大小不等的数组（num_px * num_px * 3，1）</span></span><br><span class="line"><span class="string">        b  - 偏差，一个标量</span></span><br><span class="line"><span class="string">        X  - 矩阵类型为（num_px * num_px * 3，训练数量）</span></span><br><span class="line"><span class="string">        Y  - 真正的“标签”矢量（如果非猫则为0，如果是猫则为1），矩阵维度为(1,训练数据数量)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    返回：</span></span><br><span class="line"><span class="string">        cost- 逻辑回归的负对数似然成本</span></span><br><span class="line"><span class="string">        dw  - 相对于w的损失梯度，因此与w相同的形状</span></span><br><span class="line"><span class="string">        db  - 相对于b的损失梯度，因此与b的形状相同</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    m = X.shape[<span class="number">1</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#正向传播</span></span><br><span class="line">    A = sigmoid(np.dot(w.T,X) + b) <span class="comment">#计算激活值，请参考公式2。</span></span><br><span class="line">    cost = (- <span class="number">1</span> / m) * np.sum(Y * np.log(A) + (<span class="number">1</span> - Y) * (np.log(<span class="number">1</span> - A))) <span class="comment">#计算成本，请参考公式3和4。</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#反向传播</span></span><br><span class="line">    dw = (<span class="number">1</span> / m) * np.dot(X, (A - Y).T) <span class="comment">#请参考视频中的偏导公式。</span></span><br><span class="line">    db = (<span class="number">1</span> / m) * np.sum(A - Y) <span class="comment">#请参考视频中的偏导公式。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#使用断言确保我的数据是正确的</span></span><br><span class="line">    <span class="keyword">assert</span>(dw.shape == w.shape)</span><br><span class="line">    <span class="keyword">assert</span>(db.dtype == float)</span><br><span class="line">    cost = np.squeeze(cost)</span><br><span class="line">    <span class="keyword">assert</span>(cost.shape == ())</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#创建一个字典，把dw和db保存起来。</span></span><br><span class="line">    grads = &#123;</span><br><span class="line">                <span class="string">"dw"</span>: dw,</span><br><span class="line">                <span class="string">"db"</span>: db</span><br><span class="line">             &#125;</span><br><span class="line">    <span class="keyword">return</span> (grads , cost)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#测试一下propagate</span></span><br><span class="line">print(<span class="string">"====================测试propagate===================="</span>)</span><br><span class="line"><span class="comment">#初始化一些参数</span></span><br><span class="line">w, b, X, Y = np.array([[<span class="number">1</span>], [<span class="number">2</span>]]), <span class="number">2</span>, np.array([[<span class="number">1</span>,<span class="number">2</span>], [<span class="number">3</span>,<span class="number">4</span>]]), np.array([[<span class="number">1</span>, <span class="number">0</span>]])</span><br><span class="line">grads, cost = propagate(w, b, X, Y)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"dw = "</span> + str(grads[<span class="string">"dw"</span>]))</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"db = "</span> + str(grads[<span class="string">"db"</span>]))</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"cost = "</span> + str(cost))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;测试propagate&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">dw &#x3D; [[0.99993216]</span><br><span class="line"> [1.99980262]]</span><br><span class="line">db &#x3D; 0.49993523062470574</span><br><span class="line">cost &#x3D; 6.000064773192205</span><br></pre></td></tr></table></figure><p>使用渐变下降更新参数。</p><p>目标是通过最小化成本函数 J 来学习 w和b 。对于参数 θ，更新规则是 $ \theta = \theta - \alpha \text{ } d\theta$，其中 α 是学习率。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">optimize</span><span class="params">(w , b , X , Y , num_iterations , learning_rate , print_cost = False)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    此函数通过运行梯度下降算法来优化w和b</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    参数：</span></span><br><span class="line"><span class="string">        w  - 权重，大小不等的数组（num_px * num_px * 3，1）</span></span><br><span class="line"><span class="string">        b  - 偏差，一个标量</span></span><br><span class="line"><span class="string">        X  - 维度为（num_px * num_px * 3，训练数据的数量）的数组。</span></span><br><span class="line"><span class="string">        Y  - 真正的“标签”矢量（如果非猫则为0，如果是猫则为1），矩阵维度为(1,训练数据的数量)</span></span><br><span class="line"><span class="string">        num_iterations  - 优化循环的迭代次数</span></span><br><span class="line"><span class="string">        learning_rate  - 梯度下降更新规则的学习率</span></span><br><span class="line"><span class="string">        print_cost  - 每100步打印一次损失值</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    返回：</span></span><br><span class="line"><span class="string">        params  - 包含权重w和偏差b的字典</span></span><br><span class="line"><span class="string">        grads  - 包含权重和偏差相对于成本函数的梯度的字典</span></span><br><span class="line"><span class="string">        成本 - 优化期间计算的所有成本列表，将用于绘制学习曲线。</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    提示：</span></span><br><span class="line"><span class="string">    我们需要写下两个步骤并遍历它们：</span></span><br><span class="line"><span class="string">        1）计算当前参数的成本和梯度，使用propagate（）。</span></span><br><span class="line"><span class="string">        2）使用w和b的梯度下降法则更新参数。</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    </span><br><span class="line">    costs = []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(num_iterations):</span><br><span class="line">        </span><br><span class="line">        grads, cost = propagate(w, b, X, Y)</span><br><span class="line">        </span><br><span class="line">        dw = grads[<span class="string">"dw"</span>]</span><br><span class="line">        db = grads[<span class="string">"db"</span>]</span><br><span class="line">        </span><br><span class="line">        w = w - learning_rate * dw</span><br><span class="line">        b = b - learning_rate * db</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#记录成本</span></span><br><span class="line">        <span class="keyword">if</span> i % <span class="number">100</span> == <span class="number">0</span>:</span><br><span class="line">            costs.append(cost)</span><br><span class="line">        <span class="comment">#打印成本数据</span></span><br><span class="line">        <span class="keyword">if</span> (print_cost) <span class="keyword">and</span> (i % <span class="number">100</span> == <span class="number">0</span>):</span><br><span class="line">            print(<span class="string">"迭代的次数: %i ， 误差值： %f"</span> % (i,cost))</span><br><span class="line">        </span><br><span class="line">    params  = &#123;</span><br><span class="line">                <span class="string">"w"</span> : w,</span><br><span class="line">                <span class="string">"b"</span> : b &#125;</span><br><span class="line">    grads = &#123;</span><br><span class="line">            <span class="string">"dw"</span>: dw,</span><br><span class="line">            <span class="string">"db"</span>: db &#125; </span><br><span class="line">    <span class="keyword">return</span> (params , grads , costs)</span><br></pre></td></tr></table></figure><p>测试一下优化函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#测试optimize</span></span><br><span class="line">print(<span class="string">"====================测试optimize===================="</span>)</span><br><span class="line">w, b, X, Y = np.array([[<span class="number">1</span>], [<span class="number">2</span>]]), <span class="number">2</span>, np.array([[<span class="number">1</span>,<span class="number">2</span>], [<span class="number">3</span>,<span class="number">4</span>]]), np.array([[<span class="number">1</span>, <span class="number">0</span>]])</span><br><span class="line">params , grads , costs = optimize(w , b , X , Y , num_iterations=<span class="number">100</span> , learning_rate = <span class="number">0.009</span> , print_cost = <span class="literal">False</span>)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"w = "</span> + str(params[<span class="string">"w"</span>]))</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"b = "</span> + str(params[<span class="string">"b"</span>]))</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"dw = "</span> + str(grads[<span class="string">"dw"</span>]))</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"db = "</span> + str(grads[<span class="string">"db"</span>]))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;测试optimize&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">w &#x3D; [[0.99100061]</span><br><span class="line"> [1.98200178]]</span><br><span class="line">b &#x3D; 1.9955005829243777</span><br><span class="line">dw &#x3D; [[0.99993216]</span><br><span class="line"> [1.99980262]]</span><br><span class="line">db &#x3D; 0.49993523062470574</span><br></pre></td></tr></table></figure><p>optimize函数会输出已学习的w和b的值，我们可以使用w和b来预测数据集X的标签。</p><p>现在我们要实现预测函数predict（）。计算预测有两个步骤：</p><p>1.计算$ \ hat {Y} = A = \ sigma（w ^ T X + b）$</p><p>2.将a的项转换为0（如果激活&lt;= 0.5）或1（如果激活&gt; 0.5），将预测存储在向量“ Y_prediction”中。 如果愿意，可以在for循环中使用if / else语句（尽管也可以向量化）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(w , b , X )</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    使用学习逻辑回归参数logistic （w，b）预测标签是0还是1，</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    参数：</span></span><br><span class="line"><span class="string">        w  - 权重，大小不等的数组（num_px * num_px * 3，1）</span></span><br><span class="line"><span class="string">        b  - 偏差，一个标量</span></span><br><span class="line"><span class="string">        X  - 维度为（num_px * num_px * 3，训练数据的数量）的数据</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    返回：</span></span><br><span class="line"><span class="string">        Y_prediction  - 包含X中所有图片的所有预测【0 | 1】的一个numpy数组（向量）</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    </span><br><span class="line">    m  = X.shape[<span class="number">1</span>] <span class="comment">#图片的数量</span></span><br><span class="line">    Y_prediction = np.zeros((<span class="number">1</span>,m)) </span><br><span class="line">    w = w.reshape(X.shape[<span class="number">0</span>],<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#计预测猫在图片中出现的概率</span></span><br><span class="line">    A = sigmoid(np.dot(w.T , X) + b)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(A.shape[<span class="number">1</span>]):</span><br><span class="line">        <span class="comment">#将概率a [0，i]转换为实际预测p [0，i]</span></span><br><span class="line">        Y_prediction[<span class="number">0</span>,i] = <span class="number">1</span> <span class="keyword">if</span> A[<span class="number">0</span>,i] &gt; <span class="number">0.5</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">    <span class="comment">#使用断言</span></span><br><span class="line">    <span class="keyword">assert</span>(Y_prediction.shape == (<span class="number">1</span>,m))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> Y_prediction</span><br></pre></td></tr></table></figure><p>测试一下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#测试predict</span></span><br><span class="line">print(<span class="string">"====================测试predict===================="</span>)</span><br><span class="line">w, b, X, Y = np.array([[<span class="number">1</span>], [<span class="number">2</span>]]), <span class="number">2</span>, np.array([[<span class="number">1</span>,<span class="number">2</span>], [<span class="number">3</span>,<span class="number">4</span>]]), np.array([[<span class="number">1</span>, <span class="number">0</span>]])</span><br><span class="line">print(<span class="string">"predictions = "</span> + str(predict(w, b, X)))</span><br></pre></td></tr></table></figure><p>就目前而言，我们基本上把所有的东西都做完了，把函数统统整合到一个model()函数中，届时只需要调用一个model()就基本上完成所有的事了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">model</span><span class="params">(X_train , Y_train , X_test , Y_test , num_iterations = <span class="number">2000</span> , learning_rate = <span class="number">0.5</span> , print_cost = False)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    通过调用之前实现的函数来构建逻辑回归模型</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    参数：</span></span><br><span class="line"><span class="string">        X_train  - numpy的数组,维度为（num_px * num_px * 3，m_train）的训练集</span></span><br><span class="line"><span class="string">        Y_train  - numpy的数组,维度为（1，m_train）（矢量）的训练标签集</span></span><br><span class="line"><span class="string">        X_test   - numpy的数组,维度为（num_px * num_px * 3，m_test）的测试集</span></span><br><span class="line"><span class="string">        Y_test   - numpy的数组,维度为（1，m_test）的（向量）的测试标签集</span></span><br><span class="line"><span class="string">        num_iterations  - 表示用于优化参数的迭代次数的超参数</span></span><br><span class="line"><span class="string">        learning_rate  - 表示optimize（）更新规则中使用的学习速率的超参数</span></span><br><span class="line"><span class="string">        print_cost  - 设置为true以每100次迭代打印成本</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    返回：</span></span><br><span class="line"><span class="string">        d  - 包含有关模型信息的字典。</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    w , b = initialize_with_zeros(X_train.shape[<span class="number">0</span>])</span><br><span class="line">    </span><br><span class="line">    parameters , grads , costs = optimize(w , b , X_train , Y_train,num_iterations , learning_rate , print_cost)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#从字典“参数”中检索参数w和b</span></span><br><span class="line">    w , b = parameters[<span class="string">"w"</span>] , parameters[<span class="string">"b"</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#预测测试/训练集的例子</span></span><br><span class="line">    Y_prediction_test = predict(w , b, X_test)</span><br><span class="line">    Y_prediction_train = predict(w , b, X_train)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#打印训练后的准确性</span></span><br><span class="line">    print(<span class="string">"训练集准确性："</span>  , format(<span class="number">100</span> - np.mean(np.abs(Y_prediction_train - Y_train)) * <span class="number">100</span>) ,<span class="string">"%"</span>)</span><br><span class="line">    print(<span class="string">"测试集准确性："</span>  , format(<span class="number">100</span> - np.mean(np.abs(Y_prediction_test - Y_test)) * <span class="number">100</span>) ,<span class="string">"%"</span>)</span><br><span class="line">    <span class="comment">#mean()函数功能：求取均值</span></span><br><span class="line">    d = &#123;</span><br><span class="line">            <span class="string">"costs"</span> : costs,</span><br><span class="line">            <span class="string">"Y_prediction_test"</span> : Y_prediction_test,</span><br><span class="line">            <span class="string">"Y_prediciton_train"</span> : Y_prediction_train,</span><br><span class="line">            <span class="string">"w"</span> : w,</span><br><span class="line">            <span class="string">"b"</span> : b,</span><br><span class="line">            <span class="string">"learning_rate"</span> : learning_rate,</span><br><span class="line">            <span class="string">"num_iterations"</span> : num_iterations &#125;</span><br><span class="line">    <span class="keyword">return</span> d</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">"====================测试model===================="</span>)     </span><br><span class="line"><span class="comment">#这里加载的是真实的数据，请参见上面的代码部分。</span></span><br><span class="line">d = model(train_set_x, train_set_y, test_set_x, test_set_y, num_iterations = <span class="number">2000</span>, learning_rate = <span class="number">0.005</span>, print_cost = <span class="literal">True</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;测试model&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">迭代的次数: 0 ， 误差值： 0.693147</span><br><span class="line">迭代的次数: 100 ， 误差值： 0.584508</span><br><span class="line">迭代的次数: 200 ， 误差值： 0.466949</span><br><span class="line">迭代的次数: 300 ， 误差值： 0.376007</span><br><span class="line">迭代的次数: 400 ， 误差值： 0.331463</span><br><span class="line">迭代的次数: 500 ， 误差值： 0.303273</span><br><span class="line">迭代的次数: 600 ， 误差值： 0.279880</span><br><span class="line">迭代的次数: 700 ， 误差值： 0.260042</span><br><span class="line">迭代的次数: 800 ， 误差值： 0.242941</span><br><span class="line">迭代的次数: 900 ， 误差值： 0.228004</span><br><span class="line">迭代的次数: 1000 ， 误差值： 0.214820</span><br><span class="line">迭代的次数: 1100 ， 误差值： 0.203078</span><br><span class="line">迭代的次数: 1200 ， 误差值： 0.192544</span><br><span class="line">迭代的次数: 1300 ， 误差值： 0.183033</span><br><span class="line">迭代的次数: 1400 ， 误差值： 0.174399</span><br><span class="line">迭代的次数: 1500 ， 误差值： 0.166521</span><br><span class="line">迭代的次数: 1600 ， 误差值： 0.159305</span><br><span class="line">迭代的次数: 1700 ， 误差值： 0.152667</span><br><span class="line">迭代的次数: 1800 ， 误差值： 0.146542</span><br><span class="line">迭代的次数: 1900 ， 误差值： 0.140872</span><br><span class="line">训练集准确性： 99.04306220095694 %</span><br><span class="line">测试集准确性： 70.0 %</span><br></pre></td></tr></table></figure><p>我们更改一下学习率和迭代次数，有可能会发现训练集的准确性可能会提高，但是测试集准确性会下降，这是由于过拟合造成的，但是我们并不需要担心，我们以后会使用更好的算法来解决这些问题的。</p><hr><p>到目前为止程序算是完成了，但是可以在后面加一点东西，比如画点图什么的。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#绘制图</span></span><br><span class="line">costs = np.squeeze(d[<span class="string">'costs'</span>])</span><br><span class="line">plt.plot(costs)</span><br><span class="line">plt.ylabel(<span class="string">'cost'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'iterations (per hundreds)'</span>)</span><br><span class="line">plt.title(<span class="string">"Learning rate ="</span> + str(d[<span class="string">"learning_rate"</span>]))</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>跑一波出来的效果图是这样的，可以看到成本下降，它显示参数正在被学习：</p><p><img src="https://raw.githubusercontent.com/pxlsdz/MarkDown-images/master/2020-1-16/%E6%8A%98%E7%BA%BF%E5%9B%BE.png" alt=""></p><p>让我们进一步分析一下，并研究学习率alpha的可能选择。为了让渐变下降起作用，我们必须明智地选择学习速率。学习率α决定了我们更新参数的速度。如果学习率过高，我们可能会“超过”最优值。同样，如果它太小，我们将需要太多迭代才能收敛到最佳值。这就是为什么使用良好调整的学习率至关重要的原因。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">learning_rates = [<span class="number">0.01</span>, <span class="number">0.001</span>, <span class="number">0.0001</span>]</span><br><span class="line">models = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> learning_rates:</span><br><span class="line">    <span class="keyword">print</span> (<span class="string">"learning rate is: "</span> + str(i))</span><br><span class="line">    models[str(i)] = model(train_set_x, train_set_y, test_set_x, test_set_y, num_iterations = <span class="number">1500</span>, learning_rate = i, print_cost = <span class="literal">False</span>)</span><br><span class="line">    <span class="keyword">print</span> (<span class="string">'\n'</span> + <span class="string">"-------------------------------------------------------"</span> + <span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> learning_rates:</span><br><span class="line">    plt.plot(np.squeeze(models[str(i)][<span class="string">"costs"</span>]), label= str(models[str(i)][<span class="string">"learning_rate"</span>]))</span><br><span class="line"></span><br><span class="line">plt.ylabel(<span class="string">'cost'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'iterations'</span>)</span><br><span class="line"></span><br><span class="line">legend = plt.legend(loc=<span class="string">'upper center'</span>, shadow=<span class="literal">True</span>)<span class="comment">#loc用于控制图例的位置</span></span><br><span class="line">frame = legend.get_frame()</span><br><span class="line">frame.set_facecolor(<span class="string">'0.90'</span>)<span class="comment">#置图例legend背景颜色</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">learning rate is: 0.01</span><br><span class="line">训练集准确性： 99.52153110047847 %</span><br><span class="line">测试集准确性： 68.0 %</span><br><span class="line"></span><br><span class="line">-------------------------------------------------------</span><br><span class="line"></span><br><span class="line">learning rate is: 0.001</span><br><span class="line">训练集准确性： 88.99521531100478 %</span><br><span class="line">测试集准确性： 64.0 %</span><br><span class="line"></span><br><span class="line">-------------------------------------------------------</span><br><span class="line"></span><br><span class="line">learning rate is: 0.0001</span><br><span class="line">训练集准确性： 68.42105263157895 %</span><br><span class="line">测试集准确性： 36.0 %</span><br><span class="line"></span><br><span class="line">-------------------------------------------------------</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/pxlsdz/MarkDown-images/master/2020-1-16/%E5%A4%9A%E6%8A%98%E7%BA%BF%E5%9B%BE.png" alt=""></p><hr><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a><strong>完整代码</strong></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> h5py</span><br><span class="line"><span class="keyword">from</span> lr_utils <span class="keyword">import</span> load_dataset</span><br><span class="line"></span><br><span class="line">train_set_x_orig , train_set_y , test_set_x_orig , test_set_y , classes = load_dataset()</span><br><span class="line"></span><br><span class="line">m_train = train_set_y.shape[<span class="number">1</span>] <span class="comment">#训练集里图片的数量。</span></span><br><span class="line">m_test = test_set_y.shape[<span class="number">1</span>] <span class="comment">#测试集里图片的数量。</span></span><br><span class="line">num_px = train_set_x_orig.shape[<span class="number">1</span>] <span class="comment">#训练、测试集里面的图片的宽度和高度（均为64x64）。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#现在看一看我们加载的东西的具体情况</span></span><br><span class="line"><span class="keyword">print</span> (<span class="string">"训练集的数量: m_train = "</span> + str(m_train))</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"测试集的数量 : m_test = "</span> + str(m_test))</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"每张图片的宽/高 : num_px = "</span> + str(num_px))</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"每张图片的大小 : ("</span> + str(num_px) + <span class="string">", "</span> + str(num_px) + <span class="string">", 3)"</span>)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"训练集_图片的维数 : "</span> + str(train_set_x_orig.shape))</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"训练集_标签的维数 : "</span> + str(train_set_y.shape))</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"测试集_图片的维数: "</span> + str(test_set_x_orig.shape))</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"测试集_标签的维数: "</span> + str(test_set_y.shape))</span><br><span class="line"></span><br><span class="line"><span class="comment">#将训练集的维度降低并转置。</span></span><br><span class="line">train_set_x_flatten  = train_set_x_orig.reshape(train_set_x_orig.shape[<span class="number">0</span>],<span class="number">-1</span>).T</span><br><span class="line"><span class="comment">#将测试集的维度降低并转置。</span></span><br><span class="line">test_set_x_flatten = test_set_x_orig.reshape(test_set_x_orig.shape[<span class="number">0</span>], <span class="number">-1</span>).T</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> (<span class="string">"训练集降维最后的维度： "</span> + str(train_set_x_flatten.shape))</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"训练集_标签的维数 : "</span> + str(train_set_y.shape))</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"测试集降维之后的维度: "</span> + str(test_set_x_flatten.shape))</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"测试集_标签的维数 : "</span> + str(test_set_y.shape))</span><br><span class="line"></span><br><span class="line">train_set_x = train_set_x_flatten / <span class="number">255</span></span><br><span class="line">test_set_x = test_set_x_flatten / <span class="number">255</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sigmoid</span><span class="params">(z)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    参数：</span></span><br><span class="line"><span class="string">        z  - 任何大小的标量或numpy数组。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    返回：</span></span><br><span class="line"><span class="string">        s  -  sigmoid（z）</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    s = <span class="number">1</span> / (<span class="number">1</span> + np.exp(-z))</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">initialize_with_zeros</span><span class="params">(dim)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">        此函数为w创建一个维度为（dim，1）的0向量，并将b初始化为0。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        参数：</span></span><br><span class="line"><span class="string">            dim  - 我们想要的w矢量的大小（或者这种情况下的参数数量）</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        返回：</span></span><br><span class="line"><span class="string">            w  - 维度为（dim，1）的初始化向量。</span></span><br><span class="line"><span class="string">            b  - 初始化的标量（对应于偏差）</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    w = np.zeros(shape = (dim,<span class="number">1</span>))</span><br><span class="line">    b = <span class="number">0</span></span><br><span class="line">    <span class="comment">#使用断言来确保我要的数据是正确的</span></span><br><span class="line">    <span class="keyword">assert</span>(w.shape == (dim, <span class="number">1</span>)) <span class="comment">#w的维度是(dim,1)</span></span><br><span class="line">    <span class="keyword">assert</span>(isinstance(b, float) <span class="keyword">or</span> isinstance(b, int)) <span class="comment">#b的类型是float或者是int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (w , b)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">propagate</span><span class="params">(w, b, X, Y)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    实现前向和后向传播的成本函数及其梯度。</span></span><br><span class="line"><span class="string">    参数：</span></span><br><span class="line"><span class="string">        w  - 权重，大小不等的数组（num_px * num_px * 3，1）</span></span><br><span class="line"><span class="string">        b  - 偏差，一个标量</span></span><br><span class="line"><span class="string">        X  - 矩阵类型为（num_px * num_px * 3，训练数量）</span></span><br><span class="line"><span class="string">        Y  - 真正的“标签”矢量（如果非猫则为0，如果是猫则为1），矩阵维度为(1,训练数据数量)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    返回：</span></span><br><span class="line"><span class="string">        cost- 逻辑回归的负对数似然成本</span></span><br><span class="line"><span class="string">        dw  - 相对于w的损失梯度，因此与w相同的形状</span></span><br><span class="line"><span class="string">        db  - 相对于b的损失梯度，因此与b的形状相同</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    m = X.shape[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment">#正向传播</span></span><br><span class="line">    A = sigmoid(np.dot(w.T,X) + b) <span class="comment">#计算激活值，请参考公式2。</span></span><br><span class="line">    cost = (- <span class="number">1</span> / m) * np.sum(Y * np.log(A) + (<span class="number">1</span> - Y) * (np.log(<span class="number">1</span> - A))) <span class="comment">#计算成本，请参考公式3和4。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#反向传播</span></span><br><span class="line">    dw = (<span class="number">1</span> / m) * np.dot(X, (A - Y).T) <span class="comment">#请参考视频中的偏导公式。</span></span><br><span class="line">    db = (<span class="number">1</span> / m) * np.sum(A - Y) <span class="comment">#请参考视频中的偏导公式。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#使用断言确保我的数据是正确的</span></span><br><span class="line">    <span class="keyword">assert</span>(dw.shape == w.shape)</span><br><span class="line">    <span class="keyword">assert</span>(db.dtype == float)</span><br><span class="line">    cost = np.squeeze(cost)</span><br><span class="line">    <span class="keyword">assert</span>(cost.shape == ())</span><br><span class="line"></span><br><span class="line">    <span class="comment">#创建一个字典，把dw和db保存起来。</span></span><br><span class="line">    grads = &#123;</span><br><span class="line">                <span class="string">"dw"</span>: dw,</span><br><span class="line">                <span class="string">"db"</span>: db</span><br><span class="line">             &#125;</span><br><span class="line">    <span class="keyword">return</span> (grads , cost)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">optimize</span><span class="params">(w , b , X , Y , num_iterations , learning_rate , print_cost = False)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    此函数通过运行梯度下降算法来优化w和b</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    参数：</span></span><br><span class="line"><span class="string">        w  - 权重，大小不等的数组（num_px * num_px * 3，1）</span></span><br><span class="line"><span class="string">        b  - 偏差，一个标量</span></span><br><span class="line"><span class="string">        X  - 维度为（num_px * num_px * 3，训练数据的数量）的数组。</span></span><br><span class="line"><span class="string">        Y  - 真正的“标签”矢量（如果非猫则为0，如果是猫则为1），矩阵维度为(1,训练数据的数量)</span></span><br><span class="line"><span class="string">        num_iterations  - 优化循环的迭代次数</span></span><br><span class="line"><span class="string">        learning_rate  - 梯度下降更新规则的学习率</span></span><br><span class="line"><span class="string">        print_cost  - 每100步打印一次损失值</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    返回：</span></span><br><span class="line"><span class="string">        params  - 包含权重w和偏差b的字典</span></span><br><span class="line"><span class="string">        grads  - 包含权重和偏差相对于成本函数的梯度的字典</span></span><br><span class="line"><span class="string">        成本 - 优化期间计算的所有成本列表，将用于绘制学习曲线。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    提示：</span></span><br><span class="line"><span class="string">    我们需要写下两个步骤并遍历它们：</span></span><br><span class="line"><span class="string">        1）计算当前参数的成本和梯度，使用propagate（）。</span></span><br><span class="line"><span class="string">        2）使用w和b的梯度下降法则更新参数。</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    costs = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(num_iterations):</span><br><span class="line"></span><br><span class="line">        grads, cost = propagate(w, b, X, Y)</span><br><span class="line"></span><br><span class="line">        dw = grads[<span class="string">"dw"</span>]</span><br><span class="line">        db = grads[<span class="string">"db"</span>]</span><br><span class="line"></span><br><span class="line">        w = w - learning_rate * dw</span><br><span class="line">        b = b - learning_rate * db</span><br><span class="line"></span><br><span class="line">        <span class="comment">#记录成本</span></span><br><span class="line">        <span class="keyword">if</span> i % <span class="number">100</span> == <span class="number">0</span>:</span><br><span class="line">            costs.append(cost)</span><br><span class="line">        <span class="comment">#打印成本数据</span></span><br><span class="line">        <span class="keyword">if</span> (print_cost) <span class="keyword">and</span> (i % <span class="number">100</span> == <span class="number">0</span>):</span><br><span class="line">            print(<span class="string">"迭代的次数: %i ， 误差值： %f"</span> % (i,cost))</span><br><span class="line"></span><br><span class="line">    params  = &#123;</span><br><span class="line">                <span class="string">"w"</span> : w,</span><br><span class="line">                <span class="string">"b"</span> : b &#125;</span><br><span class="line">    grads = &#123;</span><br><span class="line">            <span class="string">"dw"</span>: dw,</span><br><span class="line">            <span class="string">"db"</span>: db &#125; </span><br><span class="line">    <span class="keyword">return</span> (params , grads , costs)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(w , b , X )</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    使用学习逻辑回归参数logistic （w，b）预测标签是0还是1，</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    参数：</span></span><br><span class="line"><span class="string">        w  - 权重，大小不等的数组（num_px * num_px * 3，1）</span></span><br><span class="line"><span class="string">        b  - 偏差，一个标量</span></span><br><span class="line"><span class="string">        X  - 维度为（num_px * num_px * 3，训练数据的数量）的数据</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    返回：</span></span><br><span class="line"><span class="string">        Y_prediction  - 包含X中所有图片的所有预测【0 | 1】的一个numpy数组（向量）</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    m  = X.shape[<span class="number">1</span>] <span class="comment">#图片的数量</span></span><br><span class="line">    Y_prediction = np.zeros((<span class="number">1</span>,m)) </span><br><span class="line">    w = w.reshape(X.shape[<span class="number">0</span>],<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#计预测猫在图片中出现的概率</span></span><br><span class="line">    A = sigmoid(np.dot(w.T , X) + b)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(A.shape[<span class="number">1</span>]):</span><br><span class="line">        <span class="comment">#将概率a [0，i]转换为实际预测p [0，i]</span></span><br><span class="line">        Y_prediction[<span class="number">0</span>,i] = <span class="number">1</span> <span class="keyword">if</span> A[<span class="number">0</span>,i] &gt; <span class="number">0.5</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">    <span class="comment">#使用断言</span></span><br><span class="line">    <span class="keyword">assert</span>(Y_prediction.shape == (<span class="number">1</span>,m))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Y_prediction</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">model</span><span class="params">(X_train , Y_train , X_test , Y_test , num_iterations = <span class="number">2000</span> , learning_rate = <span class="number">0.5</span> , print_cost = False)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    通过调用之前实现的函数来构建逻辑回归模型</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    参数：</span></span><br><span class="line"><span class="string">        X_train  - numpy的数组,维度为（num_px * num_px * 3，m_train）的训练集</span></span><br><span class="line"><span class="string">        Y_train  - numpy的数组,维度为（1，m_train）（矢量）的训练标签集</span></span><br><span class="line"><span class="string">        X_test   - numpy的数组,维度为（num_px * num_px * 3，m_test）的测试集</span></span><br><span class="line"><span class="string">        Y_test   - numpy的数组,维度为（1，m_test）的（向量）的测试标签集</span></span><br><span class="line"><span class="string">        num_iterations  - 表示用于优化参数的迭代次数的超参数</span></span><br><span class="line"><span class="string">        learning_rate  - 表示optimize（）更新规则中使用的学习速率的超参数</span></span><br><span class="line"><span class="string">        print_cost  - 设置为true以每100次迭代打印成本</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    返回：</span></span><br><span class="line"><span class="string">        d  - 包含有关模型信息的字典。</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    w , b = initialize_with_zeros(X_train.shape[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    parameters , grads , costs = optimize(w , b , X_train , Y_train,num_iterations , learning_rate , print_cost)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#从字典“参数”中检索参数w和b</span></span><br><span class="line">    w , b = parameters[<span class="string">"w"</span>] , parameters[<span class="string">"b"</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment">#预测测试/训练集的例子</span></span><br><span class="line">    Y_prediction_test = predict(w , b, X_test)</span><br><span class="line">    Y_prediction_train = predict(w , b, X_train)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#打印训练后的准确性</span></span><br><span class="line">    print(<span class="string">"训练集准确性："</span>  , format(<span class="number">100</span> - np.mean(np.abs(Y_prediction_train - Y_train)) * <span class="number">100</span>) ,<span class="string">"%"</span>)</span><br><span class="line">    print(<span class="string">"测试集准确性："</span>  , format(<span class="number">100</span> - np.mean(np.abs(Y_prediction_test - Y_test)) * <span class="number">100</span>) ,<span class="string">"%"</span>)</span><br><span class="line"></span><br><span class="line">    d = &#123;</span><br><span class="line">            <span class="string">"costs"</span> : costs,</span><br><span class="line">            <span class="string">"Y_prediction_test"</span> : Y_prediction_test,</span><br><span class="line">            <span class="string">"Y_prediciton_train"</span> : Y_prediction_train,</span><br><span class="line">            <span class="string">"w"</span> : w,</span><br><span class="line">            <span class="string">"b"</span> : b,</span><br><span class="line">            <span class="string">"learning_rate"</span> : learning_rate,</span><br><span class="line">            <span class="string">"num_iterations"</span> : num_iterations &#125;</span><br><span class="line">    <span class="keyword">return</span> d</span><br><span class="line"></span><br><span class="line">d = model(train_set_x, train_set_y, test_set_x, test_set_y, num_iterations = <span class="number">2000</span>, learning_rate = <span class="number">0.005</span>, print_cost = <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#绘制图</span></span><br><span class="line">costs = np.squeeze(d[<span class="string">'costs'</span>])</span><br><span class="line">plt.plot(costs)</span><br><span class="line">plt.ylabel(<span class="string">'cost'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'iterations (per hundreds)'</span>)</span><br><span class="line">plt.title(<span class="string">"Learning rate ="</span> + str(d[<span class="string">"learning_rate"</span>]))</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 神经网络 </tag>
            
            <tag> Logistic回归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>英语句子收藏</title>
      <link href="/2020/01/10/%E8%8B%B1%E8%AF%AD%E5%8F%A5%E5%AD%90%E6%94%B6%E8%97%8F/"/>
      <url>/2020/01/10/%E8%8B%B1%E8%AF%AD%E5%8F%A5%E5%AD%90%E6%94%B6%E8%97%8F/</url>
      
        <content type="html"><![CDATA[<p>英语句子背诵</p><a id="more"></a><p><strong>Unit one</strong></p><p>1)   这个村子离边境很近，村民们一直担心会受到敌人的攻击。</p><p>The village is so close to the border that the villagers lived in constant fear of attacks from the enemy.</p><p>2)   这个国家仅用了20年的时间就发展成了一个先进的工业强国。</p><p> In only twenty years the country was transformed into an advanced industrial power.</p><p>3)   看到项目的顺利完成，那些为此投入了大量时间和精力的人们都感到非常自豪。</p><p> Seeing the project successfully completed, those who had invested so much time and energy in it felt very proud.</p><p>4)   鉴于目前的金融形势，美元进一步贬值是不可避免的。</p><p>Given the current financial situation, it is inevitable that the US dollar will be further devalued.</p><p>5)   现在的汽车太多了，这个地区的道路几乎无法应对当前的交通状况。</p><p>There are so many vehicles nowadays that the roads in this area are barely adequate to cope with the present traffic.</p><p>6)   天气没有出现好转的迹象，所以政府号召我们做好防洪的准备。</p><p>The weather showed no signs of getting better so the government called upon us to get prepared for floods.</p><p>7)   那场车祸以后爱丽丝十几年卧床不起，所以她的康复真是一个奇迹。</p><p>Alice had been confined to bed for over 10 years after the traffic accident, and so her recovery seemed nothing short of a miracle. </p><p>8)   这些同学对世界杯十分关注，每天至少花两个看比赛的现场直播。</p><p>The students were all very much concerned about the World Cup, spending at least two hours every day watching the live matches on TV.</p><p>9)   托马斯说他家半个多世纪前就在弗洛里达定居了。</p><p>Thomas said that his family had settled in Florida more than half a century ago. </p><p>10) 寻求他人的帮助，别自己一个人扛着。我很早就吸取了这个教训。</p><p>Ask for help. Don’t tough it out yourself. I learned this lesson early in my life.</p><p><strong>Unit two</strong></p><p>1)   他的确懂很多理论，但是，一碰到实际工作就显得非常无知。</p><p>He really knows a lot about theory, but when it comes to actual work, he seems to be quite ignorant.</p><p>2)   最新调查表明，大多数市民支持政府再建一个新图书馆的计划。</p><p>The latest survey shows /showed that the majority of the citizens support / supported the government’s plan to build a new library.</p><p>3)   这两个国家之所以能够成功地达成科学技术合作协定是因为有利于他们进行合作的好几种因素一直在发生作用。</p><p>The two countries could reach agreement successfully on scientific and technological cooperation because several factors favorable to their cooperation had been at work.</p><p>4)   我在上小学时就看过那部电影，可就是一时想不起它的名字来。</p><p>I saw the film when I was in the primary school, but the title just won’t come to mind for the moment.</p><p>5)   尽管每天平均工作约12个小时，他仍然陷于重重债务之中。</p><p>He has been stuck with heavy debt though he works about twelve hours every day on average.</p><p>6)   有必要知道他的身高吗？在我看来，这与他能否成为一个好的律师没有关系。</p><p>Is it necessary to know his height? To me, it is not relevant to whether he can be a good lawyer or not.</p><p>7)   橱柜被安装到墙里，既节约空间，又方便使用。</p><p>The cupboard is built into the wall so that it both saves space and is convenient to use.</p><p>8)   这些工人挣的钱比我们多，可话又说回来，他们的工作也危险得多。</p><p>These workers earn more than we do, but the other side of the coin is that their job is more dangerous.</p><p>9)   海伦在大学里学的是经济学，与此同时她把哲学作为第二专业来学习。</p><p>Helen majors in economics at the university and at the same time she studies philosophy as her second major.</p><p>10)  重要的是你们要自己发现问题和解决问题，我是否到现场去无关紧要。</p><p>What is most important is that you must find out and solve the problems by yourselves. It makes no difference whether I go there or not.</p><p><strong>Unit three</strong></p><p>1)   他试图拯救这家濒临倒闭的企业，但失败了。</p><p>He attempted to save the enterprise which was on the verge of collapse but failed.</p><p>2)   总统已经宣布，在第一个任期结束时不再谋求连任。</p><p>The president has announced that he will not seek re-election at the end of his first term.</p><p>3)   那个年轻教师在激发学生努力学习方面很有技巧。</p><p>The young teacher is skilled at motivating his students to study hard.</p><p>4)   她喜欢举行社交聚会，只要能找到借口，她就随时举办。</p><p>She loves giving parties and does so whenever she can find an excuse.</p><p>5)   要在这家公司找到一个管理职位，你恐怕至少要和50个人竞争。</p><p>I’m afraid that you’ll have to compete with at least fifty people for an administrative post in this company.</p><p>6)   他们把自己的生活搞得一团糟的一个主要原因就是他们年轻时没有接受很好的学校教育。</p><p>One of the main reasons why they have messed up their lives is that they did not have a good school education when young.</p><p>7)   玛丽已经很出名了，但是她根本就不幸福，因为她一直就被更加出名的念头困扰着。Mary is already famous, but she is not happy at all because she’s been obsessed with thoughts of becoming even more famous.</p><p>8)   随着科技的发展，人们现在能够轻而易举地获得教育，医疗和其他多种信息。</p><p>With the development of science and technology, people now can have easy access to educational, medical and many other kinds of information.</p><p>9)   公司的投资之所以以失败告终是由于总经理的决策错误，于是董事会决定把他从公司赶出去。</p><p>The company’s investment ended in failure due to the wrong strategic decisions of the general manager and so the board of directors decided to throw him out.</p><p>10) 我知道你累了，不过再坚持一会儿吧。再过半个小时我们就要到达顶峰了。</p><p>I know you are tired but try to hang on a little bit longer. We will reach the peak in half an hour.</p><p><strong>Unit four</strong></p><p>1) 随着她个人生活的细节越来越多地被媒体披露出来，她不得不辞去公司总经理的职务。As more and more details of her private life were disclosed by the media, she was compelled to resign her post as general manager (or: resign as general manager/ resign from the post of general manager) of the company.</p><p>2) 她对自己的新工作很满意，因为这份工作正好与她的兴趣相符。</p><p>She is very satisfied with her new job as it coincides with her interests.</p><p>3) 我买了这件衬衣，因为它的价格从300元降到了80元。</p><p>I bought this shirt because the price was reduced from 300 yuan to 80 yuan.</p><p>4) 为了把孩子们抚养成人，这位母亲真是历经了各种磨难。</p><p>To bring her children up, the mother really went through all kinds of hardships.</p><p>5) 警方在老太太的死亡案总已经排除了谋杀的可能性。</p><p>The police have ruled out murder in the case of the old lady’s death.</p><p>6)   市政府承诺将尽快采取有效措施，解决空气污染的问题。</p><p>The municipality (municipal government) promised to take effective steps as soon as possible to solve the problems of air pollution. </p><p>7)   因为腿部受伤，我没有参加上个月学校举行的网球锦标赛。</p><p>I did not go in for the Campus Tennis Championships held last month because of my injured leg.</p><p>8） 要是能得到大多数女生支持的话，你赢得选举成为学生会主席的机会是很大的。</p><p>If you can get the support of the majority of the girls, you stand a good chance of winning the election and becoming Chairman of the Students Union.</p><p>9)   他写的书并非都像这一本这么成功，所以我建议你从图书馆把它借来读一下。</p><p>Not all the books he wrote were as successful as this one so I recommend that you borrow it from the library and read it.</p><p>10) 在2004年雅典奥运会上刘翔打破男子110米栏世界纪录，获得冠军，这个纪录以前是由一个美国运动员保持的。</p><p>At the 2004 Athens Olympic Games Liu Xiang won the championship of the men’s 110-meter hurdle and broke the world record, which had been previously held by an American athlete.</p><p><strong>Unit six</strong></p><p>1)   这位驻联合国大使被授权代表本国政府，处理与该国相关的所有外交事务。</p><p>The ambassador to the U.N. was invested with full authority to deal with all the foreign affairs concerning his country on behalf of his government.</p><p>2)   在火车上我一直在想期末考试的结果，直到乘务员提醒我目的地已经到了。</p><p>All the way on the train I had been preoccupied with the result of the term examination until the conductor reminded me of the arrival of my destination.</p><p>3)   虽然车祸死亡名单中没有她丈夫的名字，但她仍不停地在屋里走来走去，急切地盼望他早日回到家里。</p><p>Although her husband’s name did not appear on the list of the people who got killed in the traffic accident, she kept walking to and fro, anxious to see him back home sooner.</p><p>4)   我正准备把合同翻译成英语，突然意识到合同涉及的双方都是中国公司。</p><p>I was setting out to translate the contract into English when it dawned upon me that both parties involved were Chinese companies.</p><p>5)   聚会上人们尽情地唱歌跳舞，把生活中的烦恼抛到了九霄云外。</p><p>At the party, people sang and danced with abandon, totally forgetting the troubles in their lives.</p><p>6)   怀着做一名宇航员的强烈愿望，杰克逊全身心地投入到长达两年的艰苦体能训练之中。</p><p>With the great aspirations to become an astronaut, Jackson committed himself to the 2-year strenuous constitution training.</p><p>7)   他的油画取材于亘古永存的神话故事，反映了那个时期欧洲人的鉴赏趣味。</p><p>His paintings, drawing on timeless fairy stories, exemplified the Europeans’ taste of that period.</p><p>8)   那个公共汽车司机不想承担事故责任，所以千方百计把责任推到车上的乘客身上。</p><p>The bus driver didn’t want to take any responsibility for the accident and so he took every means to put the blame on the passengers on board.</p><p>9)   他不仅冒着生命危险把老人从熊熊燃烧的房子里救了出来，还腾出自家屋子让老人住下。</p><p>He not only risked his own life to save the old man from the burning house but made some room in his own house for him to settle down.</p><p>10)  她从小就努力按照父母的教导去生活，形成了一整套为人处世的行为准则。</p><p>From childhood, she tried to live by the teachings of her parents and gradually accumulated a set of standards of conduct.</p>]]></content>
      
      
      <categories>
          
          <category> 英语 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 英语句子 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一篇博客</title>
      <link href="/2020/01/10/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
      <url>/2020/01/10/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<p>博客的目的：汇总知识点，时常复习</p><a id="more"></a><p>  早就想用github+hexo写博客了，以前一直用的CSDN，但毕竟是别人的，虽然这个hexo框架也是别人的，但毕竟可以自己设计喜欢的界面，一直很喜欢简约的界面。基于github的原因是没钱买服务器，也很麻烦。</p><p>  我的CSDN博客网址：<a href="https://blog.csdn.net/sdz20172133" target="_blank" rel="noopener">pxlsdz的csdn博客</a>，里面大部分博客是我以前打ACM的题解和知识点。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>网上书店</title>
      <link href="/2019/01/14/%E7%BD%91%E4%B8%8A%E4%B9%A6%E5%BA%97%E5%AE%9E%E7%8E%B0/"/>
      <url>/2019/01/14/%E7%BD%91%E4%B8%8A%E4%B9%A6%E5%BA%97%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="网上书店"><a href="#网上书店" class="headerlink" title="网上书店"></a>网上书店</h1><p>利用最基本的java web技术实现</p><a id="more"></a><p><u>图片未来得及修改，GitHub可以正常观看</u></p><p>github源码地址：<a href="https://github.com/pxlsdz/book-store" target="_blank" rel="noopener">https://github.com/pxlsdz/book-store</a></p><p>合作者：WentongXu,dengdeng337(github账号）</p><h1 id="《Web应用开发技术课程设计》报告—网上书店"><a href="#《Web应用开发技术课程设计》报告—网上书店" class="headerlink" title="《Web应用开发技术课程设计》报告—网上书店"></a><strong><em>《Web应用开发技术课程设计》报告—网上书店</em></strong></h1><h1 id="课程设计报告"><a href="#课程设计报告" class="headerlink" title="课程设计报告"></a>课程设计报告</h1><h1 id="一、课程设计目的"><a href="#一、课程设计目的" class="headerlink" title="一、课程设计目的"></a>一、课程设计目的</h1><p>针对Java<br>Web的综合设计应用，通过综合性的课程设计，加强理论联系实际，巩固和丰富课堂所学的基础理论知识，进一步锻炼和提高学生的实际软件开发能力。</p><p>通过该课程设计培养学生分析问题和解决问题的能力，以及开发大系统的综合能力，增强合作、协作能力，提高学生的就业机会和社会竞争能力。</p><p>为了提高学生的协作、合作精神，以及团队精神，该课程设计给定一个作何应用大题目，由学生自愿组成2-6人的开发小组，基于软件工程的开发思想与开发过程，实现该应用程序的开发、设计。</p><h1 id="二、课程设计要求"><a href="#二、课程设计要求" class="headerlink" title="二、课程设计要求"></a>二、课程设计要求</h1><p>经过该课程设计，掌握Java Web应用程序的基本开发方法、技术；熟练掌Java<br>Web的各类技术的开发整合，并完成应用系统的开发。</p><p><strong>1、设计题目与要求</strong></p><p>设计实现一个网上书店的系统。</p><p>要求：整个功能都能顺畅流畅的运行。</p><p><strong>2、数据库设计：</strong></p><h5 id="user表"><a href="#user表" class="headerlink" title="user表"></a>user表</h5><table><thead><tr><th>字段名</th><th>数据类型</th><th>实际列名</th><th>约束</th><th>备注</th></tr></thead><tbody><tr><td>userid</td><td>int</td><td>用户号</td><td>PRIMARY KEY</td><td></td></tr><tr><td>username</td><td>String</td><td>用户名</td><td></td><td></td></tr><tr><td>password</td><td>String</td><td>密码</td><td></td><td></td></tr></tbody></table><h5 id="admin表"><a href="#admin表" class="headerlink" title="admin表"></a>admin表</h5><table><thead><tr><th>字段名</th><th>数据类型</th><th>实际列名</th><th>约束</th><th>备注</th></tr></thead><tbody><tr><td>adminid</td><td>int</td><td>管理员号</td><td>PRIMARY KEY</td><td></td></tr><tr><td>adminname</td><td>String</td><td>管理员名</td><td></td><td></td></tr><tr><td>password</td><td>String</td><td>密码</td><td></td><td></td></tr></tbody></table><h5 id="shopcar表"><a href="#shopcar表" class="headerlink" title="shopcar表"></a>shopcar表</h5><table><thead><tr><th>字段名</th><th>数据类型</th><th>实际列名</th><th>约束</th><th>备注</th></tr></thead><tbody><tr><td>shopcarid</td><td>int</td><td>购物车号</td><td>PRIMARY KEY</td><td></td></tr><tr><td>userid</td><td>int</td><td>用户号</td><td></td><td></td></tr><tr><td>username</td><td>String</td><td>用户名</td><td></td><td></td></tr><tr><td>bookid</td><td>int</td><td>书号</td><td></td><td></td></tr><tr><td>bookname</td><td>String</td><td>书名</td><td></td><td></td></tr><tr><td>unitprice</td><td>double</td><td>单价</td><td></td><td></td></tr><tr><td>number</td><td>int</td><td>数量</td><td></td><td></td></tr><tr><td>totalprice</td><td>double</td><td>总价</td><td></td><td></td></tr></tbody></table><h5 id="orde表"><a href="#orde表" class="headerlink" title="orde表"></a>orde表</h5><table><thead><tr><th>字段名</th><th>数据类型</th><th>实际列名</th><th>约束</th><th>备注</th></tr></thead><tbody><tr><td>orderid</td><td>int</td><td>订单号</td><td>PRIMARY KEY</td><td></td></tr><tr><td>userid</td><td>int</td><td>用户号</td><td></td><td></td></tr><tr><td>name</td><td>String</td><td>收货人</td><td></td><td></td></tr><tr><td>address</td><td>String</td><td>收货地址</td><td></td><td></td></tr><tr><td>pay</td><td>int</td><td>支付状态</td><td></td><td></td></tr><tr><td>time</td><td>datetime</td><td>时间</td><td></td><td></td></tr><tr><td>price</td><td>double</td><td>价格</td><td></td><td></td></tr></tbody></table><h5 id="comment表"><a href="#comment表" class="headerlink" title="comment表"></a>comment表</h5><table><thead><tr><th>字段名</th><th>数据类型</th><th>实际列名</th><th>约束</th><th>备注</th></tr></thead><tbody><tr><td>commentid</td><td>int</td><td>评论编号</td><td>PRIMARY KEY</td><td></td></tr><tr><td>bookid</td><td>int</td><td>书号</td><td></td><td></td></tr><tr><td>username</td><td>String</td><td>用户名</td><td></td><td></td></tr><tr><td>text</td><td>String</td><td>评论内容</td><td></td><td></td></tr></tbody></table><h5 id="book表"><a href="#book表" class="headerlink" title="book表"></a>book表</h5><table><thead><tr><th>字段名</th><th>数据类型</th><th>实际列名</th><th>约束</th><th>备注</th></tr></thead><tbody><tr><td>bookid</td><td>int</td><td>书号</td><td>PRIMARY KEY</td><td></td></tr><tr><td>bookname</td><td>String</td><td>书名</td><td></td><td></td></tr><tr><td>cover</td><td>String</td><td>封面</td><td></td><td></td></tr><tr><td>author</td><td>String</td><td>作者</td><td></td><td></td></tr><tr><td>publish</td><td>String</td><td>出版社</td><td></td><td></td></tr><tr><td>category</td><td>String</td><td>种类</td><td></td><td></td></tr><tr><td>price</td><td>String</td><td>价格</td><td></td><td></td></tr><tr><td>tjsm</td><td>int</td><td>是否推荐</td><td></td><td></td></tr><tr><td>text</td><td>String</td><td>书简介</td><td></td><td></td></tr><tr><td>buy_number</td><td>int</td><td>购买数量</td><td></td><td></td></tr></tbody></table><p><strong>3、整体设计：</strong></p><h1 id="三、课程设计具体内容"><a href="#三、课程设计具体内容" class="headerlink" title="三、课程设计具体内容"></a>三、课程设计具体内容</h1><p><strong>（1）系统各功能的实现介绍</strong></p><h5 id="1、登陆注册"><a href="#1、登陆注册" class="headerlink" title="1、登陆注册"></a>1、登陆注册</h5><p>登陆注册功能不再是一个另外的页面，而是嵌套在了主页面中，会从右面滑出一个窗口，选择进行登录或者注册的功能。</p><p><img src="G:/%E9%A1%B9%E7%9B%AE/book_store/media/c4a8b86bbfa407c35bf0cf7cbeb2f079.png" alt=""></p><h5 id="2、查看推荐书籍"><a href="#2、查看推荐书籍" class="headerlink" title="2、查看推荐书籍"></a>2、查看推荐书籍</h5><p>在主页面中，你可以看到为用户推荐的书籍，用户还可以滑动页面进行查看，轮播推荐。</p><h5 id="media-image2-png"><a href="#media-image2-png" class="headerlink" title="./media/image2.png"></a><a href="./media/image2.png">./media/image2.png</a></h5><p>3、查看畅销书籍</p><p>在主页面中，你可以看到为用户展示的畅销书籍。</p><p><img src="G:/%E9%A1%B9%E7%9B%AE/book_store/media/c0529a2706122ae7a0a166ac6b4ab72d.png" alt=""></p><h5 id="4、：查看最新书籍"><a href="#4、：查看最新书籍" class="headerlink" title="4、：查看最新书籍"></a>4、：查看最新书籍</h5><p>在主页面中，你可以看到为用户展示的最新书籍。</p><h5 id="media-image4-png"><a href="#media-image4-png" class="headerlink" title="./media/image4.png"></a><a href="./media/image4.png">./media/image4.png</a></h5><p>5、查看图书</p><p>在全部页面，用户还可以查看全部图书，进行选择图书。还可以点击自己感兴趣的书籍点开进行单个图书的查看，再进行相关操作，下面还有对此书籍的查看。单个图书查看的时候还可以返回上一层目录。</p><p><img src="G:/%E9%A1%B9%E7%9B%AE/book_store/media/890c64cc83eb35b5288c1b310012ec71.png" alt=""></p><p><img src="G:/%E9%A1%B9%E7%9B%AE/book_store/media/f293293d64565833d3e3ed2c1712882e.png" alt=""></p><h5 id="6、查询功能"><a href="#6、查询功能" class="headerlink" title="6、查询功能"></a>6、查询功能</h5><p>在页面左上角处，有一个搜索框，用户可以根据自身情况进行查询。</p><h5 id="media-image7-png"><a href="#media-image7-png" class="headerlink" title="./media/image7.png"></a><a href="./media/image7.png">./media/image7.png</a></h5><p>购物车</p><p>用户可以根据自身情况，将自己喜欢的图书加入购物车，购物车的设计也是在页面右侧滑出进行查看。点击右上角的购物车图标即可进行查看。还可以在购物车中进行删除书籍并且查看当前已选书籍的价格。</p><p><img src="G:/%E9%A1%B9%E7%9B%AE/book_store/media/fdf8b1ad3163d797f836878bf1be1211.png" alt=""></p><h5 id="图书的购买"><a href="#图书的购买" class="headerlink" title="图书的购买"></a>图书的购买</h5><p>用户不仅可以在购物车中进行全部图书的购买，而且还可以进行单个图书的购买。全部购买在购物车中，单个书籍的购买可以直接点击单本书右下角的购物车。</p><p><img src="G:/%E9%A1%B9%E7%9B%AE/book_store/media/f293293d64565833d3e3ed2c1712882e.png" alt=""></p><h5 id="个人中心"><a href="#个人中心" class="headerlink" title="个人中心"></a>个人中心</h5><p>用户只有在登录后，才可以进入个人中心进行管理。个人中心中可以修改密码，查看个人的订单记录，退出登录。</p><p><img src="G:/%E9%A1%B9%E7%9B%AE/book_store/media/a20e2ad01831d29fac4723d7000db021.png" alt=""></p><p><img src="G:/%E9%A1%B9%E7%9B%AE/book_store/media/00f5c46ce870c9372a38f45edf63fa62.png" alt=""></p><p><img src="G:/%E9%A1%B9%E7%9B%AE/book_store/media/ca39e39b4d5a18be69f499b18d77ccc0.png" alt=""></p><h5 id="联系我们"><a href="#联系我们" class="headerlink" title="联系我们"></a>联系我们</h5><p><img src="G:/%E9%A1%B9%E7%9B%AE/book_store/media/6e4469371edf7a715b5874a7a92e358a.png" alt=""></p><p><img src="G:/%E9%A1%B9%E7%9B%AE/book_store/media/3838500e5c6e5ff190e365d73a5b7d26.png" alt=""></p><h5 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h5><p><img src="G:/%E9%A1%B9%E7%9B%AE/book_store/media/6903a6c878b32e8557fc7d13a69e1673.png" alt=""></p><p><strong>（2）管理员功能的实现</strong></p><h5 id="书籍的添加"><a href="#书籍的添加" class="headerlink" title="书籍的添加"></a>书籍的添加</h5><p><img src="G:/%E9%A1%B9%E7%9B%AE/book_store/media/e0a353d4958f72b1000735dc420d3543.png" alt="IMG_256"></p><h5 id="书籍的修改"><a href="#书籍的修改" class="headerlink" title="书籍的修改"></a>书籍的修改</h5><p><img src="G:/%E9%A1%B9%E7%9B%AE/book_store/media/e0a353d4958f72b1000735dc420d3543.png" alt="IMG_256"></p><h5 id="书籍的删除"><a href="#书籍的删除" class="headerlink" title="书籍的删除"></a>书籍的删除</h5><p><img src="G:/%E9%A1%B9%E7%9B%AE/book_store/media/848039e28aa7aa3203593cd6d85e1b2c.png" alt="IMG_256"></p><h5 id="查看全部图书"><a href="#查看全部图书" class="headerlink" title="查看全部图书"></a>查看全部图书</h5><p><img src="G:/%E9%A1%B9%E7%9B%AE/book_store/media/66950f76bf9ec3931c30f29ff34b34e0.png" alt="IMG_256"></p><h5 id="查看单个图书"><a href="#查看单个图书" class="headerlink" title="查看单个图书"></a>查看单个图书</h5><p><img src="G:/%E9%A1%B9%E7%9B%AE/book_store/media/2b1aeb45a989171f18c1b43a3dcd36b5.png" alt="IMG_256"></p><ol><li><strong>修改密码</strong></li></ol><p><img src="G:/%E9%A1%B9%E7%9B%AE/book_store/media/2b1aeb45a989171f18c1b43a3dcd36b5.png" alt="IMG_256"></p><h1 id="四、相关技术的运用"><a href="#四、相关技术的运用" class="headerlink" title="四、相关技术的运用"></a>四、相关技术的运用</h1><p>Jquery、CSS、JS、jsp、el/jstl 前端显示页面</p><p>servlet，javabean 后端</p><p>上传 管理员端上传图片</p><h1 id="系统亮点"><a href="#系统亮点" class="headerlink" title="系统亮点"></a>系统亮点</h1><p>界面美观大方，功能整体齐全，细节到位，操作易懂，人性化。</p><h1 id="系统地址及使用说明"><a href="#系统地址及使用说明" class="headerlink" title="系统地址及使用说明"></a>系统地址及使用说明</h1><h5 id="系统地址："><a href="#系统地址：" class="headerlink" title="系统地址："></a>系统地址：</h5><p><a href="http://192.144.130.39:8080/book_store/indexList" target="_blank" rel="noopener">http://192.144.130.39:8080/book_store/indexList</a></p><h5 id="系统使用说明："><a href="#系统使用说明：" class="headerlink" title="系统使用说明："></a>系统使用说明：</h5><p>用户登录账号：</p><p><img src="G:/%E9%A1%B9%E7%9B%AE/book_store/media/e3b7d64d01548612fc83087333e254df.png" alt=""></p><p>用户登陆后才可以进行个人中心的查看以及图书的购买，在购买后填写信息时大多都是自动填充，也可自行修改。</p><p>登陆后用户可根据自身兴趣进行图书的搜寻，也可以查看最新或者最热图书，点开图书后，用户可查看图书信息或者购买。</p><h5 id="管理员系统地址："><a href="#管理员系统地址：" class="headerlink" title="管理员系统地址："></a>管理员系统地址：</h5><p><a href="http://192.144.130.39:8080/web11/login.jsp" target="_blank" rel="noopener">http://192.144.130.39:8080/web11/login.jsp</a></p><h5 id="管理员系统说明："><a href="#管理员系统说明：" class="headerlink" title="管理员系统说明："></a>管理员系统说明：</h5><p>管理员登录账号：</p><p><img src="G:/%E9%A1%B9%E7%9B%AE/book_store/media/c8267ba6d1fc8c80c52bf6ee5464ec4e.png" alt=""></p><p>管理员登陆后即可对前台图书进行查看、修改、添加、删除等操作。</p><h1 id="七、系统中存在的不足"><a href="#七、系统中存在的不足" class="headerlink" title="七、系统中存在的不足"></a>七、系统中存在的不足</h1><p>1、登陆注册页面只能来回点击三次。</p><p>2、单个图书只能添加一次购物车。</p><p>3、管理员端不能显示图片。</p><h1 id="八、小组成员分工"><a href="#八、小组成员分工" class="headerlink" title="八、小组成员分工"></a>八、小组成员分工</h1><h1 id="九、课程设计收获"><a href="#九、课程设计收获" class="headerlink" title="九、课程设计收获"></a>九、课程设计收获</h1><p>第一、当接到项目任务后，首先分析其需求，然后分析其功能，将功能分模块化实现，最后测试。</p><p>第二、编程只是一个工具，是最简单的，思想才是最重要的。</p><p>第三、编程需要严谨的逻辑思维。</p><p>第四、对于小组合作，应该分工协作，每人负责一个或多个模块，尽力把其功能实现好接口做好，方便其他人使用也方便自己维护。</p><p>第五、变量和函数命名要反映其意义，名称的定义能使人一目了然。</p><h1 id="十、课程设计后的体会和建议"><a href="#十、课程设计后的体会和建议" class="headerlink" title="十、课程设计后的体会和建议"></a>十、课程设计后的体会和建议</h1><p>第一，兴趣。兴趣是最好的老师，只有我们感兴趣了，才会愿意去把一件事情做好。</p><p>第二，坚持。凡是贵在坚持，坚持了，成功才属于我们。</p><p>第三，参与到课程设计中去。很多东西想象的跟实际做起来是很不一样的。想起来很容易，做起来却不是那么简单的。一个很小的事情，如果不考虑清楚，就会出错。</p><p>第四，精益求精。实现功能的方法有很多，哪一种方法更好呢，多分析思考，不仅锻炼了我们的思维能力，而且增强了我们功能的健壮性和稳定性以及可移植性。</p><p>第五，善于总结。并不是说事情做完了就完了，而应该好好分析这件事情做完了有什么收获，遇到了什么问题，是如何解决的，下次再做这样的事情能不能做到更好。</p><p>第六，团结协作。既然是小组完成一个项目，那么每个成员都应该参与到项目中来，这样才能达到最好的效果，效率最高，而且可以相互学习，提高工作的干劲。</p>]]></content>
      
      
      <categories>
          
          <category> java web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程设计 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
